{"ast":null,"code":"import _isNumber from \"lodash/isNumber\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /* eslint-disable no-negated-condition */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { extent } from 'd3-array';\nimport { scaleThreshold } from 'd3-scale';\nimport { getSequentialSchemeRegistry, SequentialScheme } from '@superset-ui/core';\n\nimport { hexToRGB } from './utils/colors';\nconst DEFAULT_NUM_BUCKETS = 10;\nexport function getBreakPoints({ break_points: formDataBreakPoints, num_buckets: formDataNumBuckets }, features, accessor) {\n  if (!features) {\n    return [];\n  }\n  if (formDataBreakPoints === undefined || formDataBreakPoints.length === 0) {\n    // compute evenly distributed break points based on number of buckets\n    const numBuckets = formDataNumBuckets ?\n    parseInt(formDataNumBuckets, 10) :\n    DEFAULT_NUM_BUCKETS;\n    const [minValue, maxValue] = extent(features, accessor).map((value) => typeof value === 'string' ? parseFloat(value) : value);\n    if (minValue === undefined || maxValue === undefined) {\n      return [];\n    }\n    const delta = (maxValue - minValue) / numBuckets;\n    const precision = delta === 0 ? 0 : Math.max(0, Math.ceil(Math.log10(1 / delta)));\n    const extraBucket = maxValue > parseFloat(maxValue.toFixed(precision)) ? 1 : 0;\n    const startValue = minValue < parseFloat(minValue.toFixed(precision)) ?\n    minValue - 1 :\n    minValue;\n    return new Array(numBuckets + 1 + extraBucket).\n    fill(0).\n    map((_, i) => (startValue + i * delta).toFixed(precision));\n  }\n  return formDataBreakPoints.sort((a, b) => parseFloat(a) - parseFloat(b));\n}\nexport function getBreakPointColorScaler({ break_points: formDataBreakPoints, num_buckets: formDataNumBuckets, linear_color_scheme: linearColorScheme, opacity }, features, accessor) {\n  const breakPoints = formDataBreakPoints || formDataNumBuckets ?\n  getBreakPoints({\n    break_points: formDataBreakPoints,\n    num_buckets: formDataNumBuckets\n  }, features, accessor) :\n  null;\n  const colorScheme = Array.isArray(linearColorScheme) ?\n  new SequentialScheme({\n    colors: linearColorScheme,\n    id: 'custom'\n  }) :\n  getSequentialSchemeRegistry().get(linearColorScheme);\n  if (!colorScheme) {\n    return null;\n  }\n  let scaler;\n  let maskPoint;\n  if (breakPoints !== null) {\n    // bucket colors into discrete colors\n    const n = breakPoints.length - 1;\n    const bucketedColors = n > 1 ?\n    colorScheme.getColors(n) :\n    [colorScheme.colors[colorScheme.colors.length - 1]];\n    // repeat ends\n    const first = bucketedColors[0];\n    const last = bucketedColors[bucketedColors.length - 1];\n    bucketedColors.unshift(first);\n    bucketedColors.push(last);\n    const points = breakPoints.map(parseFloat);\n    scaler = scaleThreshold().\n    domain(points).\n    range(bucketedColors);\n    maskPoint = (value) => !!value && (value > points[n] || value < points[0]);\n  } else\n  {\n    // interpolate colors linearly\n    const linearScaleDomain = extent(features, accessor);\n    if (!linearScaleDomain.some(_isNumber)) {\n      scaler = colorScheme.createLinearScale();\n    } else\n    {\n      scaler = colorScheme.createLinearScale(extent(features, accessor));\n    }\n    maskPoint = () => false;\n  }\n  return (d) => {\n    const v = accessor(d);\n    if (!v) {\n      return [0, 0, 0, 0];\n    }\n    const c = hexToRGB(scaler(v));\n    if (maskPoint(v)) {\n      c[3] = 0;\n    } else\n    {\n      c[3] = opacity / 100 * 255;\n    }\n    return c;\n  };\n}\nexport function getBuckets(fd, features, accessor) {\n  const breakPoints = getBreakPoints(fd, features, accessor);\n  const colorScaler = getBreakPointColorScaler(fd, features, accessor);\n  const buckets = {};\n  breakPoints.slice(1).forEach((value, i) => {\n    const range = `${breakPoints[i]} - ${breakPoints[i + 1]}`;\n    const mid = 0.5 * (parseFloat(breakPoints[i]) + parseFloat(breakPoints[i + 1]));\n    // fix polygon doesn't show\n    const metricLabel = fd.metric ? fd.metric.label || fd.metric : null;\n    buckets[range] = {\n      color: colorScaler == null ? void 0 : colorScaler({ [metricLabel || fd.metric]: mid }),\n      enabled: true\n    };\n  });\n  return buckets;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(DEFAULT_NUM_BUCKETS, \"DEFAULT_NUM_BUCKETS\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils.ts\");reactHotLoader.register(getBreakPoints, \"getBreakPoints\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils.ts\");reactHotLoader.register(getBreakPointColorScaler, \"getBreakPointColorScaler\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils.ts\");reactHotLoader.register(getBuckets, \"getBuckets\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["extent","scaleThreshold","getSequentialSchemeRegistry","SequentialScheme","hexToRGB","DEFAULT_NUM_BUCKETS","getBreakPoints","break_points","formDataBreakPoints","num_buckets","formDataNumBuckets","features","accessor","undefined","length","numBuckets","parseInt","minValue","maxValue","map","value","parseFloat","delta","precision","Math","max","ceil","log10","extraBucket","toFixed","startValue","Array","fill","_","i","sort","a","b","getBreakPointColorScaler","linear_color_scheme","linearColorScheme","opacity","breakPoints","colorScheme","isArray","colors","id","get","scaler","maskPoint","n","bucketedColors","getColors","first","last","unshift","push","points","domain","range","linearScaleDomain","some","_isNumber","createLinearScale","d","v","c","getBuckets","fd","colorScaler","buckets","slice","forEach","mid","metricLabel","metric","label","color","enabled","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils.ts"],"sourcesContent":["/* eslint-disable no-negated-condition */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { extent } from 'd3-array';\nimport { ScaleLinear, ScaleThreshold, scaleThreshold } from 'd3-scale';\nimport {\n  getSequentialSchemeRegistry,\n  JsonObject,\n  QueryFormData,\n  SequentialScheme,\n} from '@superset-ui/core';\nimport { isNumber } from 'lodash';\nimport { hexToRGB } from './utils/colors';\n\nconst DEFAULT_NUM_BUCKETS = 10;\n\nexport type Buckets = {\n  break_points: string[];\n  num_buckets: string;\n};\n\nexport type BucketsWithColorScale = Buckets & {\n  linear_color_scheme: string | string[];\n  opacity: number;\n};\n\nexport function getBreakPoints(\n  {\n    break_points: formDataBreakPoints,\n    num_buckets: formDataNumBuckets,\n  }: Buckets,\n  features: JsonObject[],\n  accessor: (value: JsonObject) => number | undefined,\n) {\n  if (!features) {\n    return [];\n  }\n  if (formDataBreakPoints === undefined || formDataBreakPoints.length === 0) {\n    // compute evenly distributed break points based on number of buckets\n    const numBuckets = formDataNumBuckets\n      ? parseInt(formDataNumBuckets, 10)\n      : DEFAULT_NUM_BUCKETS;\n    const [minValue, maxValue] = extent<JsonObject, number>(\n      features,\n      accessor,\n    ).map((value: number | string | undefined) =>\n      typeof value === 'string' ? parseFloat(value) : value,\n    );\n    if (minValue === undefined || maxValue === undefined) {\n      return [];\n    }\n    const delta = (maxValue - minValue) / numBuckets;\n    const precision =\n      delta === 0 ? 0 : Math.max(0, Math.ceil(Math.log10(1 / delta)));\n    const extraBucket =\n      maxValue > parseFloat(maxValue.toFixed(precision)) ? 1 : 0;\n    const startValue =\n      minValue < parseFloat(minValue.toFixed(precision))\n        ? minValue - 1\n        : minValue;\n\n    return new Array(numBuckets + 1 + extraBucket)\n      .fill(0)\n      .map((_, i) => (startValue + i * delta).toFixed(precision));\n  }\n\n  return formDataBreakPoints.sort(\n    (a: string, b: string) => parseFloat(a) - parseFloat(b),\n  );\n}\n\nexport function getBreakPointColorScaler(\n  {\n    break_points: formDataBreakPoints,\n    num_buckets: formDataNumBuckets,\n    linear_color_scheme: linearColorScheme,\n    opacity,\n  }: BucketsWithColorScale,\n  features: JsonObject[],\n  accessor: (value: JsonObject) => number | undefined,\n) {\n  const breakPoints =\n    formDataBreakPoints || formDataNumBuckets\n      ? getBreakPoints(\n          {\n            break_points: formDataBreakPoints,\n            num_buckets: formDataNumBuckets,\n          },\n          features,\n          accessor,\n        )\n      : null;\n  const colorScheme = Array.isArray(linearColorScheme)\n    ? new SequentialScheme({\n        colors: linearColorScheme,\n        id: 'custom',\n      })\n    : getSequentialSchemeRegistry().get(linearColorScheme);\n\n  if (!colorScheme) {\n    return null;\n  }\n  let scaler: ScaleLinear<string, string> | ScaleThreshold<number, string>;\n  let maskPoint: (v: number | undefined) => boolean;\n  if (breakPoints !== null) {\n    // bucket colors into discrete colors\n    const n = breakPoints.length - 1;\n    const bucketedColors =\n      n > 1\n        ? colorScheme.getColors(n)\n        : [colorScheme.colors[colorScheme.colors.length - 1]];\n\n    // repeat ends\n    const first = bucketedColors[0];\n    const last = bucketedColors[bucketedColors.length - 1];\n    bucketedColors.unshift(first);\n    bucketedColors.push(last);\n\n    const points = breakPoints.map(parseFloat);\n    scaler = scaleThreshold<number, string>()\n      .domain(points)\n      .range(bucketedColors);\n    maskPoint = value => !!value && (value > points[n] || value < points[0]);\n  } else {\n    // interpolate colors linearly\n    const linearScaleDomain = extent(features, accessor);\n    if (!linearScaleDomain.some(isNumber)) {\n      scaler = colorScheme.createLinearScale();\n    } else {\n      scaler = colorScheme.createLinearScale(\n        extent(features, accessor) as number[],\n      );\n    }\n    maskPoint = () => false;\n  }\n\n  return (d: JsonObject): [number, number, number, number] => {\n    const v = accessor(d);\n    if (!v) {\n      return [0, 0, 0, 0];\n    }\n    const c = hexToRGB(scaler(v));\n    if (maskPoint(v)) {\n      c[3] = 0;\n    } else {\n      c[3] = (opacity / 100) * 255;\n    }\n\n    return c;\n  };\n}\n\nexport function getBuckets(\n  fd: QueryFormData & BucketsWithColorScale,\n  features: JsonObject[],\n  accessor: (value: JsonObject) => number | undefined,\n) {\n  const breakPoints = getBreakPoints(fd, features, accessor);\n  const colorScaler = getBreakPointColorScaler(fd, features, accessor);\n  const buckets = {};\n  breakPoints.slice(1).forEach((value, i) => {\n    const range = `${breakPoints[i]} - ${breakPoints[i + 1]}`;\n    const mid =\n      0.5 * (parseFloat(breakPoints[i]) + parseFloat(breakPoints[i + 1]));\n    // fix polygon doesn't show\n    const metricLabel = fd.metric ? fd.metric.label || fd.metric : null;\n    buckets[range] = {\n      color: colorScaler?.({ [metricLabel || fd.metric]: mid }),\n      enabled: true,\n    };\n  });\n\n  return buckets;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}