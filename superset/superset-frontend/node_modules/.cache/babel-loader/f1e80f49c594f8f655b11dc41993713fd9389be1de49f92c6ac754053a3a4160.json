{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default =\n\nfunction (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: { top: 24, right: 0, bottom: 12, left: 0 },\n    nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: []\n  };\n\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight;\n\n    // canvas data layers\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection.\n    append('svg').\n    attr('width', __.width).\n    attr('height', __.height).\n    append('svg:g').\n    attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')'\n    );\n\n    return pc;\n  };\n  var events = d3.dispatch.apply(\n      this,\n      [\n      'render',\n      'resize',\n      'highlight',\n      'brush',\n      'brushend',\n      'axesreorder'].\n      concat(d3.keys(__))\n    ),\n    w = function () {\n      return __.width - __.margin.right - __.margin.left;\n    },\n    h = function () {\n      return __.height - __.margin.top - __.margin.bottom;\n    },\n    flags = {\n      brushable: false,\n      reorderable: false,\n      axes: false,\n      interactive: false,\n      debug: false\n    },\n    xscale = d3.scale.ordinal(),\n    yscale = {},\n    dragging = {},\n    line = d3.svg.line(),\n    axis = d3.svg.axis().orient('left').ticks(5),\n    g, // groups for axes, brushes\n    ctx = {},\n    canvas = {},\n    clusterCentroids = [];\n\n  // side effects for setters\n  var side_effects = d3.dispatch.\n  apply(this, d3.keys(__)).\n  on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).\n  on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).\n  on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).\n  on('width', function (d) {\n    pc.resize();\n  }).\n  on('height', function (d) {\n    pc.resize();\n  }).\n  on('margin', function (d) {\n    pc.resize();\n  }).\n  on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).\n  on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).\n  on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).\n  on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  });\n\n  // expose the state of the chart\n  pc.state = __;\n  pc.flags = flags;\n\n  // create getter/setters\n  getset(pc, __, events);\n\n  // expose events\n  d3.rebind(pc, events, 'on');\n\n  // getter/setter with event firing\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, { value: x, previous: old });\n        events[key].call(pc, { value: x, previous: old });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [\n      h() +\n      1 -\n      __.nullValueSeparatorPadding.bottom -\n      __.nullValueSeparatorPadding.top,\n      1];\n\n    } else if (__.nullValueSeparator == 'top') {\n      return [\n      h() + 1,\n      1 +\n      __.nullValueSeparatorPadding.bottom +\n      __.nullValueSeparatorPadding.top];\n\n    }\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n          domain = [];\n\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      }\n    };\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    // xscale\n    xscale.rangePoints([0, w()], 1);\n\n    // canvas sizes\n    pc.selection.\n    selectAll('canvas').\n    style('margin-top', __.margin.top + 'px').\n    style('margin-left', __.margin.left + 'px').\n    attr('width', w() + 2).\n    attr('height', h() + 2);\n\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // scales of the same type\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(\n        scales.\n        map(function (p, i) {\n          return yscale[p].domain();\n        }).\n        reduce(function (a, b) {\n          return a.concat(b);\n        })\n      );\n\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(\n          d3.extent(__.data, function (d) {\n            return +d[k];\n          })\n        );\n      });\n    }\n\n    // update centroids\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  };\n\n  // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n  pc.toType = function (v) {\n    return {}.toString.\n    call(v).\n    match(/\\s([a-zA-Z]+)/)[1].\n    toLowerCase();\n  };\n\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n    return pc.toType(v);\n  };\n\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.\n  renderQueue(path_foreground).\n  rate(50).\n  clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.\n  renderQueue(path_brushed).\n  rate(50).\n  clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map();\n    // determine clusterCounts\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y]));\n\n      // centroids on 'virtual' axes\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i]);\n          var rightCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i + 1]);\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n\n    cps.push(centroids[0]);\n    cps.push(\n      $V([\n      centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)),\n      centroids[0].e(2)]\n      )\n    );\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n    cps.push(\n      $V([\n      centroids[cols - 1].e(1) +\n      a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)),\n      centroids[cols - 1].e(2)]\n      )\n    );\n    cps.push(centroids[cols - 1]);\n\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n\n  // draw dots with radius r on the axis line where data intersects\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return this;\n  };\n\n  // draw single cubic bezier curve\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n      ctx.bezierCurveTo(\n        cps[i].e(1),\n        cps[i].e(2),\n        cps[i + 1].e(1),\n        cps[i + 1].e(2),\n        cps[i + 2].e(1),\n        cps[i + 2].e(2)\n      );\n    }\n  }\n\n  // draw single polyline\n  function color_path(d, ctx) {\n    ctx.beginPath();\n    if (\n    __.bundleDimension !== null && __.bundlingStrength > 0 ||\n    __.smoothness > 0)\n    {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n    ctx.stroke();\n  }\n\n  // draw many polylines of the same color\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (\n      __.bundleDimension !== null && __.bundlingStrength > 0 ||\n      __.smoothness > 0)\n      {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  }\n\n  // returns the y-position just beyond the separating null value line\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\n        \"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\"\n      );\n    }\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p])\n        );\n      } else {\n        ctx.lineTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p])\n        );\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n    return this;\n  };\n\n  d3.rebind(\n    pc,\n    axis,\n    'ticks',\n    'orient',\n    'tickValues',\n    'tickSubdivide',\n    'tickSize',\n    'tickPadding',\n    'tickFormat'\n  );\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n\n    pc.flip(dimension);\n\n    d3.select(this.parentElement).\n    transition().\n    duration(1100).\n    call(axis.scale(yscale[dimension]));\n\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n\n    __.dimensionTitleRotation += delta;\n    pc.svg.\n    selectAll('text.label').\n    attr(\n      'transform',\n      'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'\n    );\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes();\n\n    // Add a group element for each dimension.\n    g = pc.svg.\n    selectAll('.dimension').\n    data(__.dimensions, function (d) {\n      return d;\n    }).\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    });\n\n    // Add an axis and title.\n    g.append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', 1 + __.nullValueSeparatorPadding.top).\n      attr('x2', w()).\n      attr('y2', 1 + __.nullValueSeparatorPadding.top).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('x2', w()).\n      attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions);\n\n    // Enter\n    g_data.\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 0).\n    append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data.\n    select('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.\n    select('.label').\n    transition().\n    duration(1100).\n    text(dimensionLabels).\n    attr(\n      'transform',\n      'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'\n    );\n\n    // Exit\n    g_data.exit().remove();\n\n    g = pc.svg.selectAll('.dimension');\n    g.transition().\n    duration(1100).\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 1);\n\n    pc.svg.\n    selectAll('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return this;\n  };\n\n  // Jason Davies, http://bl.ocks.org/1341281\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n\n    g.style('cursor', 'move').call(\n      d3.behavior.\n      drag().\n      on('dragstart', function (d) {\n        dragging[d] = this.__origin__ = xscale(d);\n      }).\n      on('drag', function (d) {\n        dragging[d] = Math.min(\n          w(),\n          Math.max(0, this.__origin__ += d3.event.dx)\n        );\n        __.dimensions.sort(function (a, b) {\n          return position(a) - position(b);\n        });\n        xscale.domain(__.dimensions);\n        pc.render();\n        g.attr('transform', function (d) {\n          return 'translate(' + position(d) + ')';\n        });\n      }).\n      on('dragend', function (d) {\n        // Let's see if the order has changed and send out an event if so.\n        var i = 0,\n          j = __.dimensions.indexOf(d),\n          elem = this,\n          parent = this.parentElement;\n\n        while ((elem = elem.previousElementSibling) != null) ++i;\n        if (i !== j) {\n          events.axesreorder.call(pc, __.dimensions);\n          // We now also want to reorder the actual dom elements that represent\n          // the axes. That is, the g.dimension elements. If we don't do this,\n          // we get a weird and confusing transition when updateAxes is called.\n          // This is due to the fact that, initially the nth g.dimension element\n          // represents the nth axis. However, after a manual reordering,\n          // without reordering the dom elements, the nth dom elements no longer\n          // necessarily represents the nth axis.\n          //\n          // i is the original index of the dom element\n          // j is the new index of the dom element\n          if (i > j) {\n            // Element moved left\n            parent.insertBefore(this, parent.children[j - 1]);\n          } else {\n            // Element moved right\n            if (j + 1 < parent.children.length) {\n              parent.insertBefore(this, parent.children[j + 1]);\n            } else {\n              parent.appendChild(this);\n            }\n          }\n        }\n\n        delete this.__origin__;\n        delete dragging[d];\n        d3.select(this).\n        transition().\n        attr('transform', 'translate(' + xscale(d) + ')');\n        pc.render();\n      })\n    );\n    flags.reorderable = true;\n    return this;\n  };\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n      return pixelDifference;\n    });\n\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n      var highlighted = __.highlighted.slice(0);\n      pc.unhighlight();\n\n      g.transition().\n      duration(1500).\n      attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  };\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {}, // Nothing to be done.\n        uninstall: function (pc) {}, // Nothing to be done.\n        selected: function () {\n          return [];\n        }, // Nothing to return\n        brushState: function () {\n          return {};\n        }\n      }\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    }\n  };\n\n  // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brush.modes[brush.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  };\n\n  // brush mode: 1D-Axes\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        string: function (d, p, dimension) {\n          return (\n            extents[dimension][0] <= yscale[p](d[p]) &&\n            yscale[p](d[p]) <= extents[dimension][1]);\n\n        }\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        });\n\n        // loop over each dimension and update appropriately (if it was passed in through extents)\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]);\n\n            //redraw the brush\n            brush(brushSelections[d]);\n\n            //fire some events\n            brush.event(brushSelections[d]);\n          }\n        });\n\n        //redraw the chart\n        pc.renderBrushed();\n      }\n    }\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })();\n  // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n  (function () {\n    var strums = {},\n      strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n        id = strum.dims.i,\n        points = [strum.p1, strum.p2],\n        line = svg.selectAll('line#strum-' + id).data([strum]),\n        circles = svg.selectAll('circle#strum-' + id).data(points),\n        drag = d3.behavior.drag();\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(\n          Math.max(strum.minX + 1, ev.x),\n          strum.maxX\n        );\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          strum;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h()\n        };\n\n        strums[dims.i] = strum;\n        strums.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          strum = strums[strums.active];\n\n        // Make sure that the point is within the bounds\n        strum.p2[0] = Math.min(\n          Math.max(strum.minX + 1, ev.x - __.margin.left),\n          strum.maxX\n        );\n        strum.p2[1] = Math.min(\n          Math.max(strum.minY, ev.y - __.margin.top),\n          strum.maxY\n        );\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n        p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n        m1 = 1 - width / p1[0],\n        b1 = p1[1] * (1 - m1),\n        m2 = 1 - width / p2[0],\n        b2 = p2[1] * (1 - m2);\n\n      // test if point falls between lines\n      return function (p) {\n        var x = p[0],\n          y = p[1],\n          y1 = m1 * x + b1,\n          y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n        brushed = __.data;\n\n      // Get the ids of the currently active strums.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n          test = containmentTest(strum, strums.width(id)),\n          d1 = strum.dims.left,\n          d2 = strum.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n        svg = pc.selection.select('svg').select('g#strums');\n\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          strum = strums[strums.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (\n        strum &&\n        strum.p1[0] === strum.p2[0] &&\n        strum.p1[1] === strum.p2[1])\n        {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      strums.active = undefined;\n      // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d;\n            // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      });\n\n      // Add a new svg group in which we draw the strums.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'strums').\n      attr(\n        'transform',\n        'translate(' + __.margin.left + ',' + __.margin.top + ')'\n      );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(strums);\n\n      drag.\n      on('dragstart', onDragStart(strums)).\n      on('drag', onDrag(strums)).\n      on('dragend', onDragEnd(strums));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#strums').\n      attr('id', 'strum-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      }\n    };\n  })();\n\n  // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        }\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).\n      extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).\n      resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })();\n  // brush mode: angular\n  // code based on 2D.strums.js\n\n  (function () {\n    var arcs = {},\n      strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n        id = arc.dims.i,\n        points = [arc.p2, arc.p3],\n        line = svg.selectAll('line#arc-' + id).data([\n        { p1: arc.p1, p2: arc.p2 },\n        { p1: arc.p1, p2: arc.p3 }]\n        ),\n        circles = svg.selectAll('circle#arc-' + id).data(points),\n        drag = d3.behavior.drag(),\n        path = svg.selectAll('path#arc-' + id).data([arc]);\n\n      path.\n      enter().\n      append('path').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc').\n      style('fill', 'orange').\n      style('opacity', 0.5);\n\n      path.\n      attr('d', arc.arc).\n      attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event,\n          angle = 0;\n\n        i = i + 2;\n\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (\n        arc.startAngle < Math.PI &&\n        arc.endAngle < Math.PI &&\n        angle < Math.PI ||\n        arc.startAngle >= Math.PI &&\n        arc.endAngle >= Math.PI &&\n        angle >= Math.PI)\n        {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          arc;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0)\n        };\n\n        arcs[dims.i] = arc;\n        arcs.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          arc = arcs[arcs.active];\n\n        // Make sure that the point is within the bounds\n        arc.p2[0] = Math.min(\n          Math.max(arc.minX + 1, ev.x - __.margin.left),\n          arc.maxX\n        );\n        arc.p2[1] = Math.min(\n          Math.max(arc.minY, ev.y - __.margin.top),\n          arc.maxY\n        );\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    }\n\n    // some helper functions\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    // [0, 2*PI] -> [-PI/2, PI/2]\n    var signedAngle = function (angle) {\n      var ret = angle;\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n      return -ret;\n    };\n\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      // test if segment angle is contained in angle interval\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n        brushed = __.data;\n\n      // Get the ids of the currently active arcs.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n          test = containmentTest(arc),\n          d1 = arc.dims.left,\n          d2 = arc.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          a = arcs.width(id),\n          b = y1(d[d1]) - y2(d[d2]),\n          c = hypothenuse(a, b),\n          angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n        svg = pc.selection.select('svg').select('g#arcs');\n\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          arc = arcs[arcs.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.\n          outerRadius(arcs.length(arcs.active)).\n          startAngle(angle).\n          endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      arcs.active = undefined;\n      // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      };\n\n      // returns angles in [-PI/2, PI/2]\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n          b = p1[1] - p2[1],\n          c = hypothenuse(a, b);\n\n        return Math.asin(b / c);\n      };\n\n      // returns angles in [0, 2 * PI]\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n        var sAngle = angle(arc.p1, arc.p2),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n          b = arc.p1[1] - arc.p2[1],\n          c = hypothenuse(a, b);\n\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d;\n            // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      });\n\n      // Add a new svg group in which we draw the arcs.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'arcs').\n      attr(\n        'transform',\n        'translate(' + __.margin.left + ',' + __.margin.top + ')'\n      );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(arcs);\n\n      drag.\n      on('dragstart', onDragStart(arcs)).\n      on('drag', onDrag(arcs)).\n      on('dragend', onDragEnd(arcs));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#arcs').\n      attr('id', 'arc-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      }\n    };\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  };\n\n  // expose a few objects\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = function () {\n    // selection size\n    pc.selection.\n    select('svg').\n    attr('width', __.width).\n    attr('height', __.height);\n    pc.svg.attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')'\n    );\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin\n    });\n    return this;\n  };\n\n  // highlight an array of data\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  };\n\n  // clear highlighting\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x:\n      ((a.x * b.y - a.y * b.x) * (c.x - d.x) -\n      (a.x - b.x) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y:\n      ((a.x * b.y - a.y * b.x) * (c.y - d.y) -\n      (a.y - b.y) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))\n    };\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n  pc.version = '0.7.0';\n  // this descriptive text should live with other introspective methods\n  pc.toString = function () {\n    return (\n      'Parallel Coordinates: ' +\n      __.dimensions.length +\n      ' dimensions (' +\n      d3.keys(__.data[0]).length +\n      ' total) , ' +\n      __.data.length +\n      ' rows');\n\n  };\n\n  return pc;\n}; /* [LICENSE TBD] */ /* eslint-disable */export default _default;\n\nd3.renderQueue = function (func) {\n  var _queue = [], // data to be rendered\n    _rate = 10, // number of calls per frame\n    _clear = function () {}, // clearing function\n    _i = 0; // current iteration\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true;\n\n      // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n      var end = Math.min(_i + _rate, _queue.length);\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["_default","config","__","data","highlighted","dimensions","dimensionTitles","dimensionTitleRotation","types","brushed","brushedColor","alphaOnBrushed","mode","rate","width","height","margin","top","right","bottom","left","nullValueSeparator","nullValueSeparatorPadding","color","composite","alpha","bundlingStrength","bundleDimension","smoothness","showControlPoints","hideAxis","extend","pc","selection","d3","select","clientWidth","clientHeight","forEach","layer","canvas","append","attr","ctx","getContext","svg","events","dispatch","apply","concat","keys","w","h","flags","brushable","reorderable","axes","interactive","debug","xscale","scale","ordinal","yscale","dragging","line","axis","orient","ticks","g","clusterCentroids","side_effects","on","d","foreground","globalCompositeOperation","value","globalAlpha","strokeStyle","resize","brushedQueue","foregroundQueue","domain","render","updateAxes","length","detectDimensions","autoscale","compute_cluster_centroids","without","state","getset","rebind","obj","key","x","arguments","old","call","previous","target","source","arr","item","filter","elem","indexOf","getRange","defaultScales","date","k","extent","getTime","rangePoints","time","range","number","linear","string","counts","map","p","undefined","Object","getOwnPropertyNames","sort","a","b","selectAll","style","lineWidth","highlight","flip","reverse","commonScale","global","type","t","scales","i","reduce","detectDimensionTypes","toType","v","toString","match","toLowerCase","toTypeCoerceNumbers","parseFloat","col","renderBrushed","isBrushed","object","brush","currentMode","brushState","hasOwnProperty","default","clear","path_foreground","renderQueue","queue","path_brushed","clusterCounts","row","scaled","has","set","count","get","compute_centroids","centroids","cols","position","y","push","$V","cx","cy","leftCentroid","rightCentroid","centroid","compute_control_points","cps","e","mid","diff","subtract","add","shadows","axisDots","r","marks","startAngle","endAngle","Math","PI","min","pow","beginPath","arc","stroke","fill","single_curve","moveTo","j","fillRect","bezierCurveTo","color_path","single_path","paths","clearRect","getNullPosition","console","log","lineTo","functor","path_highlight","fillStyle","flipAxisAndUpdatePCP","dimension","parentElement","transition","duration","rotateLabels","delta","event","deltaY","preventDefault","dimensionLabels","createAxes","removeAxes","enter","each","transform","class","text","remove","g_data","exit","brushMode","behavior","drag","__origin__","max","dx","parent","previousElementSibling","axesreorder","insertBefore","children","appendChild","reorder","rowdata","dims","slice","pixelDifference","localeCompare","reordered","some","val","index","unhighlight","adjacent_pairs","ret","modes","None","install","uninstall","selected","predicate","brushUpdated","newSelection","brushPredicate","String","toUpperCase","brushModes","brushReset","brushes","is_brushed","empty","actives","extents","within","every","brushExtents","ascending","brushSelections","brushFor","sourceEvent","stopPropagation","brushend","strums","strumRect","drawStrum","strum","activePoint","id","points","p1","p2","circles","ev","minX","maxX","minY","maxY","onDragEnd","dimensionsForPoint","dim","next","onDragStart","mouse","active","onDrag","containmentTest","m1","b1","m2","b2","y1","y2","ids","isNaN","crossesStrum","test","d1","d2","point","removeStrum","consecutive","first","second","insert","multibrush","extentAdaption","resizeAdaption","arcs","p3","path","angle","innerRadius","hypothenuse","sqrt","rad","c","deg","signedAngle","tmp","asin","outerRadius","sAngle","uAngle","classed","intersection","version","func","_queue","_rate","_clear","_i","rq","invalidate","valid","doFrame","end","timer","remaining","reactHotLoader","reactHotLoaderGlobal","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js"],"sourcesContent":["/* [LICENSE TBD] */\n/* eslint-disable */\nexport default function (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: { top: 24, right: 0, bottom: 12, left: 0 },\n    nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: [],\n  };\n\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight;\n\n    // canvas data layers\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection\n      .append('svg')\n      .attr('width', __.width)\n      .attr('height', __.height)\n      .append('svg:g')\n      .attr(\n        'transform',\n        'translate(' + __.margin.left + ',' + __.margin.top + ')',\n      );\n\n    return pc;\n  };\n  var events = d3.dispatch.apply(\n      this,\n      [\n        'render',\n        'resize',\n        'highlight',\n        'brush',\n        'brushend',\n        'axesreorder',\n      ].concat(d3.keys(__)),\n    ),\n    w = function () {\n      return __.width - __.margin.right - __.margin.left;\n    },\n    h = function () {\n      return __.height - __.margin.top - __.margin.bottom;\n    },\n    flags = {\n      brushable: false,\n      reorderable: false,\n      axes: false,\n      interactive: false,\n      debug: false,\n    },\n    xscale = d3.scale.ordinal(),\n    yscale = {},\n    dragging = {},\n    line = d3.svg.line(),\n    axis = d3.svg.axis().orient('left').ticks(5),\n    g, // groups for axes, brushes\n    ctx = {},\n    canvas = {},\n    clusterCentroids = [];\n\n  // side effects for setters\n  var side_effects = d3.dispatch\n    .apply(this, d3.keys(__))\n    .on('composite', function (d) {\n      ctx.foreground.globalCompositeOperation = d.value;\n      ctx.brushed.globalCompositeOperation = d.value;\n    })\n    .on('alpha', function (d) {\n      ctx.foreground.globalAlpha = d.value;\n      ctx.brushed.globalAlpha = d.value;\n    })\n    .on('brushedColor', function (d) {\n      ctx.brushed.strokeStyle = d.value;\n    })\n    .on('width', function (d) {\n      pc.resize();\n    })\n    .on('height', function (d) {\n      pc.resize();\n    })\n    .on('margin', function (d) {\n      pc.resize();\n    })\n    .on('rate', function (d) {\n      brushedQueue.rate(d.value);\n      foregroundQueue.rate(d.value);\n    })\n    .on('dimensions', function (d) {\n      xscale.domain(__.dimensions);\n      if (flags.interactive) {\n        pc.render().updateAxes();\n      }\n    })\n    .on('bundleDimension', function (d) {\n      if (!__.dimensions.length) pc.detectDimensions();\n      if (!(__.dimensions[0] in yscale)) pc.autoscale();\n      if (typeof d.value === 'number') {\n        if (d.value < __.dimensions.length) {\n          __.bundleDimension = __.dimensions[d.value];\n        } else if (d.value < __.hideAxis.length) {\n          __.bundleDimension = __.hideAxis[d.value];\n        }\n      } else {\n        __.bundleDimension = d.value;\n      }\n\n      __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n    })\n    .on('hideAxis', function (d) {\n      if (!__.dimensions.length) pc.detectDimensions();\n      pc.dimensions(without(__.dimensions, d.value));\n    });\n\n  // expose the state of the chart\n  pc.state = __;\n  pc.flags = flags;\n\n  // create getter/setters\n  getset(pc, __, events);\n\n  // expose events\n  d3.rebind(pc, events, 'on');\n\n  // getter/setter with event firing\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, { value: x, previous: old });\n        events[key].call(pc, { value: x, previous: old });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [\n        h() +\n          1 -\n          __.nullValueSeparatorPadding.bottom -\n          __.nullValueSeparatorPadding.top,\n        1,\n      ];\n    } else if (__.nullValueSeparator == 'top') {\n      return [\n        h() + 1,\n        1 +\n          __.nullValueSeparatorPadding.bottom +\n          __.nullValueSeparatorPadding.top,\n      ];\n    }\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n          domain = [];\n\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      },\n    };\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    // xscale\n    xscale.rangePoints([0, w()], 1);\n\n    // canvas sizes\n    pc.selection\n      .selectAll('canvas')\n      .style('margin-top', __.margin.top + 'px')\n      .style('margin-left', __.margin.left + 'px')\n      .attr('width', w() + 2)\n      .attr('height', h() + 2);\n\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // scales of the same type\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(\n        scales\n          .map(function (p, i) {\n            return yscale[p].domain();\n          })\n          .reduce(function (a, b) {\n            return a.concat(b);\n          }),\n      );\n\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(\n          d3.extent(__.data, function (d) {\n            return +d[k];\n          }),\n        );\n      });\n    }\n\n    // update centroids\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  };\n\n  // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n  pc.toType = function (v) {\n    return {}.toString\n      .call(v)\n      .match(/\\s([a-zA-Z]+)/)[1]\n      .toLowerCase();\n  };\n\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n    return pc.toType(v);\n  };\n\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3\n    .renderQueue(path_foreground)\n    .rate(50)\n    .clear(function () {\n      pc.clear('foreground');\n      pc.clear('highlight');\n    });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3\n    .renderQueue(path_brushed)\n    .rate(50)\n    .clear(function () {\n      pc.clear('brushed');\n    });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map();\n    // determine clusterCounts\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y]));\n\n      // centroids on 'virtual' axes\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids\n            .get(yscale[__.bundleDimension](row[__.bundleDimension]))\n            .get(p[i]);\n          var rightCentroid = __.clusterCentroids\n            .get(yscale[__.bundleDimension](row[__.bundleDimension]))\n            .get(p[i + 1]);\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n\n    cps.push(centroids[0]);\n    cps.push(\n      $V([\n        centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)),\n        centroids[0].e(2),\n      ]),\n    );\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n    cps.push(\n      $V([\n        centroids[cols - 1].e(1) +\n          a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)),\n        centroids[cols - 1].e(2),\n      ]),\n    );\n    cps.push(centroids[cols - 1]);\n\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n\n  // draw dots with radius r on the axis line where data intersects\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return this;\n  };\n\n  // draw single cubic bezier curve\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n      ctx.bezierCurveTo(\n        cps[i].e(1),\n        cps[i].e(2),\n        cps[i + 1].e(1),\n        cps[i + 1].e(2),\n        cps[i + 2].e(1),\n        cps[i + 2].e(2),\n      );\n    }\n  }\n\n  // draw single polyline\n  function color_path(d, ctx) {\n    ctx.beginPath();\n    if (\n      (__.bundleDimension !== null && __.bundlingStrength > 0) ||\n      __.smoothness > 0\n    ) {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n    ctx.stroke();\n  }\n\n  // draw many polylines of the same color\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (\n        (__.bundleDimension !== null && __.bundlingStrength > 0) ||\n        __.smoothness > 0\n      ) {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  }\n\n  // returns the y-position just beyond the separating null value line\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\n        \"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\",\n      );\n    }\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]),\n        );\n      } else {\n        ctx.lineTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]),\n        );\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n    return this;\n  };\n\n  d3.rebind(\n    pc,\n    axis,\n    'ticks',\n    'orient',\n    'tickValues',\n    'tickSubdivide',\n    'tickSize',\n    'tickPadding',\n    'tickFormat',\n  );\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n\n    pc.flip(dimension);\n\n    d3.select(this.parentElement)\n      .transition()\n      .duration(1100)\n      .call(axis.scale(yscale[dimension]));\n\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n\n    __.dimensionTitleRotation += delta;\n    pc.svg\n      .selectAll('text.label')\n      .attr(\n        'transform',\n        'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      );\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes();\n\n    // Add a group element for each dimension.\n    g = pc.svg\n      .selectAll('.dimension')\n      .data(__.dimensions, function (d) {\n        return d;\n      })\n      .enter()\n      .append('svg:g')\n      .attr('class', 'dimension')\n      .attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n\n    // Add an axis and title.\n    g.append('svg:g')\n      .attr('class', 'axis')\n      .attr('transform', 'translate(0,0)')\n      .each(function (d) {\n        d3.select(this).call(axis.scale(yscale[d]));\n      })\n      .append('svg:text')\n      .attr({\n        'text-anchor': 'middle',\n        y: 0,\n        transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n        x: 0,\n        class: 'label',\n      })\n      .text(dimensionLabels)\n      .on('dblclick', flipAxisAndUpdatePCP)\n      .on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg\n        .append('line')\n        .attr('x1', 0)\n        .attr('y1', 1 + __.nullValueSeparatorPadding.top)\n        .attr('x2', w())\n        .attr('y2', 1 + __.nullValueSeparatorPadding.top)\n        .attr('stroke-width', 1)\n        .attr('stroke', '#777')\n        .attr('fill', 'none')\n        .attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg\n        .append('line')\n        .attr('x1', 0)\n        .attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom)\n        .attr('x2', w())\n        .attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom)\n        .attr('stroke-width', 1)\n        .attr('stroke', '#777')\n        .attr('fill', 'none')\n        .attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions);\n\n    // Enter\n    g_data\n      .enter()\n      .append('svg:g')\n      .attr('class', 'dimension')\n      .attr('transform', function (p) {\n        return 'translate(' + position(p) + ')';\n      })\n      .style('opacity', 0)\n      .append('svg:g')\n      .attr('class', 'axis')\n      .attr('transform', 'translate(0,0)')\n      .each(function (d) {\n        d3.select(this).call(axis.scale(yscale[d]));\n      })\n      .append('svg:text')\n      .attr({\n        'text-anchor': 'middle',\n        y: 0,\n        transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n        x: 0,\n        class: 'label',\n      })\n      .text(dimensionLabels)\n      .on('dblclick', flipAxisAndUpdatePCP)\n      .on('wheel', rotateLabels);\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data\n      .select('.axis')\n      .transition()\n      .duration(1100)\n      .each(function (d) {\n        d3.select(this).call(axis.scale(yscale[d]));\n      });\n    g_data\n      .select('.label')\n      .transition()\n      .duration(1100)\n      .text(dimensionLabels)\n      .attr(\n        'transform',\n        'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      );\n\n    // Exit\n    g_data.exit().remove();\n\n    g = pc.svg.selectAll('.dimension');\n    g.transition()\n      .duration(1100)\n      .attr('transform', function (p) {\n        return 'translate(' + position(p) + ')';\n      })\n      .style('opacity', 1);\n\n    pc.svg\n      .selectAll('.axis')\n      .transition()\n      .duration(1100)\n      .each(function (d) {\n        d3.select(this).call(axis.scale(yscale[d]));\n      });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return this;\n  };\n\n  // Jason Davies, http://bl.ocks.org/1341281\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n\n    g.style('cursor', 'move').call(\n      d3.behavior\n        .drag()\n        .on('dragstart', function (d) {\n          dragging[d] = this.__origin__ = xscale(d);\n        })\n        .on('drag', function (d) {\n          dragging[d] = Math.min(\n            w(),\n            Math.max(0, (this.__origin__ += d3.event.dx)),\n          );\n          __.dimensions.sort(function (a, b) {\n            return position(a) - position(b);\n          });\n          xscale.domain(__.dimensions);\n          pc.render();\n          g.attr('transform', function (d) {\n            return 'translate(' + position(d) + ')';\n          });\n        })\n        .on('dragend', function (d) {\n          // Let's see if the order has changed and send out an event if so.\n          var i = 0,\n            j = __.dimensions.indexOf(d),\n            elem = this,\n            parent = this.parentElement;\n\n          while ((elem = elem.previousElementSibling) != null) ++i;\n          if (i !== j) {\n            events.axesreorder.call(pc, __.dimensions);\n            // We now also want to reorder the actual dom elements that represent\n            // the axes. That is, the g.dimension elements. If we don't do this,\n            // we get a weird and confusing transition when updateAxes is called.\n            // This is due to the fact that, initially the nth g.dimension element\n            // represents the nth axis. However, after a manual reordering,\n            // without reordering the dom elements, the nth dom elements no longer\n            // necessarily represents the nth axis.\n            //\n            // i is the original index of the dom element\n            // j is the new index of the dom element\n            if (i > j) {\n              // Element moved left\n              parent.insertBefore(this, parent.children[j - 1]);\n            } else {\n              // Element moved right\n              if (j + 1 < parent.children.length) {\n                parent.insertBefore(this, parent.children[j + 1]);\n              } else {\n                parent.appendChild(this);\n              }\n            }\n          }\n\n          delete this.__origin__;\n          delete dragging[d];\n          d3.select(this)\n            .transition()\n            .attr('transform', 'translate(' + xscale(d) + ')');\n          pc.render();\n        }),\n    );\n    flags.reorderable = true;\n    return this;\n  };\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n      return pixelDifference;\n    });\n\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n      var highlighted = __.highlighted.slice(0);\n      pc.unhighlight();\n\n      g.transition()\n        .duration(1500)\n        .attr('transform', function (d) {\n          return 'translate(' + xscale(d) + ')';\n        });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  };\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {}, // Nothing to be done.\n        uninstall: function (pc) {}, // Nothing to be done.\n        selected: function () {\n          return [];\n        }, // Nothing to return\n        brushState: function () {\n          return {};\n        },\n      },\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    },\n  };\n\n  // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brush.modes[brush.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  };\n\n  // brush mode: 1D-Axes\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]\n            );\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]\n            );\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]\n            );\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]\n            );\n          }\n        },\n        string: function (d, p, dimension) {\n          return (\n            extents[dimension][0] <= yscale[p](d[p]) &&\n            yscale[p](d[p]) <= extents[dimension][1]\n          );\n        },\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        });\n\n        // loop over each dimension and update appropriately (if it was passed in through extents)\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]);\n\n            //redraw the brush\n            brush(brushSelections[d]);\n\n            //fire some events\n            brush.event(brushSelections[d]);\n          }\n        });\n\n        //redraw the chart\n        pc.renderBrushed();\n      }\n    }\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n\n      brush\n        .y(yscale[axis])\n        .on('brushstart', function () {\n          if (d3.event.sourceEvent !== null) {\n            d3.event.sourceEvent.stopPropagation();\n          }\n        })\n        .on('brush', function () {\n          brushUpdated(selected());\n        })\n        .on('brushend', function () {\n          events.brushend.call(pc, __.brushed);\n        });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g')\n        .attr('class', 'brush')\n        .each(function (d) {\n          d3.select(this).call(brushFor(d));\n        })\n        .selectAll('rect')\n        .style('visibility', null)\n        .attr('x', -15)\n        .attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents,\n    };\n  })();\n  // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n  (function () {\n    var strums = {},\n      strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n        id = strum.dims.i,\n        points = [strum.p1, strum.p2],\n        line = svg.selectAll('line#strum-' + id).data([strum]),\n        circles = svg.selectAll('circle#strum-' + id).data(points),\n        drag = d3.behavior.drag();\n\n      line\n        .enter()\n        .append('line')\n        .attr('id', 'strum-' + id)\n        .attr('class', 'strum');\n\n      line\n        .attr('x1', function (d) {\n          return d.p1[0];\n        })\n        .attr('y1', function (d) {\n          return d.p1[1];\n        })\n        .attr('x2', function (d) {\n          return d.p2[0];\n        })\n        .attr('y2', function (d) {\n          return d.p2[1];\n        })\n        .attr('stroke', 'black')\n        .attr('stroke-width', 2);\n\n      drag\n        .on('drag', function (d, i) {\n          var ev = d3.event;\n          i = i + 1;\n          strum['p' + i][0] = Math.min(\n            Math.max(strum.minX + 1, ev.x),\n            strum.maxX,\n          );\n          strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n          drawStrum(strum, i - 1);\n        })\n        .on('dragend', onDragEnd());\n\n      circles\n        .enter()\n        .append('circle')\n        .attr('id', 'strum-' + id)\n        .attr('class', 'strum');\n\n      circles\n        .attr('cx', function (d) {\n          return d[0];\n        })\n        .attr('cy', function (d) {\n          return d[1];\n        })\n        .attr('r', 5)\n        .style('opacity', function (d, i) {\n          return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n        })\n        .on('mouseover', function () {\n          d3.select(this).style('opacity', 0.8);\n        })\n        .on('mouseout', function () {\n          d3.select(this).style('opacity', 0);\n        })\n        .call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          strum;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        (dims = dimensionsForPoint(p)),\n          (strum = {\n            p1: p,\n            dims: dims,\n            minX: xscale(dims.left),\n            maxX: xscale(dims.right),\n            minY: 0,\n            maxY: h(),\n          });\n\n        strums[dims.i] = strum;\n        strums.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          strum = strums[strums.active];\n\n        // Make sure that the point is within the bounds\n        strum.p2[0] = Math.min(\n          Math.max(strum.minX + 1, ev.x - __.margin.left),\n          strum.maxX,\n        );\n        strum.p2[1] = Math.min(\n          Math.max(strum.minY, ev.y - __.margin.top),\n          strum.maxY,\n        );\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n        p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n        m1 = 1 - width / p1[0],\n        b1 = p1[1] * (1 - m1),\n        m2 = 1 - width / p2[0],\n        b2 = p2[1] * (1 - m2);\n\n      // test if point falls between lines\n      return function (p) {\n        var x = p[0],\n          y = p[1],\n          y1 = m1 * x + b1,\n          y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n        brushed = __.data;\n\n      // Get the ids of the currently active strums.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n          test = containmentTest(strum, strums.width(id)),\n          d1 = strum.dims.left,\n          d2 = strum.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n        svg = pc.selection.select('svg').select('g#strums');\n\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          strum = strums[strums.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (\n          strum &&\n          strum.p1[0] === strum.p2[0] &&\n          strum.p1[1] === strum.p2[1]\n        ) {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      strums.active = undefined;\n      // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first\n              ? i + i < length && __.dimensions[i + 1] === second\n              : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d;\n            // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      });\n\n      // Add a new svg group in which we draw the strums.\n      pc.selection\n        .select('svg')\n        .append('g')\n        .attr('id', 'strums')\n        .attr(\n          'transform',\n          'translate(' + __.margin.left + ',' + __.margin.top + ')',\n        );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(strums);\n\n      drag\n        .on('dragstart', onDragStart(strums))\n        .on('drag', onDrag(strums))\n        .on('dragend', onDragEnd(strums));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection\n        .select('svg')\n        .insert('rect', 'g#strums')\n        .attr('id', 'strum-events')\n        .attr('x', __.margin.left)\n        .attr('y', __.margin.top)\n        .attr('width', w())\n        .attr('height', h() + 2)\n        .style('opacity', 0)\n        .call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      },\n    };\n  })();\n\n  // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        },\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n\n      brush\n        .y(yscale[axis])\n        .on('brushstart', function () {\n          if (d3.event.sourceEvent !== null) {\n            d3.event.sourceEvent.stopPropagation();\n          }\n        })\n        .on('brush', function () {\n          brushUpdated(selected());\n        })\n        .on('brushend', function () {\n          // d3.svg.multibrush clears extents just before calling 'brushend'\n          // so we have to update here again.\n          // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n          // to avoid unnecessary computation.\n          brushUpdated(selected());\n          events.brushend.call(pc, __.brushed);\n        })\n        .extentAdaption(function (selection) {\n          selection.style('visibility', null).attr('x', -15).attr('width', 30);\n        })\n        .resizeAdaption(function (selection) {\n          selection.selectAll('rect').attr('x', -15).attr('width', 30);\n        });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g')\n        .attr('class', 'brush')\n        .each(function (d) {\n          d3.select(this).call(brushFor(d));\n        })\n        .selectAll('rect')\n        .style('visibility', null)\n        .attr('x', -15)\n        .attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents,\n    };\n  })();\n  // brush mode: angular\n  // code based on 2D.strums.js\n\n  (function () {\n    var arcs = {},\n      strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n        id = arc.dims.i,\n        points = [arc.p2, arc.p3],\n        line = svg.selectAll('line#arc-' + id).data([\n          { p1: arc.p1, p2: arc.p2 },\n          { p1: arc.p1, p2: arc.p3 },\n        ]),\n        circles = svg.selectAll('circle#arc-' + id).data(points),\n        drag = d3.behavior.drag(),\n        path = svg.selectAll('path#arc-' + id).data([arc]);\n\n      path\n        .enter()\n        .append('path')\n        .attr('id', 'arc-' + id)\n        .attr('class', 'arc')\n        .style('fill', 'orange')\n        .style('opacity', 0.5);\n\n      path\n        .attr('d', arc.arc)\n        .attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n\n      line\n        .enter()\n        .append('line')\n        .attr('id', 'arc-' + id)\n        .attr('class', 'arc');\n\n      line\n        .attr('x1', function (d) {\n          return d.p1[0];\n        })\n        .attr('y1', function (d) {\n          return d.p1[1];\n        })\n        .attr('x2', function (d) {\n          return d.p2[0];\n        })\n        .attr('y2', function (d) {\n          return d.p2[1];\n        })\n        .attr('stroke', 'black')\n        .attr('stroke-width', 2);\n\n      drag\n        .on('drag', function (d, i) {\n          var ev = d3.event,\n            angle = 0;\n\n          i = i + 2;\n\n          arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n          arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n\n          angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n          if (\n            (arc.startAngle < Math.PI &&\n              arc.endAngle < Math.PI &&\n              angle < Math.PI) ||\n            (arc.startAngle >= Math.PI &&\n              arc.endAngle >= Math.PI &&\n              angle >= Math.PI)\n          ) {\n            if (i === 2) {\n              arc.endAngle = angle;\n              arc.arc.endAngle(angle);\n            } else if (i === 3) {\n              arc.startAngle = angle;\n              arc.arc.startAngle(angle);\n            }\n          }\n\n          drawStrum(arc, i - 2);\n        })\n        .on('dragend', onDragEnd());\n\n      circles\n        .enter()\n        .append('circle')\n        .attr('id', 'arc-' + id)\n        .attr('class', 'arc');\n\n      circles\n        .attr('cx', function (d) {\n          return d[0];\n        })\n        .attr('cy', function (d) {\n          return d[1];\n        })\n        .attr('r', 5)\n        .style('opacity', function (d, i) {\n          return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n        })\n        .on('mouseover', function () {\n          d3.select(this).style('opacity', 0.8);\n        })\n        .on('mouseout', function () {\n          d3.select(this).style('opacity', 0);\n        })\n        .call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          arc;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        (dims = dimensionsForPoint(p)),\n          (arc = {\n            p1: p,\n            dims: dims,\n            minX: xscale(dims.left),\n            maxX: xscale(dims.right),\n            minY: 0,\n            maxY: h(),\n            startAngle: undefined,\n            endAngle: undefined,\n            arc: d3.svg.arc().innerRadius(0),\n          });\n\n        arcs[dims.i] = arc;\n        arcs.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          arc = arcs[arcs.active];\n\n        // Make sure that the point is within the bounds\n        arc.p2[0] = Math.min(\n          Math.max(arc.minX + 1, ev.x - __.margin.left),\n          arc.maxX,\n        );\n        arc.p2[1] = Math.min(\n          Math.max(arc.minY, ev.y - __.margin.top),\n          arc.maxY,\n        );\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    }\n\n    // some helper functions\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = (function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    })();\n\n    var deg = (function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    })();\n\n    // [0, 2*PI] -> [-PI/2, PI/2]\n    var signedAngle = function (angle) {\n      var ret = angle;\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n      return -ret;\n    };\n\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      // test if segment angle is contained in angle interval\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n        brushed = __.data;\n\n      // Get the ids of the currently active arcs.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n          test = containmentTest(arc),\n          d1 = arc.dims.left,\n          d2 = arc.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          a = arcs.width(id),\n          b = y1(d[d1]) - y2(d[d2]),\n          c = hypothenuse(a, b),\n          angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n        svg = pc.selection.select('svg').select('g#arcs');\n\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          arc = arcs[arcs.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc\n            .outerRadius(arcs.length(arcs.active))\n            .startAngle(angle)\n            .endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      arcs.active = undefined;\n      // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      };\n\n      // returns angles in [-PI/2, PI/2]\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n          b = p1[1] - p2[1],\n          c = hypothenuse(a, b);\n\n        return Math.asin(b / c);\n      };\n\n      // returns angles in [0, 2 * PI]\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n        var sAngle = angle(arc.p1, arc.p2),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n          b = arc.p1[1] - arc.p2[1],\n          c = hypothenuse(a, b);\n\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first\n              ? i + i < length && __.dimensions[i + 1] === second\n              : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d;\n            // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      });\n\n      // Add a new svg group in which we draw the arcs.\n      pc.selection\n        .select('svg')\n        .append('g')\n        .attr('id', 'arcs')\n        .attr(\n          'transform',\n          'translate(' + __.margin.left + ',' + __.margin.top + ')',\n        );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(arcs);\n\n      drag\n        .on('dragstart', onDragStart(arcs))\n        .on('drag', onDrag(arcs))\n        .on('dragend', onDragEnd(arcs));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection\n        .select('svg')\n        .insert('rect', 'g#arcs')\n        .attr('id', 'arc-events')\n        .attr('x', __.margin.left)\n        .attr('y', __.margin.top)\n        .attr('width', w())\n        .attr('height', h() + 2)\n        .style('opacity', 0)\n        .call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      },\n    };\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  };\n\n  // expose a few objects\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = function () {\n    // selection size\n    pc.selection\n      .select('svg')\n      .attr('width', __.width)\n      .attr('height', __.height);\n    pc.svg.attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')',\n    );\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin,\n    });\n    return this;\n  };\n\n  // highlight an array of data\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  };\n\n  // clear highlighting\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x:\n        ((a.x * b.y - a.y * b.x) * (c.x - d.x) -\n          (a.x - b.x) * (c.x * d.y - c.y * d.x)) /\n        ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y:\n        ((a.x * b.y - a.y * b.x) * (c.y - d.y) -\n          (a.y - b.y) * (c.x * d.y - c.y * d.x)) /\n        ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n    };\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n  pc.version = '0.7.0';\n  // this descriptive text should live with other introspective methods\n  pc.toString = function () {\n    return (\n      'Parallel Coordinates: ' +\n      __.dimensions.length +\n      ' dimensions (' +\n      d3.keys(__.data[0]).length +\n      ' total) , ' +\n      __.data.length +\n      ' rows'\n    );\n  };\n\n  return pc;\n}\n\nd3.renderQueue = function (func) {\n  var _queue = [], // data to be rendered\n    _rate = 10, // number of calls per frame\n    _clear = function () {}, // clearing function\n    _i = 0; // current iteration\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true;\n\n      // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n      var end = Math.min(_i + _rate, _queue.length);\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}