{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import BinSorter from './bin-sorter';\nimport { getScaleFunctionByScaleType } from './scale-utils';\nimport { getValueFunc, wrapGetValueFunc } from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [{\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  pickingInfo: 'colorValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    }\n  },\n  nullValue: [0, 0, 0, 0]\n}, {\n  key: 'elevation',\n  accessor: 'getElevation',\n  pickingInfo: 'elevationValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    }\n  },\n  nullValue: -1\n}];\n\nconst defaultGetCellSize = (props) => props.cellSize;\n\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {}\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {\n      oldProps,\n      props,\n      changeFlags\n    } = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      dimensionChanges.forEach((f) => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n\n    this.setState({\n      aggregationDirty\n    });\n    return this.state;\n  }\n\n  setState(updateObject) {\n    this.state = { ...this.state,\n      ...updateObject\n    };\n  }\n\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: { ...this.state.dimensions,\n        [key]: { ...this.state.dimensions[key],\n          ...updateObject\n        }\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    if (result.hexagons) {\n      return {\n        data: result.hexagons,\n        ...result\n      };\n    } else if (result.layerData) {\n      return {\n        data: result.layerData,\n        ...result\n      };\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {\n        value,\n        weight,\n        aggregation\n      } = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {\n            data: props.data\n          });\n        } else {\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {\n            data: props.data\n          });\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {\n          getValue\n        });\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);\n  }\n\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach((dimension) => {\n      const {\n        key\n      } = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({\n    key,\n    accessor,\n    pickingInfo,\n    getBins,\n    getDomain,\n    getScaleFunc,\n    nullValue\n  }) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {\n        updater: this.getDimensionSortedBins,\n        ...getBins\n      },\n      getDomain: {\n        updater: this.getDimensionValueDomain,\n        ...getDomain\n      },\n      getScaleFunc: {\n        updater: this.getDimensionScale,\n        ...getScaleFunc\n      },\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    return Object.values(dimensionStep.triggers).some((item) => {\n      if (item.updateTrigger) {\n        return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n      }\n\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    const updaters = [];\n\n    for (const key in this.dimensionUpdaters) {\n      const needUpdate = dimensionSteps.find((step) => this.needUpdateDimensionStep(this.dimensionUpdaters[key][step], oldProps, props, changeFlags));\n\n      if (needUpdate) {\n        updaters.push(this.dimensionUpdaters[key][needUpdate].updater.bind(this, props, this.dimensionUpdaters[key]));\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {\n        accessor\n      } = this.dimensionUpdaters[key];\n      updateTriggers[accessor] = {};\n      dimensionSteps.forEach((step) => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(({\n          prop,\n          updateTrigger\n        }) => {\n          if (updateTrigger) {\n            const fromProp = _updateTriggers[updateTrigger];\n\n            if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n              Object.assign(updateTriggers[accessor], fromProp);\n            } else if (fromProp !== undefined) {\n              updateTriggers[accessor][prop] = fromProp;\n            }\n          } else {\n            updateTriggers[accessor][prop] = props[prop];\n          }\n        });\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {\n      key\n    } = dimensionUpdater;\n    const {\n      getValue\n    } = this.state.dimensions[key];\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {\n      sortedBins\n    });\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {\n      getDomain,\n      key\n    } = dimensionUpdater;\n    const {\n      triggers: {\n        lowerPercentile,\n        upperPercentile,\n        scaleType\n      }\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n    this.setDimensionState(key, {\n      valueDomain\n    });\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {\n      key,\n      getScaleFunc,\n      getDomain\n    } = dimensionUpdater;\n    const {\n      domain,\n      range\n    } = getScaleFunc.triggers;\n    const {\n      scaleType\n    } = getDomain.triggers;\n    const {\n      onSet\n    } = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {\n      scaleFunc\n    });\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return (cell) => {\n      const {\n        sortedBins,\n        scaleFunc\n      } = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        return nullValue;\n      }\n\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {\n        accessor\n      } = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      const cell = this.state.layerData.data[info.index];\n      const binInfo = {};\n\n      for (const key in this.dimensionUpdaters) {\n        const {\n          pickingInfo\n        } = this.dimensionUpdaters[key];\n        const {\n          sortedBins\n        } = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    info.picked = Boolean(object);\n    info.object = object;\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(nop, \"nop\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/cpu-aggregator.js\");reactHotLoader.register(dimensionSteps, \"dimensionSteps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/cpu-aggregator.js\");reactHotLoader.register(defaultDimensions, \"defaultDimensions\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/cpu-aggregator.js\");reactHotLoader.register(defaultGetCellSize, \"defaultGetCellSize\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/cpu-aggregator.js\");reactHotLoader.register(CPUAggregator, \"CPUAggregator\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/cpu-aggregator.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["BinSorter","getScaleFunctionByScaleType","getValueFunc","wrapGetValueFunc","nop","dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","cellSize","CPUAggregator","constructor","opts","state","layerData","dimensions","changeFlags","dimensionUpdaters","_getCellSize","getCellSize","_getAggregator","getAggregator","_addDimension","updateState","aggregationParams","oldProps","updateGetValueFuncs","reprojectNeeded","needsReProjectPoints","aggregationDirty","dataChanged","getAggregatedData","dimensionChanges","getDimensionChanges","forEach","f","setState","updateObject","setDimensionState","normalizeResult","result","hexagons","data","aggregator","getSortedBins","getValue","getValueChanged","needUpdateDimensionStep","updateTriggersChanged","all","getPosition","addDimension","dimension","getDimensionUpdaters","sortedBins","scaleFunc","updater","getDimensionSortedBins","getDimensionValueDomain","getDimensionScale","attributeAccessor","getSubLayerDimensionAttribute","dimensionStep","Object","values","some","item","updaters","needUpdate","find","step","push","bind","length","getUpdateTriggers","_updateTriggers","updateTriggers","fromProp","Array","isArray","assign","undefined","dimensionUpdater","_filterData","valueDomain","getValueDomainByScale","dimensionRange","dimensionDomain","getScaleFunction","cell","bin","binMap","index","counts","cv","isValueInDomain","getSubLayerAccessors","accessors","getPickingInfo","info","isPicked","picked","object","binInfo","points","filteredPoints","Boolean","getAccessor","dimensionKey","hasOwnProperty","__reactstandin__regenerateByEval","code","eval","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["../../../src/utils/cpu-aggregator.js"],"sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc, wrapGetValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = {...this.state, ...updateObject};\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: {\n        ...this.state.dimensions,\n        [key]: {...this.state.dimensions[key], ...updateObject}\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return {data: result.hexagons, ...result};\n    } else if (result.layerData) {\n      return {data: result.layerData, ...result};\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {data: props.data});\n        } else {\n          // If `getValue` is not provided from props, build it with aggregation and weight.\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {data: props.data});\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {updater: this.getDimensionSortedBins, ...getBins},\n      getDomain: {updater: this.getDimensionValueDomain, ...getDomain},\n      getScaleFunc: {updater: this.getDimensionScale, ...getScaleFunc},\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        // if data has changed, always update value\n        return (\n          changeFlags.dataChanged ||\n          (changeFlags.updateTriggersChanged &&\n            (changeFlags.updateTriggersChanged.all ||\n              changeFlags.updateTriggersChanged[item.updateTrigger]))\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}