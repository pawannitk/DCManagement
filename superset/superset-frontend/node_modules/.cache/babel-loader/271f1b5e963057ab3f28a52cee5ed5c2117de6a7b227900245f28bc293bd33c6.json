{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\n\nimport { SupersetClient, getClientErrorObject, ensureIsArray } from '@superset-ui/core';\nexport const SEPARATOR = ' : ';\nexport const buildTimeRangeString = (since, until) => `${since}${SEPARATOR}${until}`;\nconst formatDateEndpoint = (dttm, isStart) => dttm.replace('T00:00:00', '') || (isStart ? '-∞' : '∞');\nexport const formatTimeRange = (timeRange, columnPlaceholder = 'col') => {\n  const splitDateRange = timeRange.split(SEPARATOR);\n  if (splitDateRange.length === 1)\n  return timeRange;\n  return `${formatDateEndpoint(splitDateRange[0], true)} ≤ ${columnPlaceholder} < ${formatDateEndpoint(splitDateRange[1])}`;\n};\nexport const formatTimeRangeComparison = (initialTimeRange, shiftedTimeRange, columnPlaceholder = 'col') => {\n  const splitInitialDateRange = initialTimeRange.split(SEPARATOR);\n  const splitShiftedDateRange = shiftedTimeRange.split(SEPARATOR);\n  return `${columnPlaceholder}: ${formatDateEndpoint(splitInitialDateRange[0], true)} to ${formatDateEndpoint(splitInitialDateRange[1])} vs\n  ${formatDateEndpoint(splitShiftedDateRange[0], true)} to ${formatDateEndpoint(splitShiftedDateRange[1])}`;\n};\nexport const fetchTimeRange = async (timeRange, columnPlaceholder = 'col', shifts) => {\n  let query;\n  let endpoint;\n  if (!_isEmpty(shifts)) {\n    const timeRanges = ensureIsArray(shifts).map((shift) => ({\n      timeRange,\n      shift\n    }));\n    query = rison.encode_uri([{ timeRange }, ...timeRanges]);\n    endpoint = `/api/v1/time_range/?q=${query}`;\n  } else\n  {\n    query = rison.encode_uri(timeRange);\n    endpoint = `/api/v1/time_range/?q=${query}`;\n  }\n  try {var _response$json3;\n    const response = await SupersetClient.get({ endpoint });\n    if (_isEmpty(shifts)) {var _response$json, _response$json$result, _response$json2, _response$json2$resul;\n      const timeRangeString = buildTimeRangeString((response == null ? void 0 : (_response$json = response.json) == null ? void 0 : (_response$json$result = _response$json.result[0]) == null ? void 0 : _response$json$result.since) || '', (response == null ? void 0 : (_response$json2 = response.json) == null ? void 0 : (_response$json2$resul = _response$json2.result[0]) == null ? void 0 : _response$json2$resul.until) || '');\n      return {\n        value: formatTimeRange(timeRangeString, columnPlaceholder)\n      };\n    }\n    const timeRanges = response == null ? void 0 : (_response$json3 = response.json) == null ? void 0 : _response$json3.result.map((result) => buildTimeRangeString(result.since, result.until));\n    return {\n      value: timeRanges.\n      slice(1).\n      map((timeRange) => formatTimeRangeComparison(timeRanges[0], timeRange, columnPlaceholder))\n    };\n  }\n  catch (response) {\n    const clientError = await getClientErrorObject(response);\n    return {\n      error: clientError.message || clientError.error || response.statusText\n    };\n  }\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(SEPARATOR, \"SEPARATOR\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/time-comparison/fetchTimeRange.ts\");reactHotLoader.register(buildTimeRangeString, \"buildTimeRangeString\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/time-comparison/fetchTimeRange.ts\");reactHotLoader.register(formatDateEndpoint, \"formatDateEndpoint\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/time-comparison/fetchTimeRange.ts\");reactHotLoader.register(formatTimeRange, \"formatTimeRange\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/time-comparison/fetchTimeRange.ts\");reactHotLoader.register(formatTimeRangeComparison, \"formatTimeRangeComparison\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/time-comparison/fetchTimeRange.ts\");reactHotLoader.register(fetchTimeRange, \"fetchTimeRange\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/time-comparison/fetchTimeRange.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["rison","SupersetClient","getClientErrorObject","ensureIsArray","SEPARATOR","buildTimeRangeString","since","until","formatDateEndpoint","dttm","isStart","replace","formatTimeRange","timeRange","columnPlaceholder","splitDateRange","split","length","formatTimeRangeComparison","initialTimeRange","shiftedTimeRange","splitInitialDateRange","splitShiftedDateRange","fetchTimeRange","shifts","query","endpoint","_isEmpty","timeRanges","map","shift","encode_uri","_response$json3","response","get","_response$json","_response$json$result","_response$json2","_response$json2$resul","timeRangeString","json","result","value","slice","clientError","error","message","statusText","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/time-comparison/fetchTimeRange.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport { isEmpty } from 'lodash';\nimport {\n  SupersetClient,\n  getClientErrorObject,\n  ensureIsArray,\n} from '@superset-ui/core';\n\nexport const SEPARATOR = ' : ';\n\nexport const buildTimeRangeString = (since: string, until: string): string =>\n  `${since}${SEPARATOR}${until}`;\n\nconst formatDateEndpoint = (dttm: string, isStart?: boolean): string =>\n  dttm.replace('T00:00:00', '') || (isStart ? '-∞' : '∞');\n\nexport const formatTimeRange = (\n  timeRange: string,\n  columnPlaceholder = 'col',\n) => {\n  const splitDateRange = timeRange.split(SEPARATOR);\n  if (splitDateRange.length === 1) return timeRange;\n  return `${formatDateEndpoint(\n    splitDateRange[0],\n    true,\n  )} ≤ ${columnPlaceholder} < ${formatDateEndpoint(splitDateRange[1])}`;\n};\n\nexport const formatTimeRangeComparison = (\n  initialTimeRange: string,\n  shiftedTimeRange: string,\n  columnPlaceholder = 'col',\n) => {\n  const splitInitialDateRange = initialTimeRange.split(SEPARATOR);\n  const splitShiftedDateRange = shiftedTimeRange.split(SEPARATOR);\n  return `${columnPlaceholder}: ${formatDateEndpoint(\n    splitInitialDateRange[0],\n    true,\n  )} to ${formatDateEndpoint(splitInitialDateRange[1])} vs\n  ${formatDateEndpoint(splitShiftedDateRange[0], true)} to ${formatDateEndpoint(\n    splitShiftedDateRange[1],\n  )}`;\n};\n\nexport const fetchTimeRange = async (\n  timeRange: string,\n  columnPlaceholder = 'col',\n  shifts?: string[],\n) => {\n  let query;\n  let endpoint;\n  if (!isEmpty(shifts)) {\n    const timeRanges = ensureIsArray(shifts).map(shift => ({\n      timeRange,\n      shift,\n    }));\n    query = rison.encode_uri([{ timeRange }, ...timeRanges]);\n    endpoint = `/api/v1/time_range/?q=${query}`;\n  } else {\n    query = rison.encode_uri(timeRange);\n    endpoint = `/api/v1/time_range/?q=${query}`;\n  }\n  try {\n    const response = await SupersetClient.get({ endpoint });\n    if (isEmpty(shifts)) {\n      const timeRangeString = buildTimeRangeString(\n        response?.json?.result[0]?.since || '',\n        response?.json?.result[0]?.until || '',\n      );\n      return {\n        value: formatTimeRange(timeRangeString, columnPlaceholder),\n      };\n    }\n    const timeRanges = response?.json?.result.map((result: any) =>\n      buildTimeRangeString(result.since, result.until),\n    );\n    return {\n      value: timeRanges\n        .slice(1)\n        .map((timeRange: string) =>\n          formatTimeRangeComparison(\n            timeRanges[0],\n            timeRange,\n            columnPlaceholder,\n          ),\n        ),\n    };\n  } catch (response) {\n    const clientError = await getClientErrorObject(response);\n    return {\n      error: clientError.message || clientError.error || response.statusText,\n    };\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}