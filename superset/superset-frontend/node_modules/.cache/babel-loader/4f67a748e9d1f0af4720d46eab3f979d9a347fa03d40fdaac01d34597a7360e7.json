{"ast":null,"code":"import _pick from \"lodash/pick\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { getCategoricalSchemeRegistry, SupersetClient, useComponentDidUpdate } from '@superset-ui/core';\nimport { ParentSize } from '@visx/responsive';\n\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport { DASHBOARD_GRID_ID, DASHBOARD_ROOT_DEPTH } from 'src/dashboard/util/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/getChartIdsInFilterScope';\nimport findTabIndexByComponentId from 'src/dashboard/util/findTabIndexByComponentId';\nimport { setInScopeStatusOfFilters } from 'src/dashboard/actions/nativeFilters';\nimport { dashboardInfoChanged } from 'src/dashboard/actions/dashboardInfo';\nimport { setColorScheme } from 'src/dashboard/actions/dashboardState';\nimport jsonStringify from 'json-stringify-pretty-compact';\nimport { NATIVE_FILTER_DIVIDER_PREFIX } from '../nativeFilters/FiltersConfigModal/utils';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { getRootLevelTabsComponent } from './utils';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst useNativeFilterScopes = () => {\n  const nativeFilters = useSelector((state) => {var _state$nativeFilters;return (_state$nativeFilters = state.nativeFilters) == null ? void 0 : _state$nativeFilters.filters;});\n  return useMemo(() => nativeFilters ?\n  Object.values(nativeFilters).map((filter) => _pick(filter, ['id', 'scope', 'type'])) :\n  [], [JSON.stringify(nativeFilters)]);\n};__signature__(useNativeFilterScopes, \"useSelector{nativeFilters}\\nuseMemo{}\", () => [useSelector]);\nconst DashboardContainer = ({ topLevelTabs }) => {\n  const nativeFilterScopes = useNativeFilterScopes();\n  const dispatch = useDispatch();\n  const dashboardLayout = useSelector((state) => state.dashboardLayout.present);\n  const dashboardInfo = useSelector((state) => state.dashboardInfo);\n  const directPathToChild = useSelector((state) => state.dashboardState.directPathToChild);\n  const chartIds = useSelector((state) => Object.values(state.charts).map((chart) => chart.id));\n  const prevTabIndexRef = useRef();\n  const tabIndex = useMemo(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild\n    });\n    if (nextTabIndex === -1) {var _prevTabIndexRef$curr;\n      return (_prevTabIndexRef$curr = prevTabIndexRef.current) != null ? _prevTabIndexRef$curr : 0;\n    }\n    prevTabIndexRef.current = nextTabIndex;\n    return nextTabIndex;\n  }, [dashboardLayout, directPathToChild]);\n  useEffect(() => {\n    if (nativeFilterScopes.length === 0) {\n      return;\n    }\n    const scopes = nativeFilterScopes.map((filterScope) => {\n      if (filterScope.id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX)) {\n        return {\n          filterId: filterScope.id,\n          tabsInScope: [],\n          chartsInScope: []\n        };\n      }\n      const chartsInScope = getChartIdsInFilterScope(filterScope.scope, chartIds, dashboardLayout);\n      const tabsInScope = findTabsWithChartsInScope(dashboardLayout, chartsInScope);\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope\n      };\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [nativeFilterScopes, dashboardLayout, dispatch]);\n  const verifyUpdateColorScheme = useCallback(() => {\n    const currentMetadata = dashboardInfo.metadata;\n    if (currentMetadata != null && currentMetadata.color_scheme) {\n      const metadata = { ...currentMetadata };\n      const colorScheme = metadata == null ? void 0 : metadata.color_scheme;\n      const colorSchemeDomain = (metadata == null ? void 0 : metadata.color_scheme_domain) || [];\n      const categoricalSchemes = getCategoricalSchemeRegistry();\n      const registryColorScheme = categoricalSchemes.get(colorScheme, true) || undefined;\n      const registryColorSchemeDomain = (registryColorScheme == null ? void 0 : registryColorScheme.colors) || [];\n      const defaultColorScheme = categoricalSchemes.defaultKey;\n      const colorSchemeExists = !!registryColorScheme;\n      const updateDashboardData = () => {\n        SupersetClient.put({\n          endpoint: `/api/v1/dashboard/${dashboardInfo.id}`,\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            json_metadata: jsonStringify(metadata)\n          })\n        }).catch((e) => console.log(e));\n      };\n      const updateColorScheme = (scheme) => {\n        dispatch(setColorScheme(scheme));\n      };\n      const updateDashboard = () => {\n        dispatch(dashboardInfoChanged({\n          metadata\n        }));\n        updateDashboardData();\n      };\n      // selected color scheme does not exist anymore\n      // must fallback to the available default one\n      if (!colorSchemeExists) {var _categoricalSchemes$g;\n        const updatedScheme = (defaultColorScheme == null ? void 0 : defaultColorScheme.toString()) || 'supersetColors';\n        metadata.color_scheme = updatedScheme;\n        metadata.color_scheme_domain =\n        ((_categoricalSchemes$g = categoricalSchemes.get(defaultColorScheme)) == null ? void 0 : _categoricalSchemes$g.colors) || [];\n        // reset shared_label_colors\n        // TODO: Requires regenerating the shared_label_colors after\n        // fixing a bug which affects their generation on dashboards with tabs\n        metadata.shared_label_colors = {};\n        updateColorScheme(updatedScheme);\n        updateDashboard();\n      } else\n      {\n        // if this dashboard does not have a color_scheme_domain saved\n        // must create one and store it for the first time\n        if (colorSchemeExists && !colorSchemeDomain.length) {\n          metadata.color_scheme_domain = registryColorSchemeDomain;\n          updateDashboard();\n        }\n        // if the color_scheme_domain is not the same as the registry domain\n        // must update the existing color_scheme_domain\n        if (colorSchemeExists &&\n        colorSchemeDomain.length &&\n        registryColorSchemeDomain.toString() !== colorSchemeDomain.toString()) {\n          metadata.color_scheme_domain = registryColorSchemeDomain;\n          // reset shared_label_colors\n          // TODO: Requires regenerating the shared_label_colors after\n          // fixing a bug which affects their generation on dashboards with tabs\n          metadata.shared_label_colors = {};\n          updateColorScheme(colorScheme);\n          updateDashboard();\n        }\n      }\n    }\n  }, [chartIds]);\n  useComponentDidUpdate(verifyUpdateColorScheme);\n  const childIds = topLevelTabs ?\n  topLevelTabs.children :\n  [DASHBOARD_GRID_ID];\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n  const TOP_OF_PAGE_RANGE = 220;\n  return ___EmotionJSX(\"div\", { className: \"grid-container\", \"data-test\": \"grid-container\" },\n  ___EmotionJSX(ParentSize, null,\n  ({ width }) =>\n  /*\n    We use a TabContainer irrespective of whether top-level tabs exist to maintain\n    a consistent React component tree. This avoids expensive mounts/unmounts of\n    the entire dashboard upon adding/removing top-level tabs, which would otherwise\n    happen because of React's diffing algorithm\n  */\n  ___EmotionJSX(Tabs, { id: DASHBOARD_GRID_ID, activeKey: activeKey, renderTabBar: () => ___EmotionJSX(React.Fragment, null), fullWidth: false, animated: false, allowOverflow: true, onFocus: (e) => {\n      if (\n      // prevent scrolling when tabbing to the tab pane\n      e.target.classList.contains('ant-tabs-tabpane') &&\n      window.scrollY < TOP_OF_PAGE_RANGE) {\n        // prevent window from jumping down when tabbing\n        // if already at the top of the page\n        // to help with accessibility when using keyboard navigation\n        window.scrollTo(window.scrollX, 0);\n      }\n    } },\n  childIds.map((id, index) =>\n  // Matching the key of the first TabPane irrespective of topLevelTabs\n  // lets us keep the same React component tree when !!topLevelTabs changes.\n  // This avoids expensive mounts/unmounts of the entire dashboard.\n  ___EmotionJSX(Tabs.TabPane, { key: index === 0 ? DASHBOARD_GRID_ID : index.toString() },\n  ___EmotionJSX(DashboardGrid, { gridComponent: dashboardLayout[id]\n    // see isValidChild for why tabs do not increment the depth of their children\n    , depth: DASHBOARD_ROOT_DEPTH + 1 // (topLevelTabs ? 0 : 1)}\n    , width: width, isComponentVisible: index === tabIndex })\n  ))\n  )\n  )\n  );\n};__signature__(DashboardContainer, \"useNativeFilterScopes{nativeFilterScopes}\\nuseDispatch{dispatch}\\nuseSelector{dashboardLayout}\\nuseSelector{dashboardInfo}\\nuseSelector{directPathToChild}\\nuseSelector{chartIds}\\nuseRef{prevTabIndexRef}\\nuseMemo{tabIndex}\\nuseEffect{}\\nuseCallback{verifyUpdateColorScheme}\\nuseComponentDidUpdate{}\", () => [useNativeFilterScopes, useDispatch, useSelector, useSelector, useSelector, useSelector, useComponentDidUpdate]);const _default =\nDashboardContainer;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(useNativeFilterScopes, \"useNativeFilterScopes\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(DashboardContainer, \"DashboardContainer\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(_default, \"default\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["React","useCallback","useEffect","useMemo","useRef","useDispatch","useSelector","getCategoricalSchemeRegistry","SupersetClient","useComponentDidUpdate","ParentSize","Tabs","DashboardGrid","DASHBOARD_GRID_ID","DASHBOARD_ROOT_DEPTH","getChartIdsInFilterScope","findTabIndexByComponentId","setInScopeStatusOfFilters","dashboardInfoChanged","setColorScheme","jsonStringify","NATIVE_FILTER_DIVIDER_PREFIX","findTabsWithChartsInScope","getRootLevelTabsComponent","jsx","___EmotionJSX","useNativeFilterScopes","nativeFilters","state","_state$nativeFilters","filters","Object","values","map","filter","_pick","JSON","stringify","__signature__","DashboardContainer","topLevelTabs","nativeFilterScopes","dispatch","dashboardLayout","present","dashboardInfo","directPathToChild","dashboardState","chartIds","charts","chart","id","prevTabIndexRef","tabIndex","nextTabIndex","currentComponent","_prevTabIndexRef$curr","current","length","scopes","filterScope","startsWith","filterId","tabsInScope","chartsInScope","scope","Array","from","verifyUpdateColorScheme","currentMetadata","metadata","color_scheme","colorScheme","colorSchemeDomain","color_scheme_domain","categoricalSchemes","registryColorScheme","get","undefined","registryColorSchemeDomain","colors","defaultColorScheme","defaultKey","colorSchemeExists","updateDashboardData","put","endpoint","headers","body","json_metadata","catch","e","console","log","updateColorScheme","scheme","updateDashboard","_categoricalSchemes$g","updatedScheme","toString","shared_label_colors","childIds","children","min","Math","activeKey","TOP_OF_PAGE_RANGE","className","width","renderTabBar","Fragment","fullWidth","animated","allowOverflow","onFocus","target","classList","contains","window","scrollY","scrollTo","scrollX","index","TabPane","key","gridComponent","depth","isComponentVisible","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport React, { FC, useCallback, useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport {\n  Filter,\n  Filters,\n  getCategoricalSchemeRegistry,\n  SupersetClient,\n  useComponentDidUpdate,\n} from '@superset-ui/core';\nimport { ParentSize } from '@visx/responsive';\nimport { pick } from 'lodash';\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport {\n  DashboardInfo,\n  DashboardLayout,\n  LayoutItem,\n  RootState,\n} from 'src/dashboard/types';\nimport {\n  DASHBOARD_GRID_ID,\n  DASHBOARD_ROOT_DEPTH,\n} from 'src/dashboard/util/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/getChartIdsInFilterScope';\nimport findTabIndexByComponentId from 'src/dashboard/util/findTabIndexByComponentId';\nimport { setInScopeStatusOfFilters } from 'src/dashboard/actions/nativeFilters';\nimport { dashboardInfoChanged } from 'src/dashboard/actions/dashboardInfo';\nimport { setColorScheme } from 'src/dashboard/actions/dashboardState';\nimport jsonStringify from 'json-stringify-pretty-compact';\nimport { NATIVE_FILTER_DIVIDER_PREFIX } from '../nativeFilters/FiltersConfigModal/utils';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { getRootLevelTabsComponent } from './utils';\n\ntype DashboardContainerProps = {\n  topLevelTabs?: LayoutItem;\n};\n\nconst useNativeFilterScopes = () => {\n  const nativeFilters = useSelector<RootState, Filters>(\n    state => state.nativeFilters?.filters,\n  );\n  return useMemo(\n    () =>\n      nativeFilters\n        ? Object.values(nativeFilters).map((filter: Filter) =>\n            pick(filter, ['id', 'scope', 'type']),\n          )\n        : [],\n    [JSON.stringify(nativeFilters)],\n  );\n};\n\nconst DashboardContainer: FC<DashboardContainerProps> = ({ topLevelTabs }) => {\n  const nativeFilterScopes = useNativeFilterScopes();\n  const dispatch = useDispatch();\n\n  const dashboardLayout = useSelector<RootState, DashboardLayout>(\n    state => state.dashboardLayout.present,\n  );\n  const dashboardInfo = useSelector<RootState, DashboardInfo>(\n    state => state.dashboardInfo,\n  );\n  const directPathToChild = useSelector<RootState, string[]>(\n    state => state.dashboardState.directPathToChild,\n  );\n  const chartIds = useSelector<RootState, number[]>(state =>\n    Object.values(state.charts).map(chart => chart.id),\n  );\n\n  const prevTabIndexRef = useRef();\n  const tabIndex = useMemo(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild,\n    });\n\n    if (nextTabIndex === -1) {\n      return prevTabIndexRef.current ?? 0;\n    }\n    prevTabIndexRef.current = nextTabIndex;\n    return nextTabIndex;\n  }, [dashboardLayout, directPathToChild]);\n\n  useEffect(() => {\n    if (nativeFilterScopes.length === 0) {\n      return;\n    }\n    const scopes = nativeFilterScopes.map(filterScope => {\n      if (filterScope.id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX)) {\n        return {\n          filterId: filterScope.id,\n          tabsInScope: [],\n          chartsInScope: [],\n        };\n      }\n      const chartsInScope: number[] = getChartIdsInFilterScope(\n        filterScope.scope,\n        chartIds,\n        dashboardLayout,\n      );\n      const tabsInScope = findTabsWithChartsInScope(\n        dashboardLayout,\n        chartsInScope,\n      );\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope,\n      };\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [nativeFilterScopes, dashboardLayout, dispatch]);\n\n  const verifyUpdateColorScheme = useCallback(() => {\n    const currentMetadata = dashboardInfo.metadata;\n    if (currentMetadata?.color_scheme) {\n      const metadata = { ...currentMetadata };\n      const colorScheme = metadata?.color_scheme;\n      const colorSchemeDomain = metadata?.color_scheme_domain || [];\n      const categoricalSchemes = getCategoricalSchemeRegistry();\n      const registryColorScheme =\n        categoricalSchemes.get(colorScheme, true) || undefined;\n      const registryColorSchemeDomain = registryColorScheme?.colors || [];\n      const defaultColorScheme = categoricalSchemes.defaultKey;\n      const colorSchemeExists = !!registryColorScheme;\n\n      const updateDashboardData = () => {\n        SupersetClient.put({\n          endpoint: `/api/v1/dashboard/${dashboardInfo.id}`,\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            json_metadata: jsonStringify(metadata),\n          }),\n        }).catch(e => console.log(e));\n      };\n      const updateColorScheme = (scheme: string) => {\n        dispatch(setColorScheme(scheme));\n      };\n      const updateDashboard = () => {\n        dispatch(\n          dashboardInfoChanged({\n            metadata,\n          }),\n        );\n        updateDashboardData();\n      };\n      // selected color scheme does not exist anymore\n      // must fallback to the available default one\n      if (!colorSchemeExists) {\n        const updatedScheme =\n          defaultColorScheme?.toString() || 'supersetColors';\n        metadata.color_scheme = updatedScheme;\n        metadata.color_scheme_domain =\n          categoricalSchemes.get(defaultColorScheme)?.colors || [];\n\n        // reset shared_label_colors\n        // TODO: Requires regenerating the shared_label_colors after\n        // fixing a bug which affects their generation on dashboards with tabs\n        metadata.shared_label_colors = {};\n\n        updateColorScheme(updatedScheme);\n        updateDashboard();\n      } else {\n        // if this dashboard does not have a color_scheme_domain saved\n        // must create one and store it for the first time\n        if (colorSchemeExists && !colorSchemeDomain.length) {\n          metadata.color_scheme_domain = registryColorSchemeDomain;\n          updateDashboard();\n        }\n        // if the color_scheme_domain is not the same as the registry domain\n        // must update the existing color_scheme_domain\n        if (\n          colorSchemeExists &&\n          colorSchemeDomain.length &&\n          registryColorSchemeDomain.toString() !== colorSchemeDomain.toString()\n        ) {\n          metadata.color_scheme_domain = registryColorSchemeDomain;\n\n          // reset shared_label_colors\n          // TODO: Requires regenerating the shared_label_colors after\n          // fixing a bug which affects their generation on dashboards with tabs\n          metadata.shared_label_colors = {};\n\n          updateColorScheme(colorScheme);\n          updateDashboard();\n        }\n      }\n    }\n  }, [chartIds]);\n\n  useComponentDidUpdate(verifyUpdateColorScheme);\n\n  const childIds: string[] = topLevelTabs\n    ? topLevelTabs.children\n    : [DASHBOARD_GRID_ID];\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n  const TOP_OF_PAGE_RANGE = 220;\n\n  return (\n    <div className=\"grid-container\" data-test=\"grid-container\">\n      <ParentSize>\n        {({ width }) => (\n          /*\n            We use a TabContainer irrespective of whether top-level tabs exist to maintain\n            a consistent React component tree. This avoids expensive mounts/unmounts of\n            the entire dashboard upon adding/removing top-level tabs, which would otherwise\n            happen because of React's diffing algorithm\n          */\n          <Tabs\n            id={DASHBOARD_GRID_ID}\n            activeKey={activeKey}\n            renderTabBar={() => <></>}\n            fullWidth={false}\n            animated={false}\n            allowOverflow\n            onFocus={e => {\n              if (\n                // prevent scrolling when tabbing to the tab pane\n                e.target.classList.contains('ant-tabs-tabpane') &&\n                window.scrollY < TOP_OF_PAGE_RANGE\n              ) {\n                // prevent window from jumping down when tabbing\n                // if already at the top of the page\n                // to help with accessibility when using keyboard navigation\n                window.scrollTo(window.scrollX, 0);\n              }\n            }}\n          >\n            {childIds.map((id, index) => (\n              // Matching the key of the first TabPane irrespective of topLevelTabs\n              // lets us keep the same React component tree when !!topLevelTabs changes.\n              // This avoids expensive mounts/unmounts of the entire dashboard.\n              <Tabs.TabPane\n                key={index === 0 ? DASHBOARD_GRID_ID : index.toString()}\n              >\n                <DashboardGrid\n                  gridComponent={dashboardLayout[id]}\n                  // see isValidChild for why tabs do not increment the depth of their children\n                  depth={DASHBOARD_ROOT_DEPTH + 1} // (topLevelTabs ? 0 : 1)}\n                  width={width}\n                  isComponentVisible={index === tabIndex}\n                />\n              </Tabs.TabPane>\n            ))}\n          </Tabs>\n        )}\n      </ParentSize>\n    </div>\n  );\n};\n\nexport default DashboardContainer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}