{"ast":null,"code":"import _invert from \"lodash/invert\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\nimport { AxisType, buildCustomFormatters, CategoricalColorNamespace, CurrencyFormatter, ensureIsArray, GenericDataType, getCustomFormatter, getNumberFormatter, getXAxisLabel, isDefined, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isPhysicalColumn, isTimeseriesAnnotationLayer, NumberFormats, tooltipHtml } from '@superset-ui/core';\nimport { getOriginalSeries } from '@superset-ui/chart-controls';\nimport { DEFAULT_FORM_DATA } from './types';\nimport { EchartsTimeseriesSeriesType, ForecastSeriesEnum } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport { dedupSeries, extractDataTotalValues, extractSeries, extractShowValueIndexes, getAxisType, getColtypesMapping, getLegendProps, getMinAndMaxFromBounds, getOverMaxHiddenFormatter } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from '../Timeseries/transformers';\nimport { TIMEGRAIN_TO_TIMESTAMP, TIMESERIES_CONSTANTS } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getPercentFormatter, getTooltipTimeFormatter, getXAxisFormatter, getYAxisFormatter } from '../utils/formatters';\nconst getFormatter = (customFormatters, defaultFormatter, metrics, formatterKey, forcePercentFormat) => {var _getCustomFormatter;\n  if (forcePercentFormat) {\n    return getNumberFormatter(',.0%');\n  }\n  return (_getCustomFormatter = getCustomFormatter(customFormatters, metrics, formatterKey)) != null ? _getCustomFormatter :\n  defaultFormatter;\n};\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, formData, queriesData, hooks, filterState, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  let focusedSeries = null;\n  const { verboseMap = {}, currencyFormats = {}, columnFormats = {} } = datasource;\n  const { label_map: labelMap } = queriesData[0];\n  const { label_map: labelMapB } = queriesData[1];\n  const data1 = queriesData[0].data || [];\n  const data2 = queriesData[1].data || [];\n  const annotationData = getAnnotationData(chartProps);\n  const coltypeMapping = {\n    ...getColtypesMapping(queriesData[0]),\n    ...getColtypesMapping(queriesData[1])\n  };\n  const { area, areaB, annotationLayers, colorScheme, contributionMode, legendOrientation, legendType, logAxis, logAxisSecondary, markerEnabled, markerEnabledB, markerSize, markerSizeB, opacity, opacityB, minorSplitLine, minorTicks, seriesType, seriesTypeB, showLegend, showValue, showValueB, stack, stackB, truncateXAxis, truncateYAxis, tooltipTimeFormat, yAxisFormat, currencyFormat, yAxisFormatSecondary, currencyFormatSecondary, xAxisTimeFormat, yAxisBounds, yAxisBoundsSecondary, yAxisIndex, yAxisIndexB, yAxisTitleSecondary, zoomable, richTooltip, tooltipSortByMetric, xAxisBounds, xAxisLabelRotation, groupby, groupbyB, xAxis: xAxisOrig, xAxisForceCategorical, xAxisTitle, yAxisTitle, xAxisTitleMargin, yAxisTitleMargin, yAxisTitlePosition, sliceId, timeGrainSqla, percentageThreshold, metrics = [], metricsB = [] } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const rebasedDataA = rebaseForecastDatum(data1, verboseMap);\n  const [rawSeriesA] = extractSeries(rebasedDataA, {\n    fillNeighborValue: stack ? 0 : undefined,\n    xAxis: xAxisLabel\n  });\n  const rebasedDataB = rebaseForecastDatum(data2, verboseMap);\n  const [rawSeriesB] = extractSeries(rebasedDataB, {\n    fillNeighborValue: stackB ? 0 : undefined,\n    xAxis: xAxisLabel\n  });\n  const dataTypes = getColtypesMapping(queriesData[0]);\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series = [];\n  const percentFormatter = getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const formatter = contributionMode ?\n  getNumberFormatter(',.0%') :\n  currencyFormat != null && currencyFormat.symbol ?\n  new CurrencyFormatter({\n    d3Format: yAxisFormat,\n    currency: currencyFormat\n  }) :\n  getNumberFormatter(yAxisFormat);\n  const formatterSecondary = contributionMode ?\n  getNumberFormatter(',.0%') :\n  currencyFormatSecondary != null && currencyFormatSecondary.symbol ?\n  new CurrencyFormatter({\n    d3Format: yAxisFormatSecondary,\n    currency: currencyFormatSecondary\n  }) :\n  getNumberFormatter(yAxisFormatSecondary);\n  const customFormatters = buildCustomFormatters([...ensureIsArray(metrics), ...ensureIsArray(metricsB)], currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  const customFormattersSecondary = buildCustomFormatters([...ensureIsArray(metrics), ...ensureIsArray(metricsB)], currencyFormats, columnFormats, yAxisFormatSecondary, currencyFormatSecondary);\n  const primarySeries = new Set();\n  const secondarySeries = new Set();\n  const mapSeriesIdToAxis = (seriesOption, index) => {\n    if (index === 1) {\n      secondarySeries.add(seriesOption.id);\n    } else\n    {\n      primarySeries.add(seriesOption.id);\n    }\n  };\n  rawSeriesA.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndex));\n  rawSeriesB.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndexB));\n  const showValueIndexesA = extractShowValueIndexes(rawSeriesA, {\n    stack\n  });\n  const showValueIndexesB = extractShowValueIndexes(rawSeriesB, {\n    stack\n  });\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedDataA, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel\n  });\n  const { totalStackedValues: totalStackedValuesB, thresholdValues: thresholdValuesB } = extractDataTotalValues(rebasedDataB, {\n    stack: Boolean(stackB),\n    percentageThreshold,\n    xAxisCol: xAxisLabel\n  });\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data1, xAxisLabel, xAxisType, colorScale, sliceId));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data1, annotationData, colorScale, sliceId));\n    }\n  });\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n  let [minSecondary, maxSecondary] = (yAxisBoundsSecondary || []).map(parseAxisBound);\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  rawSeriesA.forEach((entry) => {var _labelMap$seriesName;\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const seriesFormatter = getFormatter(customFormatters, formatter, metrics, labelMap == null ? void 0 : (_labelMap$seriesName = labelMap[seriesName]) == null ? void 0 : _labelMap$seriesName[0], !!contributionMode);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      showValue,\n      stack: Boolean(stack),\n      yAxisIndex,\n      filterState,\n      seriesKey: entry.name,\n      sliceId,\n      queryIndex: 0,\n      formatter: seriesType === EchartsTimeseriesSeriesType.Bar ?\n      getOverMaxHiddenFormatter({\n        max: yAxisMax,\n        formatter: seriesFormatter\n      }) :\n      seriesFormatter,\n      showValueIndexes: showValueIndexesA,\n      totalStackedValues,\n      thresholdValues\n    });\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  rawSeriesB.forEach((entry) => {var _labelMapB$seriesName;\n    const entryName = String(entry.name || '');\n    const seriesEntry = inverted[entryName] || entryName;\n    const seriesName = `${seriesEntry} (1)`;\n    const colorScaleKey = getOriginalSeries(seriesEntry, array);\n    const seriesFormatter = getFormatter(customFormattersSecondary, formatterSecondary, metricsB, labelMapB == null ? void 0 : (_labelMapB$seriesName = labelMapB[seriesName]) == null ? void 0 : _labelMapB$seriesName[0], !!contributionMode);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area: areaB,\n      markerEnabled: markerEnabledB,\n      markerSize: markerSizeB,\n      areaOpacity: opacityB,\n      seriesType: seriesTypeB,\n      showValue: showValueB,\n      stack: Boolean(stackB),\n      yAxisIndex: yAxisIndexB,\n      filterState,\n      seriesKey: primarySeries.has(entry.name) ?\n      `${entry.name} (1)` :\n      entry.name,\n      sliceId,\n      queryIndex: 1,\n      formatter: seriesTypeB === EchartsTimeseriesSeriesType.Bar ?\n      getOverMaxHiddenFormatter({\n        max: maxSecondary,\n        formatter: seriesFormatter\n      }) :\n      seriesFormatter,\n      showValueIndexes: showValueIndexesB,\n      totalStackedValues: totalStackedValuesB,\n      thresholdValues: thresholdValuesB\n    });\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  // default to 0-100% range when doing row-level contribution chart\n  if (contributionMode === 'row' && stack) {\n    if (yAxisMin === undefined)\n    yAxisMin = 0;\n    if (yAxisMax === undefined)\n    yAxisMax = 1;\n    if (minSecondary === undefined)\n    minSecondary = 0;\n    if (maxSecondary === undefined)\n    maxSecondary = 1;\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const addYAxisTitleOffset = !!(yAxisTitle || yAxisTitleSecondary);\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(showLegend, legendOrientation, addYAxisTitleOffset, zoomable, null, addXAxisTitleOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const alignTicks = yAxisIndex !== yAxisIndexB;\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...chartPadding\n    },\n    xAxis: {\n      type: xAxisType,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        rotate: xAxisLabelRotation\n      },\n      minorTick: { show: minorTicks },\n      minInterval: xAxisType === AxisType.Time && timeGrainSqla ?\n      TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n      0,\n      ...getMinAndMaxFromBounds(xAxisType, truncateXAxis, xAxisMin, xAxisMax, seriesType === EchartsTimeseriesSeriesType.Bar ||\n      seriesTypeB === EchartsTimeseriesSeriesType.Bar ?\n      EchartsTimeseriesSeriesType.Bar :\n      undefined)\n    },\n    yAxis: [\n    {\n      ...defaultYAxis,\n      type: logAxis ? 'log' : 'value',\n      min: yAxisMin,\n      max: yAxisMax,\n      minorTick: { show: minorTicks },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: {\n        formatter: getYAxisFormatter(metrics, !!contributionMode, customFormatters, formatter, yAxisFormat)\n      },\n      scale: truncateYAxis,\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n      alignTicks\n    },\n    {\n      ...defaultYAxis,\n      type: logAxisSecondary ? 'log' : 'value',\n      min: minSecondary,\n      max: maxSecondary,\n      minorTick: { show: minorTicks },\n      splitLine: { show: false },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: {\n        formatter: getYAxisFormatter(metricsB, !!contributionMode, customFormattersSecondary, formatterSecondary, yAxisFormatSecondary)\n      },\n      scale: truncateYAxis,\n      name: yAxisTitleSecondary,\n      alignTicks\n    }],\n\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {\n        const xValue = richTooltip ?\n        params[0].value[0] :\n        params.value[0];\n        const forecastValue = richTooltip ? params : [params];\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[1] - a.data[1]);\n        }\n        const rows = [];\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue);\n        const isForecast = Object.values(forecastValues).some((value) => value.forecastTrend || value.forecastLower || value.forecastUpper);\n        const total = Object.values(forecastValues).reduce((acc, value) => value.observation !== undefined ? acc + value.observation : acc, 0);\n        const showTotal = richTooltip && !isForecast;\n        const keys = Object.keys(forecastValues);\n        keys.forEach((key) => {\n          const value = forecastValues[key];\n          // if there are no dimensions, key is a verbose name of a metric,\n          // otherwise it is a comma separated string where the first part is metric name\n          let formatterKey;\n          if (primarySeries.has(key)) {var _labelMap$key;\n            formatterKey =\n            groupby.length === 0 ? inverted[key] : (_labelMap$key = labelMap[key]) == null ? void 0 : _labelMap$key[0];\n          } else\n          {var _labelMapB$key;\n            formatterKey =\n            groupbyB.length === 0 ? inverted[key] : (_labelMapB$key = labelMapB[key]) == null ? void 0 : _labelMapB$key[0];\n          }\n          const tooltipFormatter = getFormatter(customFormatters, formatter, metrics, formatterKey, !!contributionMode);\n          const tooltipFormatterSecondary = getFormatter(customFormattersSecondary, formatterSecondary, metricsB, formatterKey, !!contributionMode);\n          const row = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: primarySeries.has(key) ?\n            tooltipFormatter :\n            tooltipFormatterSecondary\n          });\n          if (showTotal && value.observation !== undefined) {\n            row.push(percentFormatter.format(value.observation / (total || 1)));\n          }\n          rows.push(row);\n        });\n        if (showTotal) {\n          rows.push([\n          'Total',\n          formatter.format(total),\n          percentFormatter.format(1)]\n          );\n        }\n        return tooltipHtml(rows, tooltipFormatter(xValue), keys.findIndex((key) => key === focusedSeries));\n      }\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable),\n      // @ts-ignore\n      data: rawSeriesA.\n      concat(rawSeriesB).\n      filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n      ForecastSeriesEnum.Observation).\n      map((entry) => entry.name || '').\n      concat(extractAnnotationLabels(annotationLayers, annotationData))\n    },\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: 'zoom area',\n            back: 'restore zoom'\n          }\n        }\n      }\n    },\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom\n    }] :\n\n    []\n  };\n  const onFocusedSeries = (seriesName) => {\n    focusedSeries = seriesName;\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    labelMapB,\n    groupby,\n    groupbyB,\n    seriesBreakdown: rawSeriesA.length,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType\n    },\n    refs,\n    coltypeMapping\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getFormatter, \"getFormatter\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/MixedTimeseries/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/MixedTimeseries/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","AxisType","buildCustomFormatters","CategoricalColorNamespace","CurrencyFormatter","ensureIsArray","GenericDataType","getCustomFormatter","getNumberFormatter","getXAxisLabel","isDefined","isEventAnnotationLayer","isFormulaAnnotationLayer","isIntervalAnnotationLayer","isPhysicalColumn","isTimeseriesAnnotationLayer","NumberFormats","tooltipHtml","getOriginalSeries","DEFAULT_FORM_DATA","EchartsTimeseriesSeriesType","ForecastSeriesEnum","parseAxisBound","dedupSeries","extractDataTotalValues","extractSeries","extractShowValueIndexes","getAxisType","getColtypesMapping","getLegendProps","getMinAndMaxFromBounds","getOverMaxHiddenFormatter","extractAnnotationLabels","getAnnotationData","extractForecastSeriesContext","extractForecastValuesFromTooltipParams","formatForecastTooltipSeries","rebaseForecastDatum","convertInteger","defaultGrid","defaultYAxis","getPadding","transformEventAnnotation","transformFormulaAnnotation","transformIntervalAnnotation","transformSeries","transformTimeseriesAnnotation","TIMEGRAIN_TO_TIMESTAMP","TIMESERIES_CONSTANTS","getDefaultTooltip","getPercentFormatter","getTooltipTimeFormatter","getXAxisFormatter","getYAxisFormatter","getFormatter","customFormatters","defaultFormatter","metrics","formatterKey","forcePercentFormat","_getCustomFormatter","transformProps","chartProps","_chartProps$rawFormDa","_dataTypes$xAxisLabel","_chartProps$rawFormDa2","width","height","formData","queriesData","hooks","filterState","datasource","theme","inContextMenu","emitCrossFilters","focusedSeries","verboseMap","currencyFormats","columnFormats","label_map","labelMap","labelMapB","data1","data","data2","annotationData","coltypeMapping","area","areaB","annotationLayers","colorScheme","contributionMode","legendOrientation","legendType","logAxis","logAxisSecondary","markerEnabled","markerEnabledB","markerSize","markerSizeB","opacity","opacityB","minorSplitLine","minorTicks","seriesType","seriesTypeB","showLegend","showValue","showValueB","stack","stackB","truncateXAxis","truncateYAxis","tooltipTimeFormat","yAxisFormat","currencyFormat","yAxisFormatSecondary","currencyFormatSecondary","xAxisTimeFormat","yAxisBounds","yAxisBoundsSecondary","yAxisIndex","yAxisIndexB","yAxisTitleSecondary","zoomable","richTooltip","tooltipSortByMetric","xAxisBounds","xAxisLabelRotation","groupby","groupbyB","xAxis","xAxisOrig","xAxisForceCategorical","xAxisTitle","yAxisTitle","xAxisTitleMargin","yAxisTitleMargin","yAxisTitlePosition","sliceId","timeGrainSqla","percentageThreshold","metricsB","refs","colorScale","getScale","xAxisLabel","rawFormData","x_axis","rebasedDataA","rawSeriesA","fillNeighborValue","rebasedDataB","rawSeriesB","dataTypes","xAxisDataType","xAxisType","series","percentFormatter","PERCENT_2_POINT","formatter","symbol","d3Format","currency","formatterSecondary","customFormattersSecondary","primarySeries","Set","secondarySeries","mapSeriesIdToAxis","seriesOption","index","add","id","forEach","showValueIndexesA","showValueIndexesB","totalStackedValues","thresholdValues","xAxisCol","totalStackedValuesB","thresholdValuesB","Boolean","filter","layer","show","push","xAxisMin","xAxisMax","map","yAxisMin","yAxisMax","minSecondary","maxSecondary","array","time_compare","inverted","_invert","entry","_labelMap$seriesName","entryName","String","name","seriesName","colorScaleKey","seriesFormatter","transformedSeries","areaOpacity","seriesKey","queryIndex","Bar","max","showValueIndexes","_labelMapB$seriesName","seriesEntry","has","tooltipFormatter","Temporal","xAxisFormatter","addYAxisTitleOffset","addXAxisTitleOffset","chartPadding","setDataMask","onContextMenu","alignTicks","echartOptions","useUTC","grid","type","nameGap","nameLocation","axisLabel","rotate","minorTick","minInterval","Time","yAxis","min","scale","splitLine","tooltip","trigger","params","xValue","value","forecastValue","sort","b","rows","forecastValues","isForecast","Object","values","some","forecastTrend","forecastLower","forecastUpper","total","reduce","acc","observation","showTotal","keys","key","_labelMap$key","length","_labelMapB$key","tooltipFormatterSecondary","row","format","findIndex","legend","concat","Observation","toolbox","top","toolboxTop","right","toolboxRight","feature","dataZoom","title","zoom","back","start","dataZoomStart","end","dataZoomEnd","bottom","zoomBottom","onFocusedSeries","seriesBreakdown","selectedValues","xValueFormatter","label","reactHotLoader","register","leaveModule"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/MixedTimeseries/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { invert } from 'lodash';\nimport {\n  AnnotationLayer,\n  AxisType,\n  buildCustomFormatters,\n  CategoricalColorNamespace,\n  CurrencyFormatter,\n  ensureIsArray,\n  GenericDataType,\n  getCustomFormatter,\n  getNumberFormatter,\n  getXAxisLabel,\n  isDefined,\n  isEventAnnotationLayer,\n  isFormulaAnnotationLayer,\n  isIntervalAnnotationLayer,\n  isPhysicalColumn,\n  isTimeseriesAnnotationLayer,\n  NumberFormats,\n  QueryFormData,\n  QueryFormMetric,\n  TimeseriesChartDataResponseResult,\n  TimeseriesDataRecord,\n  tooltipHtml,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport { getOriginalSeries } from '@superset-ui/chart-controls';\nimport { EChartsCoreOption, SeriesOption } from 'echarts';\nimport {\n  DEFAULT_FORM_DATA,\n  EchartsMixedTimeseriesChartTransformedProps,\n  EchartsMixedTimeseriesFormData,\n  EchartsMixedTimeseriesProps,\n} from './types';\nimport {\n  EchartsTimeseriesSeriesType,\n  ForecastSeriesEnum,\n  Refs,\n} from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport {\n  dedupSeries,\n  extractDataTotalValues,\n  extractSeries,\n  extractShowValueIndexes,\n  getAxisType,\n  getColtypesMapping,\n  getLegendProps,\n  getMinAndMaxFromBounds,\n  getOverMaxHiddenFormatter,\n} from '../utils/series';\nimport {\n  extractAnnotationLabels,\n  getAnnotationData,\n} from '../utils/annotation';\nimport {\n  extractForecastSeriesContext,\n  extractForecastValuesFromTooltipParams,\n  formatForecastTooltipSeries,\n  rebaseForecastDatum,\n} from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport {\n  getPadding,\n  transformEventAnnotation,\n  transformFormulaAnnotation,\n  transformIntervalAnnotation,\n  transformSeries,\n  transformTimeseriesAnnotation,\n} from '../Timeseries/transformers';\nimport { TIMEGRAIN_TO_TIMESTAMP, TIMESERIES_CONSTANTS } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport {\n  getPercentFormatter,\n  getTooltipTimeFormatter,\n  getXAxisFormatter,\n  getYAxisFormatter,\n} from '../utils/formatters';\n\nconst getFormatter = (\n  customFormatters: Record<string, ValueFormatter>,\n  defaultFormatter: ValueFormatter,\n  metrics: QueryFormMetric[],\n  formatterKey: string,\n  forcePercentFormat: boolean,\n) => {\n  if (forcePercentFormat) {\n    return getNumberFormatter(',.0%');\n  }\n  return (\n    getCustomFormatter(customFormatters, metrics, formatterKey) ??\n    defaultFormatter\n  );\n};\n\nexport default function transformProps(\n  chartProps: EchartsMixedTimeseriesProps,\n): EchartsMixedTimeseriesChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    queriesData,\n    hooks,\n    filterState,\n    datasource,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n\n  let focusedSeries: string | null = null;\n\n  const {\n    verboseMap = {},\n    currencyFormats = {},\n    columnFormats = {},\n  } = datasource;\n  const { label_map: labelMap } =\n    queriesData[0] as TimeseriesChartDataResponseResult;\n  const { label_map: labelMapB } =\n    queriesData[1] as TimeseriesChartDataResponseResult;\n  const data1 = (queriesData[0].data || []) as TimeseriesDataRecord[];\n  const data2 = (queriesData[1].data || []) as TimeseriesDataRecord[];\n  const annotationData = getAnnotationData(chartProps);\n  const coltypeMapping = {\n    ...getColtypesMapping(queriesData[0]),\n    ...getColtypesMapping(queriesData[1]),\n  };\n  const {\n    area,\n    areaB,\n    annotationLayers,\n    colorScheme,\n    contributionMode,\n    legendOrientation,\n    legendType,\n    logAxis,\n    logAxisSecondary,\n    markerEnabled,\n    markerEnabledB,\n    markerSize,\n    markerSizeB,\n    opacity,\n    opacityB,\n    minorSplitLine,\n    minorTicks,\n    seriesType,\n    seriesTypeB,\n    showLegend,\n    showValue,\n    showValueB,\n    stack,\n    stackB,\n    truncateXAxis,\n    truncateYAxis,\n    tooltipTimeFormat,\n    yAxisFormat,\n    currencyFormat,\n    yAxisFormatSecondary,\n    currencyFormatSecondary,\n    xAxisTimeFormat,\n    yAxisBounds,\n    yAxisBoundsSecondary,\n    yAxisIndex,\n    yAxisIndexB,\n    yAxisTitleSecondary,\n    zoomable,\n    richTooltip,\n    tooltipSortByMetric,\n    xAxisBounds,\n    xAxisLabelRotation,\n    groupby,\n    groupbyB,\n    xAxis: xAxisOrig,\n    xAxisForceCategorical,\n    xAxisTitle,\n    yAxisTitle,\n    xAxisTitleMargin,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    sliceId,\n    timeGrainSqla,\n    percentageThreshold,\n    metrics = [],\n    metricsB = [],\n  }: EchartsMixedTimeseriesFormData = { ...DEFAULT_FORM_DATA, ...formData };\n\n  const refs: Refs = {};\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme as string);\n\n  let xAxisLabel = getXAxisLabel(\n    chartProps.rawFormData as QueryFormData,\n  ) as string;\n  if (\n    isPhysicalColumn(chartProps.rawFormData?.x_axis) &&\n    isDefined(verboseMap[xAxisLabel])\n  ) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n\n  const rebasedDataA = rebaseForecastDatum(data1, verboseMap);\n  const [rawSeriesA] = extractSeries(rebasedDataA, {\n    fillNeighborValue: stack ? 0 : undefined,\n    xAxis: xAxisLabel,\n  });\n  const rebasedDataB = rebaseForecastDatum(data2, verboseMap);\n  const [rawSeriesB] = extractSeries(rebasedDataB, {\n    fillNeighborValue: stackB ? 0 : undefined,\n    xAxis: xAxisLabel,\n  });\n\n  const dataTypes = getColtypesMapping(queriesData[0]);\n  const xAxisDataType = dataTypes?.[xAxisLabel] ?? dataTypes?.[xAxisOrig];\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series: SeriesOption[] = [];\n  const percentFormatter = getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const formatter = contributionMode\n    ? getNumberFormatter(',.0%')\n    : currencyFormat?.symbol\n      ? new CurrencyFormatter({\n          d3Format: yAxisFormat,\n          currency: currencyFormat,\n        })\n      : getNumberFormatter(yAxisFormat);\n  const formatterSecondary = contributionMode\n    ? getNumberFormatter(',.0%')\n    : currencyFormatSecondary?.symbol\n      ? new CurrencyFormatter({\n          d3Format: yAxisFormatSecondary,\n          currency: currencyFormatSecondary,\n        })\n      : getNumberFormatter(yAxisFormatSecondary);\n  const customFormatters = buildCustomFormatters(\n    [...ensureIsArray(metrics), ...ensureIsArray(metricsB)],\n    currencyFormats,\n    columnFormats,\n    yAxisFormat,\n    currencyFormat,\n  );\n  const customFormattersSecondary = buildCustomFormatters(\n    [...ensureIsArray(metrics), ...ensureIsArray(metricsB)],\n    currencyFormats,\n    columnFormats,\n    yAxisFormatSecondary,\n    currencyFormatSecondary,\n  );\n\n  const primarySeries = new Set<string>();\n  const secondarySeries = new Set<string>();\n  const mapSeriesIdToAxis = (\n    seriesOption: SeriesOption,\n    index?: number,\n  ): void => {\n    if (index === 1) {\n      secondarySeries.add(seriesOption.id as string);\n    } else {\n      primarySeries.add(seriesOption.id as string);\n    }\n  };\n  rawSeriesA.forEach(seriesOption =>\n    mapSeriesIdToAxis(seriesOption, yAxisIndex),\n  );\n  rawSeriesB.forEach(seriesOption =>\n    mapSeriesIdToAxis(seriesOption, yAxisIndexB),\n  );\n  const showValueIndexesA = extractShowValueIndexes(rawSeriesA, {\n    stack,\n  });\n  const showValueIndexesB = extractShowValueIndexes(rawSeriesB, {\n    stack,\n  });\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(\n    rebasedDataA,\n    {\n      stack,\n      percentageThreshold,\n      xAxisCol: xAxisLabel,\n    },\n  );\n  const {\n    totalStackedValues: totalStackedValuesB,\n    thresholdValues: thresholdValuesB,\n  } = extractDataTotalValues(rebasedDataB, {\n    stack: Boolean(stackB),\n    percentageThreshold,\n    xAxisCol: xAxisLabel,\n  });\n\n  annotationLayers\n    .filter((layer: AnnotationLayer) => layer.show)\n    .forEach((layer: AnnotationLayer) => {\n      if (isFormulaAnnotationLayer(layer))\n        series.push(\n          transformFormulaAnnotation(\n            layer,\n            data1,\n            xAxisLabel,\n            xAxisType,\n            colorScale,\n            sliceId,\n          ),\n        );\n      else if (isIntervalAnnotationLayer(layer)) {\n        series.push(\n          ...transformIntervalAnnotation(\n            layer,\n            data1,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isEventAnnotationLayer(layer)) {\n        series.push(\n          ...transformEventAnnotation(\n            layer,\n            data1,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isTimeseriesAnnotationLayer(layer)) {\n        series.push(\n          ...transformTimeseriesAnnotation(\n            layer,\n            markerSize,\n            data1,\n            annotationData,\n            colorScale,\n            sliceId,\n          ),\n        );\n      }\n    });\n\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n  let [minSecondary, maxSecondary] = (yAxisBoundsSecondary || []).map(\n    parseAxisBound,\n  );\n\n  const array = ensureIsArray(chartProps.rawFormData?.time_compare);\n  const inverted = invert(verboseMap);\n\n  rawSeriesA.forEach(entry => {\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const seriesFormatter = getFormatter(\n      customFormatters,\n      formatter,\n      metrics,\n      labelMap?.[seriesName]?.[0],\n      !!contributionMode,\n    );\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area,\n        markerEnabled,\n        markerSize,\n        areaOpacity: opacity,\n        seriesType,\n        showValue,\n        stack: Boolean(stack),\n        yAxisIndex,\n        filterState,\n        seriesKey: entry.name,\n        sliceId,\n        queryIndex: 0,\n        formatter:\n          seriesType === EchartsTimeseriesSeriesType.Bar\n            ? getOverMaxHiddenFormatter({\n                max: yAxisMax,\n                formatter: seriesFormatter,\n              })\n            : seriesFormatter,\n        showValueIndexes: showValueIndexesA,\n        totalStackedValues,\n        thresholdValues,\n      },\n    );\n    if (transformedSeries) series.push(transformedSeries);\n  });\n\n  rawSeriesB.forEach(entry => {\n    const entryName = String(entry.name || '');\n    const seriesEntry = inverted[entryName] || entryName;\n    const seriesName = `${seriesEntry} (1)`;\n    const colorScaleKey = getOriginalSeries(seriesEntry, array);\n\n    const seriesFormatter = getFormatter(\n      customFormattersSecondary,\n      formatterSecondary,\n      metricsB,\n      labelMapB?.[seriesName]?.[0],\n      !!contributionMode,\n    );\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area: areaB,\n        markerEnabled: markerEnabledB,\n        markerSize: markerSizeB,\n        areaOpacity: opacityB,\n        seriesType: seriesTypeB,\n        showValue: showValueB,\n        stack: Boolean(stackB),\n        yAxisIndex: yAxisIndexB,\n        filterState,\n        seriesKey: primarySeries.has(entry.name as string)\n          ? `${entry.name} (1)`\n          : entry.name,\n        sliceId,\n        queryIndex: 1,\n        formatter:\n          seriesTypeB === EchartsTimeseriesSeriesType.Bar\n            ? getOverMaxHiddenFormatter({\n                max: maxSecondary,\n                formatter: seriesFormatter,\n              })\n            : seriesFormatter,\n        showValueIndexes: showValueIndexesB,\n        totalStackedValues: totalStackedValuesB,\n        thresholdValues: thresholdValuesB,\n      },\n    );\n    if (transformedSeries) series.push(transformedSeries);\n  });\n\n  // default to 0-100% range when doing row-level contribution chart\n  if (contributionMode === 'row' && stack) {\n    if (yAxisMin === undefined) yAxisMin = 0;\n    if (yAxisMax === undefined) yAxisMax = 1;\n    if (minSecondary === undefined) minSecondary = 0;\n    if (maxSecondary === undefined) maxSecondary = 1;\n  }\n\n  const tooltipFormatter =\n    xAxisDataType === GenericDataType.Temporal\n      ? getTooltipTimeFormatter(tooltipTimeFormat)\n      : String;\n  const xAxisFormatter =\n    xAxisDataType === GenericDataType.Temporal\n      ? getXAxisFormatter(xAxisTimeFormat)\n      : String;\n\n  const addYAxisTitleOffset = !!(yAxisTitle || yAxisTitleSecondary);\n  const addXAxisTitleOffset = !!xAxisTitle;\n\n  const chartPadding = getPadding(\n    showLegend,\n    legendOrientation,\n    addYAxisTitleOffset,\n    zoomable,\n    null,\n    addXAxisTitleOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n  );\n\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const alignTicks = yAxisIndex !== yAxisIndexB;\n\n  const echartOptions: EChartsCoreOption = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...chartPadding,\n    },\n    xAxis: {\n      type: xAxisType,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        rotate: xAxisLabelRotation,\n      },\n      minorTick: { show: minorTicks },\n      minInterval:\n        xAxisType === AxisType.Time && timeGrainSqla\n          ? TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla]\n          : 0,\n      ...getMinAndMaxFromBounds(\n        xAxisType,\n        truncateXAxis,\n        xAxisMin,\n        xAxisMax,\n        seriesType === EchartsTimeseriesSeriesType.Bar ||\n          seriesTypeB === EchartsTimeseriesSeriesType.Bar\n          ? EchartsTimeseriesSeriesType.Bar\n          : undefined,\n      ),\n    },\n    yAxis: [\n      {\n        ...defaultYAxis,\n        type: logAxis ? 'log' : 'value',\n        min: yAxisMin,\n        max: yAxisMax,\n        minorTick: { show: minorTicks },\n        minorSplitLine: { show: minorSplitLine },\n        axisLabel: {\n          formatter: getYAxisFormatter(\n            metrics,\n            !!contributionMode,\n            customFormatters,\n            formatter,\n            yAxisFormat,\n          ),\n        },\n        scale: truncateYAxis,\n        name: yAxisTitle,\n        nameGap: convertInteger(yAxisTitleMargin),\n        nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n        alignTicks,\n      },\n      {\n        ...defaultYAxis,\n        type: logAxisSecondary ? 'log' : 'value',\n        min: minSecondary,\n        max: maxSecondary,\n        minorTick: { show: minorTicks },\n        splitLine: { show: false },\n        minorSplitLine: { show: minorSplitLine },\n        axisLabel: {\n          formatter: getYAxisFormatter(\n            metricsB,\n            !!contributionMode,\n            customFormattersSecondary,\n            formatterSecondary,\n            yAxisFormatSecondary,\n          ),\n        },\n        scale: truncateYAxis,\n        name: yAxisTitleSecondary,\n        alignTicks,\n      },\n    ],\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params: any) => {\n        const xValue: number = richTooltip\n          ? params[0].value[0]\n          : params.value[0];\n        const forecastValue: any[] = richTooltip ? params : [params];\n\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[1] - a.data[1]);\n        }\n\n        const rows: string[][] = [];\n        const forecastValues =\n          extractForecastValuesFromTooltipParams(forecastValue);\n\n        const isForecast = Object.values(forecastValues).some(\n          value =>\n            value.forecastTrend || value.forecastLower || value.forecastUpper,\n        );\n\n        const total = Object.values(forecastValues).reduce(\n          (acc, value) =>\n            value.observation !== undefined ? acc + value.observation : acc,\n          0,\n        );\n        const showTotal = richTooltip && !isForecast;\n        const keys = Object.keys(forecastValues);\n        keys.forEach(key => {\n          const value = forecastValues[key];\n          // if there are no dimensions, key is a verbose name of a metric,\n          // otherwise it is a comma separated string where the first part is metric name\n          let formatterKey;\n          if (primarySeries.has(key)) {\n            formatterKey =\n              groupby.length === 0 ? inverted[key] : labelMap[key]?.[0];\n          } else {\n            formatterKey =\n              groupbyB.length === 0 ? inverted[key] : labelMapB[key]?.[0];\n          }\n          const tooltipFormatter = getFormatter(\n            customFormatters,\n            formatter,\n            metrics,\n            formatterKey,\n            !!contributionMode,\n          );\n          const tooltipFormatterSecondary = getFormatter(\n            customFormattersSecondary,\n            formatterSecondary,\n            metricsB,\n            formatterKey,\n            !!contributionMode,\n          );\n          const row = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: primarySeries.has(key)\n              ? tooltipFormatter\n              : tooltipFormatterSecondary,\n          });\n          if (showTotal && value.observation !== undefined) {\n            row.push(percentFormatter.format(value.observation / (total || 1)));\n          }\n          rows.push(row);\n        });\n        if (showTotal) {\n          rows.push([\n            'Total',\n            formatter.format(total),\n            percentFormatter.format(1),\n          ]);\n        }\n        return tooltipHtml(\n          rows,\n          tooltipFormatter(xValue),\n          keys.findIndex(key => key === focusedSeries),\n        );\n      },\n    },\n    legend: {\n      ...getLegendProps(\n        legendType,\n        legendOrientation,\n        showLegend,\n        theme,\n        zoomable,\n      ),\n      // @ts-ignore\n      data: rawSeriesA\n        .concat(rawSeriesB)\n        .filter(\n          entry =>\n            extractForecastSeriesContext((entry.name || '') as string).type ===\n            ForecastSeriesEnum.Observation,\n        )\n        .map(entry => entry.name || '')\n        .concat(extractAnnotationLabels(annotationLayers, annotationData)),\n    },\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: 'zoom area',\n            back: 'restore zoom',\n          },\n        },\n      },\n    },\n    dataZoom: zoomable\n      ? [\n          {\n            type: 'slider',\n            start: TIMESERIES_CONSTANTS.dataZoomStart,\n            end: TIMESERIES_CONSTANTS.dataZoomEnd,\n            bottom: TIMESERIES_CONSTANTS.zoomBottom,\n          },\n        ]\n      : [],\n  };\n\n  const onFocusedSeries = (seriesName: string | null) => {\n    focusedSeries = seriesName;\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    labelMapB,\n    groupby,\n    groupbyB,\n    seriesBreakdown: rawSeriesA.length,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType,\n    },\n    refs,\n    coltypeMapping,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}