{"ast":null,"code":"import _pick from \"lodash/pick\";import _omit from \"lodash/omit\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { ensureIsArray } from '@superset-ui/core';\n\nimport { DYNAMIC_PLUGIN_CONTROLS_READY } from 'src/components/Chart/chartAction';\nimport { getControlsState } from 'src/explore/store';\nimport {\n  getControlConfig,\n  getControlStateFromControlConfig,\n  getControlValuesCompatibleWithDatasource,\n  StandardizedFormData } from\n'src/explore/controlUtils';\nimport * as actions from 'src/explore/actions/exploreActions';\nimport { HYDRATE_EXPLORE } from '../actions/hydrateExplore';\n\nexport default function exploreReducer(state = {}, action) {\n  const actionHandlers = {\n    [DYNAMIC_PLUGIN_CONTROLS_READY]() {\n      return {\n        ...state,\n        controls: action.controlsState\n      };\n    },\n    [actions.TOGGLE_FAVE_STAR]() {\n      return {\n        ...state,\n        isStarred: action.isStarred\n      };\n    },\n    [actions.POST_DATASOURCE_STARTED]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: true\n      };\n    },\n    [actions.UPDATE_FORM_DATA_BY_DATASOURCE]() {\n      const newFormData = { ...state.form_data };\n      const { prevDatasource, newDatasource } = action;\n      const controls = { ...state.controls };\n      const controlsTransferred = [];\n\n      if (\n      prevDatasource.id !== newDatasource.id ||\n      prevDatasource.type !== newDatasource.type)\n      {\n        newFormData.datasource = newDatasource.uid;\n      }\n      // reset control values for column/metric related controls\n      Object.entries(controls).forEach(([controlName, controlState]) => {\n        if (\n        // for direct column select controls\n        controlState.valueKey === 'column_name' ||\n        // for all other controls\n        'savedMetrics' in controlState ||\n        'columns' in controlState ||\n        'options' in controlState && !Array.isArray(controlState.options))\n        {\n          newFormData[controlName] = getControlValuesCompatibleWithDatasource(\n            newDatasource,\n            controlState,\n            controlState.value\n          );\n          if (\n          ensureIsArray(newFormData[controlName]).length > 0 &&\n          newFormData[controlName] !== controls[controlName].default)\n          {\n            controlsTransferred.push(controlName);\n          }\n        }\n      });\n\n      const newState = {\n        ...state,\n        controls,\n        datasource: action.newDatasource\n      };\n      return {\n        ...newState,\n        form_data: newFormData,\n        controls: getControlsState(newState, newFormData),\n        controlsTransferred\n      };\n    },\n    [actions.FETCH_DATASOURCES_STARTED]() {\n      return {\n        ...state,\n        isDatasourcesLoading: true\n      };\n    },\n    [actions.SET_FIELD_VALUE]() {\n      const { controlName, value, validationErrors } = action;\n      let new_form_data = { ...state.form_data, [controlName]: value };\n      const old_metrics_data = state.form_data.metrics;\n      const new_column_config = state.form_data.column_config;\n\n      const vizType = new_form_data.viz_type;\n\n      // if the controlName is metrics, and the metric column name is updated,\n      // need to update column config as well to keep the previous config.\n      if (controlName === 'metrics' && old_metrics_data && new_column_config) {\n        value.forEach((item, index) => {var _old_metrics_data$ind, _old_metrics_data$ind2;\n          const itemExist = old_metrics_data.some(\n            (oldItem) => (oldItem == null ? void 0 : oldItem.label) === (item == null ? void 0 : item.label)\n          );\n\n          if (\n          !itemExist &&\n          (item == null ? void 0 : item.label) !== ((_old_metrics_data$ind = old_metrics_data[index]) == null ? void 0 : _old_metrics_data$ind.label) &&\n          !!new_column_config[(_old_metrics_data$ind2 = old_metrics_data[index]) == null ? void 0 : _old_metrics_data$ind2.label])\n          {\n            new_column_config[item.label] =\n            new_column_config[old_metrics_data[index].label];\n\n            delete new_column_config[old_metrics_data[index].label];\n          }\n        });\n        new_form_data.column_config = new_column_config;\n      }\n\n      // Use the processed control config (with overrides and everything)\n      // if `controlName` does not exist in current controls,\n      const controlConfig =\n      state.controls[action.controlName] ||\n      getControlConfig(action.controlName, vizType) ||\n      null;\n\n      // will call validators again\n      const control = {\n        ...getControlStateFromControlConfig(controlConfig, state, action.value)\n      };\n\n      const column_config = {\n        ...state.controls.column_config,\n        ...(new_column_config && { value: new_column_config })\n      };\n\n      const newState = {\n        ...state,\n        controls: {\n          ...state.controls,\n          ...(controlConfig && { [controlName]: control }),\n          ...(controlName === 'metrics' && { column_config })\n        }\n      };\n\n      const rerenderedControls = {};\n      if (Array.isArray(control.rerender)) {\n        control.rerender.forEach((controlName) => {\n          rerenderedControls[controlName] = {\n            ...getControlStateFromControlConfig(\n              newState.controls[controlName],\n              newState,\n              newState.controls[controlName].value\n            )\n          };\n        });\n      }\n\n      // combine newly detected errors with errors from `onChange` event of\n      // each control component (passed via reducer action).\n      const errors = control.validationErrors || [];\n      (validationErrors || []).forEach((err) => {\n        // skip duplicated errors\n        if (!errors.includes(err)) {\n          errors.push(err);\n        }\n      });\n      const hasErrors = errors && errors.length > 0;\n\n      const isVizSwitch =\n      action.controlName === 'viz_type' &&\n      action.value !== state.controls.viz_type.value;\n      let currentControlsState = state.controls;\n      if (isVizSwitch) {\n        // get StandardizedFormData from source form_data\n        const sfd = new StandardizedFormData(state.form_data);\n        const transformed = sfd.transform(action.value, state);\n        new_form_data = transformed.formData;\n        currentControlsState = transformed.controlsState;\n      }\n\n      return {\n        ...state,\n        form_data: new_form_data,\n        triggerRender: control.renderTrigger && !hasErrors,\n        controls: {\n          ...currentControlsState,\n          ...(controlConfig && {\n            [action.controlName]: {\n              ...control,\n              validationErrors: errors\n            }\n          }),\n          ...rerenderedControls\n        }\n      };\n    },\n    [actions.SET_EXPLORE_CONTROLS]() {\n      return {\n        ...state,\n        controls: getControlsState(state, action.formData)\n      };\n    },\n    [actions.SET_FORM_DATA]() {\n      return {\n        ...state,\n        form_data: action.formData\n      };\n    },\n    [actions.UPDATE_CHART_TITLE]() {\n      return {\n        ...state,\n        sliceName: action.sliceName\n      };\n    },\n    [actions.SET_SAVE_ACTION]() {\n      return {\n        ...state,\n        saveAction: action.saveAction\n      };\n    },\n    [actions.CREATE_NEW_SLICE]() {\n      return {\n        ...state,\n        slice: action.slice,\n        controls: getControlsState(state, action.form_data),\n        can_add: action.can_add,\n        can_download: action.can_download,\n        can_overwrite: action.can_overwrite\n      };\n    },\n    [actions.SET_STASH_FORM_DATA]() {\n      const { form_data, hiddenFormData } = state;\n      const { fieldNames, isHidden } = action;\n      if (isHidden) {\n        return {\n          ...state,\n          hiddenFormData: {\n            ...hiddenFormData,\n            ..._pick(form_data, fieldNames)\n          },\n          form_data: _omit(form_data, fieldNames)\n        };\n      }\n\n      const restoredField = _pick(hiddenFormData, fieldNames);\n      return {\n        ...state,\n        form_data: {\n          ...form_data,\n          ...restoredField\n        },\n        hiddenFormData\n      };\n    },\n    [actions.SLICE_UPDATED]() {var _action$slice$slice_n;\n      return {\n        ...state,\n        slice: {\n          ...state.slice,\n          ...action.slice,\n          owners: action.slice.owners ?\n          action.slice.owners.map((owner) => owner.value) :\n          null\n        },\n        sliceName: (_action$slice$slice_n = action.slice.slice_name) != null ? _action$slice$slice_n : state.sliceName,\n        metadata: {\n          ...state.metadata,\n          owners: action.slice.owners ?\n          action.slice.owners.map((owner) => owner.label) :\n          null\n        }\n      };\n    },\n    [actions.SET_FORCE_QUERY]() {\n      return {\n        ...state,\n        force: action.force\n      };\n    },\n    [HYDRATE_EXPLORE]() {\n      return {\n        ...action.data.explore\n      };\n    }\n  };\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(exploreReducer, \"exploreReducer\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/reducers/exploreReducer.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["ensureIsArray","DYNAMIC_PLUGIN_CONTROLS_READY","getControlsState","getControlConfig","getControlStateFromControlConfig","getControlValuesCompatibleWithDatasource","StandardizedFormData","actions","HYDRATE_EXPLORE","exploreReducer","state","action","actionHandlers","controls","controlsState","TOGGLE_FAVE_STAR","isStarred","POST_DATASOURCE_STARTED","isDatasourceMetaLoading","UPDATE_FORM_DATA_BY_DATASOURCE","newFormData","form_data","prevDatasource","newDatasource","controlsTransferred","id","type","datasource","uid","Object","entries","forEach","controlName","controlState","valueKey","Array","isArray","options","value","length","default","push","newState","FETCH_DATASOURCES_STARTED","isDatasourcesLoading","SET_FIELD_VALUE","validationErrors","new_form_data","old_metrics_data","metrics","new_column_config","column_config","vizType","viz_type","item","index","_old_metrics_data$ind","_old_metrics_data$ind2","itemExist","some","oldItem","label","controlConfig","control","rerenderedControls","rerender","errors","err","includes","hasErrors","isVizSwitch","currentControlsState","sfd","transformed","transform","formData","triggerRender","renderTrigger","SET_EXPLORE_CONTROLS","SET_FORM_DATA","UPDATE_CHART_TITLE","sliceName","SET_SAVE_ACTION","saveAction","CREATE_NEW_SLICE","slice","can_add","can_download","can_overwrite","SET_STASH_FORM_DATA","hiddenFormData","fieldNames","isHidden","_pick","_omit","restoredField","SLICE_UPDATED","_action$slice$slice_n","owners","map","owner","slice_name","metadata","SET_FORCE_QUERY","force","data","explore","reactHotLoader","reactHotLoaderGlobal","undefined","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/reducers/exploreReducer.js"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { ensureIsArray } from '@superset-ui/core';\nimport { omit, pick } from 'lodash';\nimport { DYNAMIC_PLUGIN_CONTROLS_READY } from 'src/components/Chart/chartAction';\nimport { getControlsState } from 'src/explore/store';\nimport {\n  getControlConfig,\n  getControlStateFromControlConfig,\n  getControlValuesCompatibleWithDatasource,\n  StandardizedFormData,\n} from 'src/explore/controlUtils';\nimport * as actions from 'src/explore/actions/exploreActions';\nimport { HYDRATE_EXPLORE } from '../actions/hydrateExplore';\n\nexport default function exploreReducer(state = {}, action) {\n  const actionHandlers = {\n    [DYNAMIC_PLUGIN_CONTROLS_READY]() {\n      return {\n        ...state,\n        controls: action.controlsState,\n      };\n    },\n    [actions.TOGGLE_FAVE_STAR]() {\n      return {\n        ...state,\n        isStarred: action.isStarred,\n      };\n    },\n    [actions.POST_DATASOURCE_STARTED]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: true,\n      };\n    },\n    [actions.UPDATE_FORM_DATA_BY_DATASOURCE]() {\n      const newFormData = { ...state.form_data };\n      const { prevDatasource, newDatasource } = action;\n      const controls = { ...state.controls };\n      const controlsTransferred = [];\n\n      if (\n        prevDatasource.id !== newDatasource.id ||\n        prevDatasource.type !== newDatasource.type\n      ) {\n        newFormData.datasource = newDatasource.uid;\n      }\n      // reset control values for column/metric related controls\n      Object.entries(controls).forEach(([controlName, controlState]) => {\n        if (\n          // for direct column select controls\n          controlState.valueKey === 'column_name' ||\n          // for all other controls\n          'savedMetrics' in controlState ||\n          'columns' in controlState ||\n          ('options' in controlState && !Array.isArray(controlState.options))\n        ) {\n          newFormData[controlName] = getControlValuesCompatibleWithDatasource(\n            newDatasource,\n            controlState,\n            controlState.value,\n          );\n          if (\n            ensureIsArray(newFormData[controlName]).length > 0 &&\n            newFormData[controlName] !== controls[controlName].default\n          ) {\n            controlsTransferred.push(controlName);\n          }\n        }\n      });\n\n      const newState = {\n        ...state,\n        controls,\n        datasource: action.newDatasource,\n      };\n      return {\n        ...newState,\n        form_data: newFormData,\n        controls: getControlsState(newState, newFormData),\n        controlsTransferred,\n      };\n    },\n    [actions.FETCH_DATASOURCES_STARTED]() {\n      return {\n        ...state,\n        isDatasourcesLoading: true,\n      };\n    },\n    [actions.SET_FIELD_VALUE]() {\n      const { controlName, value, validationErrors } = action;\n      let new_form_data = { ...state.form_data, [controlName]: value };\n      const old_metrics_data = state.form_data.metrics;\n      const new_column_config = state.form_data.column_config;\n\n      const vizType = new_form_data.viz_type;\n\n      // if the controlName is metrics, and the metric column name is updated,\n      // need to update column config as well to keep the previous config.\n      if (controlName === 'metrics' && old_metrics_data && new_column_config) {\n        value.forEach((item, index) => {\n          const itemExist = old_metrics_data.some(\n            oldItem => oldItem?.label === item?.label,\n          );\n\n          if (\n            !itemExist &&\n            item?.label !== old_metrics_data[index]?.label &&\n            !!new_column_config[old_metrics_data[index]?.label]\n          ) {\n            new_column_config[item.label] =\n              new_column_config[old_metrics_data[index].label];\n\n            delete new_column_config[old_metrics_data[index].label];\n          }\n        });\n        new_form_data.column_config = new_column_config;\n      }\n\n      // Use the processed control config (with overrides and everything)\n      // if `controlName` does not exist in current controls,\n      const controlConfig =\n        state.controls[action.controlName] ||\n        getControlConfig(action.controlName, vizType) ||\n        null;\n\n      // will call validators again\n      const control = {\n        ...getControlStateFromControlConfig(controlConfig, state, action.value),\n      };\n\n      const column_config = {\n        ...state.controls.column_config,\n        ...(new_column_config && { value: new_column_config }),\n      };\n\n      const newState = {\n        ...state,\n        controls: {\n          ...state.controls,\n          ...(controlConfig && { [controlName]: control }),\n          ...(controlName === 'metrics' && { column_config }),\n        },\n      };\n\n      const rerenderedControls = {};\n      if (Array.isArray(control.rerender)) {\n        control.rerender.forEach(controlName => {\n          rerenderedControls[controlName] = {\n            ...getControlStateFromControlConfig(\n              newState.controls[controlName],\n              newState,\n              newState.controls[controlName].value,\n            ),\n          };\n        });\n      }\n\n      // combine newly detected errors with errors from `onChange` event of\n      // each control component (passed via reducer action).\n      const errors = control.validationErrors || [];\n      (validationErrors || []).forEach(err => {\n        // skip duplicated errors\n        if (!errors.includes(err)) {\n          errors.push(err);\n        }\n      });\n      const hasErrors = errors && errors.length > 0;\n\n      const isVizSwitch =\n        action.controlName === 'viz_type' &&\n        action.value !== state.controls.viz_type.value;\n      let currentControlsState = state.controls;\n      if (isVizSwitch) {\n        // get StandardizedFormData from source form_data\n        const sfd = new StandardizedFormData(state.form_data);\n        const transformed = sfd.transform(action.value, state);\n        new_form_data = transformed.formData;\n        currentControlsState = transformed.controlsState;\n      }\n\n      return {\n        ...state,\n        form_data: new_form_data,\n        triggerRender: control.renderTrigger && !hasErrors,\n        controls: {\n          ...currentControlsState,\n          ...(controlConfig && {\n            [action.controlName]: {\n              ...control,\n              validationErrors: errors,\n            },\n          }),\n          ...rerenderedControls,\n        },\n      };\n    },\n    [actions.SET_EXPLORE_CONTROLS]() {\n      return {\n        ...state,\n        controls: getControlsState(state, action.formData),\n      };\n    },\n    [actions.SET_FORM_DATA]() {\n      return {\n        ...state,\n        form_data: action.formData,\n      };\n    },\n    [actions.UPDATE_CHART_TITLE]() {\n      return {\n        ...state,\n        sliceName: action.sliceName,\n      };\n    },\n    [actions.SET_SAVE_ACTION]() {\n      return {\n        ...state,\n        saveAction: action.saveAction,\n      };\n    },\n    [actions.CREATE_NEW_SLICE]() {\n      return {\n        ...state,\n        slice: action.slice,\n        controls: getControlsState(state, action.form_data),\n        can_add: action.can_add,\n        can_download: action.can_download,\n        can_overwrite: action.can_overwrite,\n      };\n    },\n    [actions.SET_STASH_FORM_DATA]() {\n      const { form_data, hiddenFormData } = state;\n      const { fieldNames, isHidden } = action;\n      if (isHidden) {\n        return {\n          ...state,\n          hiddenFormData: {\n            ...hiddenFormData,\n            ...pick(form_data, fieldNames),\n          },\n          form_data: omit(form_data, fieldNames),\n        };\n      }\n\n      const restoredField = pick(hiddenFormData, fieldNames);\n      return {\n        ...state,\n        form_data: {\n          ...form_data,\n          ...restoredField,\n        },\n        hiddenFormData,\n      };\n    },\n    [actions.SLICE_UPDATED]() {\n      return {\n        ...state,\n        slice: {\n          ...state.slice,\n          ...action.slice,\n          owners: action.slice.owners\n            ? action.slice.owners.map(owner => owner.value)\n            : null,\n        },\n        sliceName: action.slice.slice_name ?? state.sliceName,\n        metadata: {\n          ...state.metadata,\n          owners: action.slice.owners\n            ? action.slice.owners.map(owner => owner.label)\n            : null,\n        },\n      };\n    },\n    [actions.SET_FORCE_QUERY]() {\n      return {\n        ...state,\n        force: action.force,\n      };\n    },\n    [HYDRATE_EXPLORE]() {\n      return {\n        ...action.data.explore,\n      };\n    },\n  };\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}