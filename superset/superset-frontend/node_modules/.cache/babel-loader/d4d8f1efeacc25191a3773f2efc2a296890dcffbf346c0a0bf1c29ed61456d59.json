{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { DataMaskType, ensureIsArray, FeatureFlag, getColumnLabel, isFeatureEnabled, NativeFilterType, NO_TIME_RANGE } from '@superset-ui/core';\nimport { TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { areObjectsEqual } from 'src/reduxUtils';\nexport var IndicatorStatus;\n(function (IndicatorStatus) {\n  IndicatorStatus[\"Unset\"] = \"UNSET\";\n  IndicatorStatus[\"Applied\"] = \"APPLIED\";\n  IndicatorStatus[\"Incompatible\"] = \"INCOMPATIBLE\";\n  IndicatorStatus[\"CrossFilterApplied\"] = \"CROSS_FILTER_APPLIED\";\n})(IndicatorStatus || (IndicatorStatus = {}));\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\nexport const extractLabel = (filter) => {var _filter$label;\n  if (filter != null && filter.label && !(filter != null && (_filter$label = filter.label) != null && _filter$label.includes(undefined))) {\n    return filter.label;\n  }\n  if (filter != null && filter.value) {\n    return ensureIsArray(filter == null ? void 0 : filter.value).join(', ');\n  }\n  return null;\n};\nconst selectIndicatorValue = (columnKey, filter, datasource) => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n  if (values == null ||\n  filter.isDateFilter && values === NO_TIME_RANGE ||\n  arrValues.length === 0) {\n    return [];\n  }\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = ((columnKey === TIME_FILTER_MAP.time_grain_sqla ?\n    datasource.time_grain_sqla :\n    datasource.granularity) || []).reduce((map, [key, value]) => ({\n      ...map,\n      [key]: value\n    }), {});\n    return arrValues.map((value) => timeGranularityMap[value] || value);\n  }\n  return arrValues;\n};\nconst selectIndicatorsForChartFromFilter = (chartId, filter, filterDataSource, appliedColumns, rejectedColumns) => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column, filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n    return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n  return Object.keys(filter.columns).\n  filter((column) => getChartIdsInFilterScope({\n    filterScope: filter.scopes[column]\n  }).includes(chartId)).\n  map((column) => ({\n    column,\n    name: filter.labels[column] || column,\n    value: selectIndicatorValue(column, filter, filterDataSource),\n    status: getStatus(column, filter),\n    path: filter.directPathToFilter\n  }));\n};\nconst getAppliedColumns = (chart) => {var _chart$queriesRespons, _chart$queriesRespons2;return new Set(((chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.applied_filters) || []).map((filter) => filter.column));};\nconst getRejectedColumns = (chart) => {var _chart$queriesRespons3, _chart$queriesRespons4;return new Set(((chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.rejected_filters) || []).map((filter) => getColumnLabel(filter.column)));};\nexport const getCrossFilterIndicator = (chartId, dataMask, dashboardLayout) => {var _dataMask$extraFormDa, _filters$, _dashboardLayoutItem$, _dashboardLayoutItem$2, _dashboardLayoutItem$3;\n  const filterState = dataMask == null ? void 0 : dataMask.filterState;\n  const filters = dataMask == null ? void 0 : (_dataMask$extraFormDa = dataMask.extraFormData) == null ? void 0 : _dataMask$extraFormDa.filters;\n  const label = extractLabel(filterState);\n  const filtersState = filterState == null ? void 0 : filterState.filters;\n  const column = (filters == null ? void 0 : (_filters$ = filters[0]) == null ? void 0 : _filters$.col) || filtersState && Object.keys(filtersState)[0];\n  const dashboardLayoutItem = Object.values(dashboardLayout).find((layoutItem) => {var _layoutItem$meta;return (layoutItem == null ? void 0 : (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === chartId;});\n  const filterObject = {\n    column,\n    name: (dashboardLayoutItem == null ? void 0 : (_dashboardLayoutItem$ = dashboardLayoutItem.meta) == null ? void 0 : _dashboardLayoutItem$.sliceNameOverride) || (\n    dashboardLayoutItem == null ? void 0 : (_dashboardLayoutItem$2 = dashboardLayoutItem.meta) == null ? void 0 : _dashboardLayoutItem$2.sliceName) ||\n    '',\n    path: [\n    ...((_dashboardLayoutItem$3 = dashboardLayoutItem == null ? void 0 : dashboardLayoutItem.parents) != null ? _dashboardLayoutItem$3 : []),\n    (dashboardLayoutItem == null ? void 0 : dashboardLayoutItem.id) || ''],\n\n    value: label\n  };\n  return filterObject;\n};\nconst cachedIndicatorsForChart = {};\nconst cachedDashboardFilterDataForChart = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (chartId, filters, datasources, chart) => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter((filter) => filter.chartId !== chartId);\n  const matchingDatasources = Object.entries(datasources).\n  filter(([key]) => matchingFilters.find((filter) => filter.datasourceId === key)).\n  map(([, datasource]) => datasource);\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (cachedIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.matchingFilters, matchingFilters) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.matchingDatasources, matchingDatasources)) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce((acc, filter) => acc.concat(selectIndicatorsForChartFromFilter(chartId, filter, datasources[filter.datasourceId] || {}, appliedColumns, rejectedColumns)), []);\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources\n  };\n  return indicators;\n};\nconst getStatus = ({ label, column, type = DataMaskType.NativeFilters, rejectedColumns, appliedColumns }) => {\n  // a filter is only considered unset if it's value is null\n  const hasValue = label !== null;\n  const APPLIED_STATUS = type === DataMaskType.CrossFilters ?\n  IndicatorStatus.CrossFilterApplied :\n  IndicatorStatus.Applied;\n  if (!column && hasValue) {\n    // Filter without datasource\n    return APPLIED_STATUS;\n  }\n  if (column && rejectedColumns != null && rejectedColumns.has(column))\n  return IndicatorStatus.Incompatible;\n  if (column && appliedColumns != null && appliedColumns.has(column) && hasValue) {\n    return APPLIED_STATUS;\n  }\n  return IndicatorStatus.Unset;\n};\nconst defaultChartConfig = {};\nexport const selectChartCrossFilters = (dataMask, chartId, dashboardLayout, chartConfiguration = defaultChartConfig, appliedColumns, rejectedColumns, filterEmitter = false) => {\n  let crossFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DashboardCrossFilters)) {\n    crossFilterIndicators = Object.values(chartConfiguration).\n    filter((chartConfig) => {var _chartConfig$crossFil, _chartConfig$crossFil2;\n      const inScope = (_chartConfig$crossFil = chartConfig.crossFilters) == null ? void 0 : (_chartConfig$crossFil2 = _chartConfig$crossFil.chartsInScope) == null ? void 0 : _chartConfig$crossFil2.includes(chartId);\n      if (!filterEmitter && inScope) {\n        return true;\n      }\n      if (filterEmitter && !inScope) {\n        return true;\n      }\n      return false;\n    }).\n    map((chartConfig) => {\n      const filterIndicator = getCrossFilterIndicator(Number(chartConfig.id), dataMask[chartConfig.id], dashboardLayout);\n      const filterStatus = getStatus({\n        label: filterIndicator.value,\n        column: filterIndicator.column ?\n        getColumnLabel(filterIndicator.column) :\n        undefined,\n        type: DataMaskType.CrossFilters,\n        appliedColumns,\n        rejectedColumns\n      });\n      return { ...filterIndicator, status: filterStatus };\n    }).\n    filter((filter) => filter.status === IndicatorStatus.CrossFilterApplied);\n  }\n  return crossFilterIndicators;\n};\nconst cachedNativeIndicatorsForChart = {};\nconst cachedNativeFilterDataForChart = {};\nexport const selectNativeIndicatorsForChart = (nativeFilters, dataMask, chartId, chart, dashboardLayout, chartConfiguration = defaultChartConfig) => {\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (cachedNativeIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.nativeFilters) === nativeFilters &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dashboardLayout) === dashboardLayout &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.chartConfiguration) === chartConfiguration &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dataMask) === dataMask) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n  const nativeFilterIndicators = nativeFilters &&\n  Object.values(nativeFilters).\n  filter((nativeFilter) => {var _nativeFilter$chartsI;return nativeFilter.type === NativeFilterType.NativeFilter && ((_nativeFilter$chartsI =\n    nativeFilter.chartsInScope) == null ? void 0 : _nativeFilter$chartsI.includes(chartId));}).\n  map((nativeFilter) => {var _nativeFilter$targets, _nativeFilter$targets2, _nativeFilter$targets3, _dataMask$nativeFilte;\n    const column = (_nativeFilter$targets = nativeFilter.targets) == null ? void 0 : (_nativeFilter$targets2 = _nativeFilter$targets[0]) == null ? void 0 : (_nativeFilter$targets3 = _nativeFilter$targets2.column) == null ? void 0 : _nativeFilter$targets3.name;\n    const filterState = (_dataMask$nativeFilte = dataMask[nativeFilter.id]) == null ? void 0 : _dataMask$nativeFilte.filterState;\n    const label = extractLabel(filterState);\n    return {\n      column,\n      name: nativeFilter.name,\n      path: [nativeFilter.id],\n      status: getStatus({\n        label,\n        column,\n        rejectedColumns,\n        appliedColumns\n      }),\n      value: label\n    };\n  });\n  let crossFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DashboardCrossFilters)) {\n    crossFilterIndicators = selectChartCrossFilters(dataMask, chartId, dashboardLayout, chartConfiguration, appliedColumns, rejectedColumns);\n  }\n  const indicators = crossFilterIndicators.concat(nativeFilterIndicators);\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    dashboardLayout,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns\n  };\n  return indicators;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(IndicatorStatus, \"IndicatorStatus\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(TIME_GRANULARITY_FIELDS, \"TIME_GRANULARITY_FIELDS\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(extractLabel, \"extractLabel\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectIndicatorValue, \"selectIndicatorValue\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectIndicatorsForChartFromFilter, \"selectIndicatorsForChartFromFilter\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(getAppliedColumns, \"getAppliedColumns\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(getRejectedColumns, \"getRejectedColumns\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(getCrossFilterIndicator, \"getCrossFilterIndicator\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(cachedIndicatorsForChart, \"cachedIndicatorsForChart\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(cachedDashboardFilterDataForChart, \"cachedDashboardFilterDataForChart\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectIndicatorsForChart, \"selectIndicatorsForChart\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(getStatus, \"getStatus\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(defaultChartConfig, \"defaultChartConfig\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectChartCrossFilters, \"selectChartCrossFilters\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(cachedNativeIndicatorsForChart, \"cachedNativeIndicatorsForChart\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(cachedNativeFilterDataForChart, \"cachedNativeFilterDataForChart\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectNativeIndicatorsForChart, \"selectNativeIndicatorsForChart\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["DataMaskType","ensureIsArray","FeatureFlag","getColumnLabel","isFeatureEnabled","NativeFilterType","NO_TIME_RANGE","TIME_FILTER_MAP","getChartIdsInFilterScope","areObjectsEqual","IndicatorStatus","TIME_GRANULARITY_FIELDS","Set","Object","values","extractLabel","filter","_filter$label","label","includes","undefined","value","join","selectIndicatorValue","columnKey","datasource","columns","arrValues","Array","isArray","isDateFilter","length","has","timeGranularityMap","time_grain_sqla","granularity","reduce","map","key","selectIndicatorsForChartFromFilter","chartId","filterDataSource","appliedColumns","rejectedColumns","getStatus","column","Applied","Incompatible","Unset","keys","filterScope","scopes","name","labels","status","path","directPathToFilter","getAppliedColumns","chart","_chart$queriesRespons","_chart$queriesRespons2","queriesResponse","applied_filters","getRejectedColumns","_chart$queriesRespons3","_chart$queriesRespons4","rejected_filters","getCrossFilterIndicator","dataMask","dashboardLayout","_dataMask$extraFormDa","_filters$","_dashboardLayoutItem$","_dashboardLayoutItem$2","_dashboardLayoutItem$3","filterState","filters","extraFormData","filtersState","col","dashboardLayoutItem","find","layoutItem","_layoutItem$meta","meta","filterObject","sliceNameOverride","sliceName","parents","id","cachedIndicatorsForChart","cachedDashboardFilterDataForChart","selectIndicatorsForChart","datasources","matchingFilters","matchingDatasources","entries","datasourceId","cachedFilterData","indicators","acc","concat","sort","a","b","localeCompare","type","NativeFilters","hasValue","APPLIED_STATUS","CrossFilters","CrossFilterApplied","defaultChartConfig","selectChartCrossFilters","chartConfiguration","filterEmitter","crossFilterIndicators","DashboardCrossFilters","chartConfig","_chartConfig$crossFil","_chartConfig$crossFil2","inScope","crossFilters","chartsInScope","filterIndicator","Number","filterStatus","cachedNativeIndicatorsForChart","cachedNativeFilterDataForChart","selectNativeIndicatorsForChart","nativeFilters","nativeFilterIndicators","nativeFilter","_nativeFilter$chartsI","NativeFilter","_nativeFilter$targets","_nativeFilter$targets2","_nativeFilter$targets3","_dataMask$nativeFilte","targets","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  DataMask,\n  DataMaskStateWithId,\n  DataMaskType,\n  ensureIsArray,\n  FeatureFlag,\n  Filters,\n  FilterState,\n  getColumnLabel,\n  isFeatureEnabled,\n  NativeFilterType,\n  NO_TIME_RANGE,\n  QueryFormColumn,\n} from '@superset-ui/core';\nimport { TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport {\n  ChartConfiguration,\n  DashboardLayout,\n  Layout,\n} from 'src/dashboard/types';\nimport { areObjectsEqual } from 'src/reduxUtils';\n\nexport enum IndicatorStatus {\n  Unset = 'UNSET',\n  Applied = 'APPLIED',\n  Incompatible = 'INCOMPATIBLE',\n  CrossFilterApplied = 'CROSS_FILTER_APPLIED',\n}\n\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\n\n// As of 2020-09-28, the Dataset type in superset-ui is incorrect.\n// Should patch it here until the Dataset type is updated.\ntype Datasource = {\n  time_grain_sqla?: [string, string][];\n  granularity?: [string, string][];\n  verbose_map?: Record<string, string>;\n};\n\ntype Filter = {\n  chartId: number;\n  columns: { [key: string]: string | string[] };\n  scopes: { [key: string]: any };\n  labels: { [key: string]: string };\n  isDateFilter: boolean;\n  directPathToFilter: string[];\n  datasourceId: string;\n};\n\nexport const extractLabel = (filter?: FilterState): string | null => {\n  if (filter?.label && !filter?.label?.includes(undefined)) {\n    return filter.label;\n  }\n  if (filter?.value) {\n    return ensureIsArray(filter?.value).join(', ');\n  }\n  return null;\n};\n\nconst selectIndicatorValue = (\n  columnKey: string,\n  filter: Filter,\n  datasource: Datasource,\n): any => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n\n  if (\n    values == null ||\n    (filter.isDateFilter && values === NO_TIME_RANGE) ||\n    arrValues.length === 0\n  ) {\n    return [];\n  }\n\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = (\n      (columnKey === TIME_FILTER_MAP.time_grain_sqla\n        ? datasource.time_grain_sqla\n        : datasource.granularity) || []\n    ).reduce(\n      (map, [key, value]) => ({\n        ...map,\n        [key]: value,\n      }),\n      {},\n    );\n\n    return arrValues.map(value => timeGranularityMap[value] || value);\n  }\n\n  return arrValues;\n};\n\nconst selectIndicatorsForChartFromFilter = (\n  chartId: number,\n  filter: Filter,\n  filterDataSource: Datasource,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n): Indicator[] => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column: string, filter: Filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n      return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column)) return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n\n  return Object.keys(filter.columns)\n    .filter(column =>\n      getChartIdsInFilterScope({\n        filterScope: filter.scopes[column],\n      }).includes(chartId),\n    )\n    .map(column => ({\n      column,\n      name: filter.labels[column] || column,\n      value: selectIndicatorValue(column, filter, filterDataSource),\n      status: getStatus(column, filter),\n      path: filter.directPathToFilter,\n    }));\n};\n\nconst getAppliedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.applied_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n\nconst getRejectedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.rejected_filters || []).map((filter: any) =>\n      getColumnLabel(filter.column),\n    ),\n  );\n\nexport type Indicator = {\n  column?: QueryFormColumn;\n  name: string;\n  value?: any;\n  status?: IndicatorStatus;\n  path?: string[];\n};\n\nexport type CrossFilterIndicator = Indicator & { emitterId: number };\n\nexport const getCrossFilterIndicator = (\n  chartId: number,\n  dataMask: DataMask,\n  dashboardLayout: DashboardLayout,\n) => {\n  const filterState = dataMask?.filterState;\n  const filters = dataMask?.extraFormData?.filters;\n  const label = extractLabel(filterState);\n  const filtersState = filterState?.filters;\n  const column =\n    filters?.[0]?.col || (filtersState && Object.keys(filtersState)[0]);\n\n  const dashboardLayoutItem = Object.values(dashboardLayout).find(\n    layoutItem => layoutItem?.meta?.chartId === chartId,\n  );\n  const filterObject: Indicator = {\n    column,\n    name:\n      dashboardLayoutItem?.meta?.sliceNameOverride ||\n      dashboardLayoutItem?.meta?.sliceName ||\n      '',\n    path: [\n      ...(dashboardLayoutItem?.parents ?? []),\n      dashboardLayoutItem?.id || '',\n    ],\n    value: label,\n  };\n  return filterObject;\n};\n\nconst cachedIndicatorsForChart = {};\nconst cachedDashboardFilterDataForChart = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (\n  chartId: number,\n  filters: { [key: number]: Filter },\n  datasources: { [key: string]: Datasource },\n  chart: any,\n): Indicator[] => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter(\n    filter => filter.chartId !== chartId,\n  );\n  const matchingDatasources = Object.entries(datasources)\n    .filter(([key]) =>\n      matchingFilters.find(filter => filter.datasourceId === key),\n    )\n    .map(([, datasource]) => datasource);\n\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (\n    cachedIndicatorsForChart[chartId] &&\n    areObjectsEqual(cachedFilterData?.appliedColumns, appliedColumns) &&\n    areObjectsEqual(cachedFilterData?.rejectedColumns, rejectedColumns) &&\n    areObjectsEqual(cachedFilterData?.matchingFilters, matchingFilters) &&\n    areObjectsEqual(cachedFilterData?.matchingDatasources, matchingDatasources)\n  ) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce(\n    (acc, filter) =>\n      acc.concat(\n        selectIndicatorsForChartFromFilter(\n          chartId,\n          filter,\n          datasources[filter.datasourceId] || {},\n          appliedColumns,\n          rejectedColumns,\n        ),\n      ),\n    [] as Indicator[],\n  );\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources,\n  };\n  return indicators;\n};\n\nconst getStatus = ({\n  label,\n  column,\n  type = DataMaskType.NativeFilters,\n  rejectedColumns,\n  appliedColumns,\n}: {\n  label: string | null;\n  column?: string;\n  type?: DataMaskType;\n  rejectedColumns?: Set<string>;\n  appliedColumns?: Set<string>;\n}): IndicatorStatus => {\n  // a filter is only considered unset if it's value is null\n  const hasValue = label !== null;\n  const APPLIED_STATUS =\n    type === DataMaskType.CrossFilters\n      ? IndicatorStatus.CrossFilterApplied\n      : IndicatorStatus.Applied;\n  if (!column && hasValue) {\n    // Filter without datasource\n    return APPLIED_STATUS;\n  }\n  if (column && rejectedColumns?.has(column))\n    return IndicatorStatus.Incompatible;\n  if (column && appliedColumns?.has(column) && hasValue) {\n    return APPLIED_STATUS;\n  }\n  return IndicatorStatus.Unset;\n};\n\nconst defaultChartConfig = {};\nexport const selectChartCrossFilters = (\n  dataMask: DataMaskStateWithId,\n  chartId: number,\n  dashboardLayout: Layout,\n  chartConfiguration: ChartConfiguration = defaultChartConfig,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n  filterEmitter = false,\n): Indicator[] | CrossFilterIndicator[] => {\n  let crossFilterIndicators: any = [];\n  if (isFeatureEnabled(FeatureFlag.DashboardCrossFilters)) {\n    crossFilterIndicators = Object.values(chartConfiguration)\n      .filter(chartConfig => {\n        const inScope =\n          chartConfig.crossFilters?.chartsInScope?.includes(chartId);\n        if (!filterEmitter && inScope) {\n          return true;\n        }\n        if (filterEmitter && !inScope) {\n          return true;\n        }\n        return false;\n      })\n      .map(chartConfig => {\n        const filterIndicator = getCrossFilterIndicator(\n          Number(chartConfig.id),\n          dataMask[chartConfig.id],\n          dashboardLayout,\n        );\n        const filterStatus = getStatus({\n          label: filterIndicator.value,\n          column: filterIndicator.column\n            ? getColumnLabel(filterIndicator.column)\n            : undefined,\n          type: DataMaskType.CrossFilters,\n          appliedColumns,\n          rejectedColumns,\n        });\n\n        return { ...filterIndicator, status: filterStatus };\n      })\n      .filter(filter => filter.status === IndicatorStatus.CrossFilterApplied);\n  }\n\n  return crossFilterIndicators;\n};\n\nconst cachedNativeIndicatorsForChart = {};\nconst cachedNativeFilterDataForChart: any = {};\nexport const selectNativeIndicatorsForChart = (\n  nativeFilters: Filters,\n  dataMask: DataMaskStateWithId,\n  chartId: number,\n  chart: any,\n  dashboardLayout: Layout,\n  chartConfiguration: ChartConfiguration = defaultChartConfig,\n): Indicator[] => {\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (\n    cachedNativeIndicatorsForChart[chartId] &&\n    areObjectsEqual(cachedFilterData?.appliedColumns, appliedColumns) &&\n    areObjectsEqual(cachedFilterData?.rejectedColumns, rejectedColumns) &&\n    cachedFilterData?.nativeFilters === nativeFilters &&\n    cachedFilterData?.dashboardLayout === dashboardLayout &&\n    cachedFilterData?.chartConfiguration === chartConfiguration &&\n    cachedFilterData?.dataMask === dataMask\n  ) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n\n  const nativeFilterIndicators =\n    nativeFilters &&\n    Object.values(nativeFilters)\n      .filter(\n        nativeFilter =>\n          nativeFilter.type === NativeFilterType.NativeFilter &&\n          nativeFilter.chartsInScope?.includes(chartId),\n      )\n      .map(nativeFilter => {\n        const column = nativeFilter.targets?.[0]?.column?.name;\n        const filterState = dataMask[nativeFilter.id]?.filterState;\n        const label = extractLabel(filterState);\n        return {\n          column,\n          name: nativeFilter.name,\n          path: [nativeFilter.id],\n          status: getStatus({\n            label,\n            column,\n            rejectedColumns,\n            appliedColumns,\n          }),\n          value: label,\n        };\n      });\n\n  let crossFilterIndicators: any = [];\n  if (isFeatureEnabled(FeatureFlag.DashboardCrossFilters)) {\n    crossFilterIndicators = selectChartCrossFilters(\n      dataMask,\n      chartId,\n      dashboardLayout,\n      chartConfiguration,\n      appliedColumns,\n      rejectedColumns,\n    );\n  }\n  const indicators = crossFilterIndicators.concat(nativeFilterIndicators);\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    dashboardLayout,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns,\n  };\n  return indicators;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}