{"ast":null,"code":"import _isNumber from \"lodash/isNumber\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\nimport { DTTM_ALIAS } from '@superset-ui/core';\nimport { ForecastSeriesEnum } from '../types';\nimport { sanitizeHtml } from './series';\nconst seriesTypeRegex = new RegExp(`(.+)(${ForecastSeriesEnum.ForecastLower}|${ForecastSeriesEnum.ForecastTrend}|${ForecastSeriesEnum.ForecastUpper})$`);\nexport const extractForecastSeriesContext = (seriesName) => {\n  const name = seriesName;\n  const regexMatch = seriesTypeRegex.exec(name);\n  if (!regexMatch)\n  return { name, type: ForecastSeriesEnum.Observation };\n  return {\n    name: regexMatch[1],\n    type: regexMatch[2]\n  };\n};\nexport const extractForecastSeriesContexts = (seriesNames) => seriesNames.reduce((agg, name) => {\n  const context = extractForecastSeriesContext(name);\n  const currentContexts = agg[context.name] || [];\n  currentContexts.push(context.type);\n  return { ...agg, [context.name]: currentContexts };\n}, {});\nexport const extractForecastValuesFromTooltipParams = (params, isHorizontal = false) => {\n  const values = {};\n  params.forEach((param) => {\n    const { marker, seriesId, value } = param;\n    const context = extractForecastSeriesContext(seriesId);\n    const numericValue = isHorizontal ? value[0] : value[1];\n    if (_isNumber(numericValue)) {\n      if (!(context.name in values))\n      values[context.name] = {\n        marker: marker || ''\n      };\n      const forecastValues = values[context.name];\n      if (context.type === ForecastSeriesEnum.Observation)\n      forecastValues.observation = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastTrend)\n      forecastValues.forecastTrend = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastLower)\n      forecastValues.forecastLower = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastUpper)\n      forecastValues.forecastUpper = numericValue;\n    }\n  });\n  return values;\n};\nexport const formatForecastTooltipSeries = ({ seriesName, observation, forecastTrend, forecastLower, forecastUpper, marker, formatter }) => {\n  const name = `${marker}${sanitizeHtml(seriesName)}`;\n  let value = _isNumber(observation) ? formatter(observation) : '';\n  if (forecastTrend || forecastLower || forecastUpper) {\n    // forecast values take the form of \"20, y = 30 (10, 40)\"\n    // where the first part is the observation, the second part is the forecast trend\n    // and the third part is the lower and upper bounds\n    if (forecastTrend) {\n      if (value)\n      value += ', ';\n      value += `ŷ = ${formatter(forecastTrend)}`;\n    }\n    if (forecastLower && forecastUpper) {\n      if (value)\n      value += ' ';\n      // the lower bound needs to be added to the upper bound\n      value += `(${formatter(forecastLower)}, ${formatter(forecastLower + forecastUpper)})`;\n    }\n  }\n  return [name, value];\n};\nexport function rebaseForecastDatum(data, verboseMap = {}) {\n  const keys = data.length ? Object.keys(data[0]) : [];\n  return data.map((row) => {\n    const newRow = {};\n    keys.forEach((key) => {\n      const forecastContext = extractForecastSeriesContext(key);\n      const verboseKey = key !== DTTM_ALIAS && verboseMap[forecastContext.name] ?\n      `${verboseMap[forecastContext.name]}${forecastContext.type}` :\n      key;\n      // check if key is equal to lower confidence level. If so, extract it\n      // from the upper bound\n      const lowerForecastKey = `${forecastContext.name}${ForecastSeriesEnum.ForecastLower}`;\n      let value = row[key];\n      if (forecastContext.type === ForecastSeriesEnum.ForecastUpper &&\n      keys.includes(lowerForecastKey) &&\n      value !== null &&\n      row[lowerForecastKey] !== null) {\n        value -= row[lowerForecastKey];\n      }\n      newRow[verboseKey] = value;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return newRow;\n  });\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(seriesTypeRegex, \"seriesTypeRegex\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(extractForecastSeriesContext, \"extractForecastSeriesContext\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(extractForecastSeriesContexts, \"extractForecastSeriesContexts\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(extractForecastValuesFromTooltipParams, \"extractForecastValuesFromTooltipParams\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(formatForecastTooltipSeries, \"formatForecastTooltipSeries\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(rebaseForecastDatum, \"rebaseForecastDatum\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","DTTM_ALIAS","ForecastSeriesEnum","sanitizeHtml","seriesTypeRegex","RegExp","ForecastLower","ForecastTrend","ForecastUpper","extractForecastSeriesContext","seriesName","name","regexMatch","exec","type","Observation","extractForecastSeriesContexts","seriesNames","reduce","agg","context","currentContexts","push","extractForecastValuesFromTooltipParams","params","isHorizontal","values","forEach","param","marker","seriesId","value","numericValue","_isNumber","forecastValues","observation","forecastTrend","forecastLower","forecastUpper","formatForecastTooltipSeries","formatter","rebaseForecastDatum","data","verboseMap","keys","length","Object","map","row","newRow","key","forecastContext","verboseKey","lowerForecastKey","includes","reactHotLoader","register","leaveModule"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isNumber } from 'lodash';\nimport { DataRecord, DTTM_ALIAS, ValueFormatter } from '@superset-ui/core';\nimport { OptionName } from 'echarts/types/src/util/types';\nimport { TooltipMarker } from 'echarts/types/src/util/format';\nimport {\n  ForecastSeriesContext,\n  ForecastSeriesEnum,\n  ForecastValue,\n} from '../types';\nimport { sanitizeHtml } from './series';\n\nconst seriesTypeRegex = new RegExp(\n  `(.+)(${ForecastSeriesEnum.ForecastLower}|${ForecastSeriesEnum.ForecastTrend}|${ForecastSeriesEnum.ForecastUpper})$`,\n);\nexport const extractForecastSeriesContext = (\n  seriesName: OptionName,\n): ForecastSeriesContext => {\n  const name = seriesName as string;\n  const regexMatch = seriesTypeRegex.exec(name);\n  if (!regexMatch) return { name, type: ForecastSeriesEnum.Observation };\n  return {\n    name: regexMatch[1],\n    type: regexMatch[2] as ForecastSeriesEnum,\n  };\n};\n\nexport const extractForecastSeriesContexts = (\n  seriesNames: string[],\n): { [key: string]: ForecastSeriesEnum[] } =>\n  seriesNames.reduce(\n    (agg, name) => {\n      const context = extractForecastSeriesContext(name);\n      const currentContexts = agg[context.name] || [];\n      currentContexts.push(context.type);\n      return { ...agg, [context.name]: currentContexts };\n    },\n    {} as { [key: string]: ForecastSeriesEnum[] },\n  );\n\nexport const extractForecastValuesFromTooltipParams = (\n  params: any[],\n  isHorizontal = false,\n): Record<string, ForecastValue> => {\n  const values: Record<string, ForecastValue> = {};\n  params.forEach(param => {\n    const { marker, seriesId, value } = param;\n    const context = extractForecastSeriesContext(seriesId);\n    const numericValue = isHorizontal ? value[0] : value[1];\n    if (isNumber(numericValue)) {\n      if (!(context.name in values))\n        values[context.name] = {\n          marker: marker || '',\n        };\n      const forecastValues = values[context.name];\n      if (context.type === ForecastSeriesEnum.Observation)\n        forecastValues.observation = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastTrend)\n        forecastValues.forecastTrend = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastLower)\n        forecastValues.forecastLower = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastUpper)\n        forecastValues.forecastUpper = numericValue;\n    }\n  });\n  return values;\n};\n\nexport const formatForecastTooltipSeries = ({\n  seriesName,\n  observation,\n  forecastTrend,\n  forecastLower,\n  forecastUpper,\n  marker,\n  formatter,\n}: ForecastValue & {\n  seriesName: string;\n  marker: TooltipMarker;\n  formatter: ValueFormatter;\n}): string[] => {\n  const name = `${marker}${sanitizeHtml(seriesName)}`;\n  let value = isNumber(observation) ? formatter(observation) : '';\n  if (forecastTrend || forecastLower || forecastUpper) {\n    // forecast values take the form of \"20, y = 30 (10, 40)\"\n    // where the first part is the observation, the second part is the forecast trend\n    // and the third part is the lower and upper bounds\n    if (forecastTrend) {\n      if (value) value += ', ';\n      value += `ŷ = ${formatter(forecastTrend)}`;\n    }\n    if (forecastLower && forecastUpper) {\n      if (value) value += ' ';\n      // the lower bound needs to be added to the upper bound\n      value += `(${formatter(forecastLower)}, ${formatter(\n        forecastLower + forecastUpper,\n      )})`;\n    }\n  }\n  return [name, value];\n};\n\nexport function rebaseForecastDatum(\n  data: DataRecord[],\n  verboseMap: Record<string, string> = {},\n) {\n  const keys = data.length ? Object.keys(data[0]) : [];\n\n  return data.map(row => {\n    const newRow: DataRecord = {};\n    keys.forEach(key => {\n      const forecastContext = extractForecastSeriesContext(key);\n      const verboseKey =\n        key !== DTTM_ALIAS && verboseMap[forecastContext.name]\n          ? `${verboseMap[forecastContext.name]}${forecastContext.type}`\n          : key;\n\n      // check if key is equal to lower confidence level. If so, extract it\n      // from the upper bound\n      const lowerForecastKey = `${forecastContext.name}${ForecastSeriesEnum.ForecastLower}`;\n      let value = row[key] as number | null;\n      if (\n        forecastContext.type === ForecastSeriesEnum.ForecastUpper &&\n        keys.includes(lowerForecastKey) &&\n        value !== null &&\n        row[lowerForecastKey] !== null\n      ) {\n        value -= row[lowerForecastKey] as number;\n      }\n      newRow[verboseKey] = value;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return newRow;\n  });\n}\n"],"mappings":"yCAAA;;;;;;;;;;;;;;;;;GAAA,kBAAAA,WAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAD,WAAA,GAAAE,SAAA,CAAAF,WAAA,IAAAA,WAAA,CAAAG,MAAA,WAAAC,aAAA,UAAAH,oBAAA,mBAAAA,oBAAA,CAAAI,OAAA,CAAAC,SAAA,aAAAC,CAAA,UAAAA,CAAA;;AAmBA,SAAqBC,UAAU,QAAwB,mBAAmB;AAG1E,SAEEC,kBAAkB,QAEb,UAAU;AACjB,SAASC,YAAY,QAAQ,UAAU;AAEvC,MAAMC,eAAe,GAAG,IAAIC,MAAM,CAChC,QAAQH,kBAAkB,CAACI,aAAa,IAAIJ,kBAAkB,CAACK,aAAa,IAAIL,kBAAkB,CAACM,aAAa,IAAI,CACrH;AACD,OAAO,MAAMC,4BAA4B,GAAGA,CAC1CC,UAAsB,KACG;EACzB,MAAMC,IAAI,GAAGD,UAAoB;EACjC,MAAME,UAAU,GAAGR,eAAe,CAACS,IAAI,CAACF,IAAI,CAAC;EAC7C,IAAI,CAACC,UAAU;EAAE,OAAO,EAAED,IAAI,EAAEG,IAAI,EAAEZ,kBAAkB,CAACa,WAAW,EAAE;EACtE,OAAO;IACLJ,IAAI,EAAEC,UAAU,CAAC,CAAC,CAAC;IACnBE,IAAI,EAAEF,UAAU,CAAC,CAAC;GACnB;AACH,CAAC;AAED,OAAO,MAAMI,6BAA6B,GAAGA,CAC3CC,WAAqB,KAErBA,WAAW,CAACC,MAAM,CAChB,CAACC,GAAG,EAAER,IAAI,KAAI;EACZ,MAAMS,OAAO,GAAGX,4BAA4B,CAACE,IAAI,CAAC;EAClD,MAAMU,eAAe,GAAGF,GAAG,CAACC,OAAO,CAACT,IAAI,CAAC,IAAI,EAAE;EAC/CU,eAAe,CAACC,IAAI,CAACF,OAAO,CAACN,IAAI,CAAC;EAClC,OAAO,EAAE,GAAGK,GAAG,EAAE,CAACC,OAAO,CAACT,IAAI,GAAGU,eAAe,EAAE;AACpD,CAAC,EACD,EAA6C,CAC9C;AAEH,OAAO,MAAME,sCAAsC,GAAGA,CACpDC,MAAa,EACbC,YAAY,GAAG,KAAK,KACa;EACjC,MAAMC,MAAM,GAAkC,EAAE;EAChDF,MAAM,CAACG,OAAO,CAAC,CAAAC,KAAK,KAAG;IACrB,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAE,GAAGH,KAAK;IACzC,MAAMR,OAAO,GAAGX,4BAA4B,CAACqB,QAAQ,CAAC;IACtD,MAAME,YAAY,GAAGP,YAAY,GAAGM,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;IACvD,IAAIE,SAAA,CAASD,YAAY,CAAC,EAAE;MAC1B,IAAI,EAAEZ,OAAO,CAACT,IAAI,IAAIe,MAAM,CAAC;MAC3BA,MAAM,CAACN,OAAO,CAACT,IAAI,CAAC,GAAG;QACrBkB,MAAM,EAAEA,MAAM,IAAI;OACnB;MACH,MAAMK,cAAc,GAAGR,MAAM,CAACN,OAAO,CAACT,IAAI,CAAC;MAC3C,IAAIS,OAAO,CAACN,IAAI,KAAKZ,kBAAkB,CAACa,WAAW;MACjDmB,cAAc,CAACC,WAAW,GAAGH,YAAY;MAC3C,IAAIZ,OAAO,CAACN,IAAI,KAAKZ,kBAAkB,CAACK,aAAa;MACnD2B,cAAc,CAACE,aAAa,GAAGJ,YAAY;MAC7C,IAAIZ,OAAO,CAACN,IAAI,KAAKZ,kBAAkB,CAACI,aAAa;MACnD4B,cAAc,CAACG,aAAa,GAAGL,YAAY;MAC7C,IAAIZ,OAAO,CAACN,IAAI,KAAKZ,kBAAkB,CAACM,aAAa;MACnD0B,cAAc,CAACI,aAAa,GAAGN,YAAY;;EAEjD,CAAC,CAAC;EACF,OAAON,MAAM;AACf,CAAC;AAED,OAAO,MAAMa,2BAA2B,GAAGA,CAAC,EAC1C7B,UAAU,EACVyB,WAAW,EACXC,aAAa,EACbC,aAAa,EACbC,aAAa,EACbT,MAAM,EACNW,SAAS,EAKV,KAAc;EACb,MAAM7B,IAAI,GAAG,GAAGkB,MAAM,GAAG1B,YAAY,CAACO,UAAU,CAAC,EAAE;EACnD,IAAIqB,KAAK,GAAGE,SAAA,CAASE,WAAW,CAAC,GAAGK,SAAS,CAACL,WAAW,CAAC,GAAG,EAAE;EAC/D,IAAIC,aAAa,IAAIC,aAAa,IAAIC,aAAa,EAAE;IACnD;IACA;IACA;IACA,IAAIF,aAAa,EAAE;MACjB,IAAIL,KAAK;MAAEA,KAAK,IAAI,IAAI;MACxBA,KAAK,IAAI,OAAOS,SAAS,CAACJ,aAAa,CAAC,EAAE;;IAE5C,IAAIC,aAAa,IAAIC,aAAa,EAAE;MAClC,IAAIP,KAAK;MAAEA,KAAK,IAAI,GAAG;MACvB;MACAA,KAAK,IAAI,IAAIS,SAAS,CAACH,aAAa,CAAC,KAAKG,SAAS,CACjDH,aAAa,GAAGC,aAAa,CAC9B,GAAG;;;EAGR,OAAO,CAAC3B,IAAI,EAAEoB,KAAK,CAAC;AACtB,CAAC;AAED,OAAM,SAAUU,mBAAmBA,CACjCC,IAAkB,EAClBC,UAAA,GAAqC,EAAE;EAEvC,MAAMC,IAAI,GAAGF,IAAI,CAACG,MAAM,GAAGC,MAAM,CAACF,IAAI,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;EAEpD,OAAOA,IAAI,CAACK,GAAG,CAAC,CAAAC,GAAG,KAAG;IACpB,MAAMC,MAAM,GAAe,EAAE;IAC7BL,IAAI,CAACjB,OAAO,CAAC,CAAAuB,GAAG,KAAG;MACjB,MAAMC,eAAe,GAAG1C,4BAA4B,CAACyC,GAAG,CAAC;MACzD,MAAME,UAAU,GACdF,GAAG,KAAKjD,UAAU,IAAI0C,UAAU,CAACQ,eAAe,CAACxC,IAAI,CAAC;MAClD,GAAGgC,UAAU,CAACQ,eAAe,CAACxC,IAAI,CAAC,GAAGwC,eAAe,CAACrC,IAAI,EAAE;MAC5DoC,GAAG;MAET;MACA;MACA,MAAMG,gBAAgB,GAAG,GAAGF,eAAe,CAACxC,IAAI,GAAGT,kBAAkB,CAACI,aAAa,EAAE;MACrF,IAAIyB,KAAK,GAAGiB,GAAG,CAACE,GAAG,CAAkB;MACrC,IACEC,eAAe,CAACrC,IAAI,KAAKZ,kBAAkB,CAACM,aAAa;MACzDoC,IAAI,CAACU,QAAQ,CAACD,gBAAgB,CAAC;MAC/BtB,KAAK,KAAK,IAAI;MACdiB,GAAG,CAACK,gBAAgB,CAAC,KAAK,IAAI,EAC9B;QACAtB,KAAK,IAAIiB,GAAG,CAACK,gBAAgB,CAAW;;MAE1CJ,MAAM,CAACG,UAAU,CAAC,GAAGrB,KAAK;IAC5B,CAAC,CAAC;IACF;IACA,OAAOkB,MAAM;EACf,CAAC,CAAC;AACJ,CAAC,mBAAAM,cAAA,UAAA7D,oBAAA,mBAAAA,oBAAA,CAAAI,OAAA,GAAAH,SAAA,MAAA4D,cAAA,WAAAA,cAAA,CAAAC,QAAA,CA1HKpD,eAAe,kIAAAmD,cAAA,CAAAC,QAAA,CAGR/C,4BAA4B,+IAAA8C,cAAA,CAAAC,QAAA,CAY5BxC,6BAA6B,gJAAAuC,cAAA,CAAAC,QAAA,CAa7BjC,sCAAsC,yJAAAgC,cAAA,CAAAC,QAAA,CA4BtCjB,2BAA2B,8IAAAgB,cAAA,CAAAC,QAAA,CAkCxBf,mBAAmB,8JAAAgB,WAAA,UAAA/D,oBAAA,mBAAAA,oBAAA,CAAA+D,WAAA,GAAA9D,SAAA,CAAA8D,WAAA,IAAAA,WAAA,CAAA7D,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}