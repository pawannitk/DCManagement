{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};export const dashShaders = {\n  inject: {\n    'vs:#decl': \"\\nattribute vec2 instanceDashArrays;\\nattribute float instanceDashOffsets;\\nvarying vec2 vDashArray;\\nvarying float vDashOffset;\\n\",\n    'vs:#main-end': \"\\nvDashArray = instanceDashArrays;\\nvDashOffset = instanceDashOffsets / width.x;\\n\",\n    'fs:#decl': \"\\nuniform float dashAlignMode;\\nuniform float capType;\\nuniform bool dashGapPickable;\\nvarying vec2 vDashArray;\\nvarying float vDashOffset;\\n\\nfloat round(float x) {\\n  return floor(x + 0.5);\\n}\\n\",\n    'fs:#main-start': \"\\n  float solidLength = vDashArray.x;\\n  float gapLength = vDashArray.y;\\n  float unitLength = solidLength + gapLength;\\n\\n  float offset;\\n\\n  if (unitLength > 0.0) {\\n    if (dashAlignMode == 0.0) {\\n      offset = vDashOffset;\\n    } else {\\n      unitLength = vPathLength / round(vPathLength / unitLength);\\n      offset = solidLength / 2.0;\\n    }\\n\\n    float unitOffset = mod(vPathPosition.y + offset, unitLength);\\n\\n    if (gapLength > 0.0 && unitOffset > solidLength) {\\n      if (capType <= 0.5) {\\n        if (!(dashGapPickable && picking_uActive)) {\\n          discard;\\n        }\\n      } else {\\n        float distToEnd = length(vec2(\\n          min(unitOffset - solidLength, unitLength - unitOffset),\\n          vPathPosition.x\\n        ));\\n        if (distToEnd > 1.0) {\\n          if (!(dashGapPickable && picking_uActive)) {\\n            discard;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\"\n  }\n};\nexport const offsetShaders = {\n  inject: {\n    'vs:#decl': \"\\nattribute float instanceOffsets;\\n\",\n    'vs:DECKGL_FILTER_SIZE': \"\\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\\n  size *= offsetWidth;\\n\",\n    'vs:#main-end': \"\\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\\n  float offsetDir = sign(instanceOffsets);\\n  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\\n  vPathPosition.y *= offsetWidth;\\n  vPathLength *= offsetWidth;\\n\",\n    'fs:#main-start': \"\\n  float isInside;\\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\\n  if (isInside == 0.0) {\\n    discard;\\n  }\\n\"\n  }\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(dashShaders, \"dashShaders\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js\");reactHotLoader.register(offsetShaders, \"offsetShaders\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["dashShaders","inject","offsetShaders","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["../../../src/path-style/shaders.glsl.ts"],"sourcesContent":["export const dashShaders = {\n  inject: {\n    'vs:#decl': `\nattribute vec2 instanceDashArrays;\nattribute float instanceDashOffsets;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n`,\n\n    'vs:#main-end': `\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n`,\n\n    'fs:#decl': `\nuniform float dashAlignMode;\nuniform float capType;\nuniform bool dashGapPickable;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n`,\n\n    // if given position is in the gap part of the dashed line\n    // dashArray.x: solid stroke length, relative to width\n    // dashArray.y: gap length, relative to width\n    // alignMode:\n    // 0 - no adjustment\n    // o----     ----     ----     ---- o----     -o----     ----     o\n    // 1 - stretch to fit, draw half dash at each end for nicer joints\n    // o--    ----    ----    ----    --o--      --o--     ----     --o\n    'fs:#main-start': `\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  float offset;\n\n  if (unitLength > 0.0) {\n    if (dashAlignMode == 0.0) {\n      offset = vDashOffset;\n    } else {\n      unitLength = vPathLength / round(vPathLength / unitLength);\n      offset = solidLength / 2.0;\n    }\n\n    float unitOffset = mod(vPathPosition.y + offset, unitLength);\n\n    if (gapLength > 0.0 && unitOffset > solidLength) {\n      if (capType <= 0.5) {\n        if (!(dashGapPickable && picking_uActive)) {\n          discard;\n        }\n      } else {\n        // caps are rounded, test the distance to solid ends\n        float distToEnd = length(vec2(\n          min(unitOffset - solidLength, unitLength - unitOffset),\n          vPathPosition.x\n        ));\n        if (distToEnd > 1.0) {\n          if (!(dashGapPickable && picking_uActive)) {\n            discard;\n          }\n        }\n      }\n    }\n  }\n`\n  }\n};\n\nexport const offsetShaders = {\n  inject: {\n    'vs:#decl': `\nattribute float instanceOffsets;\n`,\n    'vs:DECKGL_FILTER_SIZE': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n`,\n    'vs:#main-end': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  float offsetDir = sign(instanceOffsets);\n  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\n  vPathPosition.y *= offsetWidth;\n  vPathLength *= offsetWidth;\n`,\n    'fs:#main-start': `\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n`\n  }\n};\n"],"mappings":"uSAAA,OAAO,MAAMA,WAAW,GAAG;EACzBC,MAAM,EAAE;IACN,gJADM;IAQN,oGARM;IAaN,kNAbM;IAiCN;EAjCM;AADiB,CAApB;AA0EP,OAAO,MAAMC,aAAa,GAAG;EAC3BD,MAAM,EAAE;IACN,kDADM;IAIN,8GAJM;IAQN,yQARM;IAeN;EAfM;AADmB,CAAtB,oBAAAE,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAC,SAAA,MAAAH,cAAA,WAAAA,cAAA,CAAAI,QAAA,CA1EMP,WAAW,mLAAAG,cAAA,CAAAI,QAAA,CA0EXL,aAAa,6MAAAM,WAAA,UAAAJ,oBAAA,mBAAAA,oBAAA,CAAAI,WAAA,GAAAF,SAAA,CAAAE,WAAA,IAAAA,WAAA,CAAAC,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}