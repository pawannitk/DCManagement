{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getMetricLabel, tooltipHtml } from '@superset-ui/core';\nimport { DEFAULT_FORM_DATA, DEFAULT_TREE_SERIES_OPTION } from './constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport function formatTooltip({ params, metricLabel }) {\n  const { value, treeAncestors } = params;\n  const treePath = (treeAncestors != null ? treeAncestors : []).\n  map((pathInfo) => (pathInfo == null ? void 0 : pathInfo.name) || '').\n  filter((path) => path !== '');\n  const row = value ? [metricLabel, String(value)] : [];\n  return tooltipHtml([row], treePath.join(' ▸ '));\n}\nexport default function transformProps(chartProps) {\n  const { width, height, formData, queriesData } = chartProps;\n  const refs = {};\n  const data = queriesData[0].data || [];\n  const { id, parent, name, metric = '', rootNodeId, layout, orient, symbol, symbolSize, roam, nodeLabelPosition, childLabelPosition, emphasis } = { ...DEFAULT_FORM_DATA, ...formData };\n  const metricLabel = getMetricLabel(metric);\n  const nameColumn = name || id;\n  function findNodeName(rootNodeId) {\n    let nodeName = '';\n    data.some((node) => {\n      if (node[id].toString() === rootNodeId) {\n        nodeName = node[nameColumn];\n        return true;\n      }\n      return false;\n    });\n    return nodeName;\n  }\n  function getTotalChildren(tree) {\n    let totalChildren = 0;\n    function traverse(tree) {\n      tree.children.forEach((node) => {\n        traverse(node);\n      });\n      totalChildren += 1;\n    }\n    traverse(tree);\n    return totalChildren;\n  }\n  function createTree(rootNodeId) {\n    const rootNodeName = findNodeName(rootNodeId);\n    const tree = { name: rootNodeName, children: [] };\n    const children = [];\n    const indexMap = {};\n    if (!rootNodeName) {\n      return tree;\n    }\n    // index indexMap with node ids\n    for (let i = 0; i < data.length; i += 1) {\n      const nodeId = data[i][id];\n      indexMap[nodeId] = i;\n      children[i] = [];\n    }\n    // generate tree\n    for (let i = 0; i < data.length; i += 1) {var _node$parent;\n      const node = data[i];\n      if (((_node$parent = node[parent]) == null ? void 0 : _node$parent.toString()) === rootNodeId) {var _tree$children;\n        (_tree$children = tree.children) == null ? void 0 : _tree$children.push({\n          name: node[nameColumn],\n          children: children[i],\n          value: node[metricLabel]\n        });\n      } else\n      {\n        const parentId = node[parent];\n        if (data[indexMap[parentId]]) {\n          const parentIndex = indexMap[parentId];\n          children[parentIndex].push({\n            name: node[nameColumn],\n            children: children[i],\n            value: node[metricLabel]\n          });\n        }\n      }\n    }\n    return tree;\n  }\n  let finalTree = {};\n  if (rootNodeId) {\n    finalTree = createTree(rootNodeId);\n  } else\n  {\n    /*\n      to select root node,\n      1.find parent nodes with only 1 child.\n      2.build tree for each such child nodes as root\n      3.select tree with most children\n    */\n    // create map of parent:children\n    const parentChildMap = {};\n    data.forEach((node) => {\n      const parentId = node[parent];\n      if (parentId in parentChildMap) {\n        parentChildMap[parentId].push({ id: node[id] });\n      } else\n      {\n        parentChildMap[parentId] = [{ id: node[id] }];\n      }\n    });\n    // for each parent node which has only 1 child,find tree and select node with max number of children.\n    let maxChildren = 0;\n    Object.keys(parentChildMap).forEach((key) => {\n      if (parentChildMap[key].length === 1) {\n        const tree = createTree(parentChildMap[key][0].id);\n        const totalChildren = getTotalChildren(tree);\n        if (totalChildren > maxChildren) {\n          maxChildren = totalChildren;\n          finalTree = tree;\n        }\n      }\n    });\n  }\n  const series = [\n  {\n    type: 'tree',\n    data: [finalTree],\n    label: {\n      ...DEFAULT_TREE_SERIES_OPTION.label,\n      position: nodeLabelPosition\n    },\n    emphasis: { focus: emphasis },\n    animation: DEFAULT_TREE_SERIES_OPTION.animation,\n    layout,\n    orient,\n    symbol,\n    roam,\n    symbolSize,\n    lineStyle: DEFAULT_TREE_SERIES_OPTION.lineStyle,\n    select: DEFAULT_TREE_SERIES_OPTION.select,\n    leaves: { label: { position: childLabelPosition } }\n  }];\n\n  const echartOptions = {\n    animationDuration: DEFAULT_TREE_SERIES_OPTION.animationDuration,\n    animationEasing: DEFAULT_TREE_SERIES_OPTION.animationEasing,\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: (params) => formatTooltip({\n        params,\n        metricLabel\n      })\n    }\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    refs\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(formatTooltip, \"formatTooltip\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Tree/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Tree/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["getMetricLabel","tooltipHtml","DEFAULT_FORM_DATA","DEFAULT_TREE_SERIES_OPTION","getDefaultTooltip","formatTooltip","params","metricLabel","value","treeAncestors","treePath","map","pathInfo","name","filter","path","row","String","join","transformProps","chartProps","width","height","formData","queriesData","refs","data","id","parent","metric","rootNodeId","layout","orient","symbol","symbolSize","roam","nodeLabelPosition","childLabelPosition","emphasis","nameColumn","findNodeName","nodeName","some","node","toString","getTotalChildren","tree","totalChildren","traverse","children","forEach","createTree","rootNodeName","indexMap","i","length","nodeId","_node$parent","_tree$children","push","parentId","parentIndex","finalTree","parentChildMap","maxChildren","Object","keys","key","series","type","label","position","focus","animation","lineStyle","select","leaves","echartOptions","animationDuration","animationEasing","tooltip","trigger","triggerOn","formatter","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Tree/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  getMetricLabel,\n  DataRecordValue,\n  tooltipHtml,\n} from '@superset-ui/core';\nimport { EChartsCoreOption, TreeSeriesOption } from 'echarts';\nimport {\n  TreeSeriesCallbackDataParams,\n  TreeSeriesNodeItemOption,\n} from 'echarts/types/src/chart/tree/TreeSeries';\nimport { OptionName } from 'echarts/types/src/util/types';\nimport {\n  EchartsTreeChartProps,\n  EchartsTreeFormData,\n  TreeDataRecord,\n  TreeTransformedProps,\n} from './types';\nimport { DEFAULT_FORM_DATA, DEFAULT_TREE_SERIES_OPTION } from './constants';\nimport { Refs } from '../types';\nimport { getDefaultTooltip } from '../utils/tooltip';\n\nexport function formatTooltip({\n  params,\n  metricLabel,\n}: {\n  params: TreeSeriesCallbackDataParams;\n  metricLabel: string;\n}): string {\n  const { value, treeAncestors } = params;\n  const treePath = (treeAncestors ?? [])\n    .map(pathInfo => pathInfo?.name || '')\n    .filter(path => path !== '');\n  const row = value ? [metricLabel, String(value)] : [];\n  return tooltipHtml([row], treePath.join(' ▸ '));\n}\n\nexport default function transformProps(\n  chartProps: EchartsTreeChartProps,\n): TreeTransformedProps {\n  const { width, height, formData, queriesData } = chartProps;\n  const refs: Refs = {};\n  const data: TreeDataRecord[] = queriesData[0].data || [];\n\n  const {\n    id,\n    parent,\n    name,\n    metric = '',\n    rootNodeId,\n    layout,\n    orient,\n    symbol,\n    symbolSize,\n    roam,\n    nodeLabelPosition,\n    childLabelPosition,\n    emphasis,\n  }: EchartsTreeFormData = { ...DEFAULT_FORM_DATA, ...formData };\n  const metricLabel = getMetricLabel(metric);\n\n  const nameColumn = name || id;\n\n  function findNodeName(rootNodeId: DataRecordValue): OptionName {\n    let nodeName: DataRecordValue = '';\n    data.some(node => {\n      if (node[id]!.toString() === rootNodeId) {\n        nodeName = node[nameColumn];\n        return true;\n      }\n      return false;\n    });\n    return nodeName;\n  }\n\n  function getTotalChildren(tree: TreeSeriesNodeItemOption) {\n    let totalChildren = 0;\n\n    function traverse(tree: TreeSeriesNodeItemOption) {\n      tree.children!.forEach(node => {\n        traverse(node);\n      });\n      totalChildren += 1;\n    }\n    traverse(tree);\n    return totalChildren;\n  }\n\n  function createTree(rootNodeId: DataRecordValue): TreeSeriesNodeItemOption {\n    const rootNodeName = findNodeName(rootNodeId);\n    const tree: TreeSeriesNodeItemOption = { name: rootNodeName, children: [] };\n    const children: TreeSeriesNodeItemOption[][] = [];\n    const indexMap: { [name: string]: number } = {};\n\n    if (!rootNodeName) {\n      return tree;\n    }\n\n    // index indexMap with node ids\n    for (let i = 0; i < data.length; i += 1) {\n      const nodeId = data[i][id] as number;\n      indexMap[nodeId] = i;\n      children[i] = [];\n    }\n\n    // generate tree\n    for (let i = 0; i < data.length; i += 1) {\n      const node = data[i];\n      if (node[parent]?.toString() === rootNodeId) {\n        tree.children?.push({\n          name: node[nameColumn],\n          children: children[i],\n          value: node[metricLabel],\n        });\n      } else {\n        const parentId = node[parent];\n        if (data[indexMap[parentId]]) {\n          const parentIndex = indexMap[parentId];\n          children[parentIndex].push({\n            name: node[nameColumn],\n            children: children[i],\n            value: node[metricLabel],\n          });\n        }\n      }\n    }\n\n    return tree;\n  }\n\n  let finalTree = {};\n\n  if (rootNodeId) {\n    finalTree = createTree(rootNodeId);\n  } else {\n    /*\n      to select root node,\n      1.find parent nodes with only 1 child.\n      2.build tree for each such child nodes as root\n      3.select tree with most children\n    */\n    // create map of parent:children\n    const parentChildMap: { [name: string]: { [name: string]: any } } = {};\n    data.forEach(node => {\n      const parentId = node[parent] as string;\n      if (parentId in parentChildMap) {\n        parentChildMap[parentId].push({ id: node[id] });\n      } else {\n        parentChildMap[parentId] = [{ id: node[id] }];\n      }\n    });\n\n    // for each parent node which has only 1 child,find tree and select node with max number of children.\n    let maxChildren = 0;\n    Object.keys(parentChildMap).forEach(key => {\n      if (parentChildMap[key].length === 1) {\n        const tree = createTree(parentChildMap[key][0].id);\n        const totalChildren = getTotalChildren(tree);\n        if (totalChildren > maxChildren) {\n          maxChildren = totalChildren;\n          finalTree = tree;\n        }\n      }\n    });\n  }\n\n  const series: TreeSeriesOption[] = [\n    {\n      type: 'tree',\n      data: [finalTree],\n      label: {\n        ...DEFAULT_TREE_SERIES_OPTION.label,\n        position: nodeLabelPosition,\n      },\n      emphasis: { focus: emphasis },\n      animation: DEFAULT_TREE_SERIES_OPTION.animation,\n      layout,\n      orient,\n      symbol,\n      roam,\n      symbolSize,\n      lineStyle: DEFAULT_TREE_SERIES_OPTION.lineStyle,\n      select: DEFAULT_TREE_SERIES_OPTION.select,\n      leaves: { label: { position: childLabelPosition } },\n    },\n  ];\n\n  const echartOptions: EChartsCoreOption = {\n    animationDuration: DEFAULT_TREE_SERIES_OPTION.animationDuration,\n    animationEasing: DEFAULT_TREE_SERIES_OPTION.animationEasing,\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: (params: any) =>\n        formatTooltip({\n          params,\n          metricLabel,\n        }),\n    },\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    refs,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}