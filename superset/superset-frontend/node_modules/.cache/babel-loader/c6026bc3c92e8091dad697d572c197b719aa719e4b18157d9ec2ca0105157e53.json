{"ast":null,"code":"import _invert from \"lodash/invert\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\nimport { AxisType, buildCustomFormatters, CategoricalColorNamespace, CurrencyFormatter, ensureIsArray, tooltipHtml, GenericDataType, getCustomFormatter, getMetricLabel, getNumberFormatter, getXAxisLabel, isDefined, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isPhysicalColumn, isTimeseriesAnnotationLayer, t, NumberFormats } from '@superset-ui/core';\nimport { extractExtraMetrics, getOriginalSeries, isDerivedSeries, getTimeOffset } from '@superset-ui/chart-controls';\nimport { OrientationType } from './types';\nimport { DEFAULT_FORM_DATA } from './constants';\nimport { ForecastSeriesEnum } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport { calculateLowerLogTick, dedupSeries, extractDataTotalValues, extractSeries, extractShowValueIndexes, getAxisType, getColtypesMapping, getLegendProps, getMinAndMaxFromBounds } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastSeriesContexts, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getBaselineSeriesForStream, getPadding, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from './transformers';\nimport { StackControlsValue, TIMEGRAIN_TO_TIMESTAMP, TIMESERIES_CONSTANTS } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getPercentFormatter, getTooltipTimeFormatter, getXAxisFormatter, getYAxisFormatter } from '../utils/formatters';\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, filterState, legendState, formData, hooks, queriesData, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  let focusedSeries = null;\n  const { verboseMap = {}, columnFormats = {}, currencyFormats = {} } = datasource;\n  const [queryData] = queriesData;\n  const { data = [], label_map = {} } = queryData;\n  const dataTypes = getColtypesMapping(queryData);\n  const annotationData = getAnnotationData(chartProps);\n  const { area, annotationLayers, colorScheme, contributionMode, forecastEnabled, groupby, legendOrientation, legendType, legendMargin, logAxis, markerEnabled, markerSize, metrics, minorSplitLine, minorTicks, onlyTotal, opacity, orientation, percentageThreshold, richTooltip, seriesType, showLegend, showValue, sliceId, sortSeriesType, sortSeriesAscending, timeGrainSqla, timeCompare, stack, tooltipTimeFormat, tooltipSortByMetric, truncateXAxis, truncateYAxis, xAxis: xAxisOrig, xAxisBounds, xAxisForceCategorical, xAxisLabelRotation, xAxisSortSeries, xAxisSortSeriesAscending, xAxisTimeFormat, xAxisTitle, xAxisTitleMargin, yAxisBounds, yAxisFormat, currencyFormat, yAxisTitle, yAxisTitleMargin, yAxisTitlePosition, zoomable } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const groupBy = ensureIsArray(groupby);\n  const labelMap = Object.entries(label_map).reduce((acc, entry) => {\n    if (entry[1].length > groupBy.length &&\n    Array.isArray(timeCompare) &&\n    timeCompare.includes(entry[1][0])) {\n      entry[1].shift();\n    }\n    return { ...acc, [entry[0]]: entry[1] };\n  }, {});\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  const rebasedData = rebaseForecastDatum(data, verboseMap);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedData, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel,\n    legendState\n  });\n  const extraMetricLabels = extractExtraMetrics(chartProps.rawFormData).map(getMetricLabel);\n  const isMultiSeries = groupBy.length || (metrics == null ? void 0 : metrics.length) > 1;\n  const [rawSeries, sortedTotalValues, minPositiveValue] = extractSeries(rebasedData, {\n    fillNeighborValue: stack && !forecastEnabled ? 0 : undefined,\n    xAxis: xAxisLabel,\n    extraMetricLabels,\n    stack,\n    totalStackedValues,\n    isHorizontal,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries: isMultiSeries ? xAxisSortSeries : undefined,\n    xAxisSortSeriesAscending: isMultiSeries ?\n    xAxisSortSeriesAscending :\n    undefined\n  });\n  const showValueIndexes = extractShowValueIndexes(rawSeries, {\n    stack,\n    onlyTotal,\n    isHorizontal,\n    legendState\n  });\n  const seriesContexts = extractForecastSeriesContexts(Object.values(rawSeries).map((series) => series.name));\n  const isAreaExpand = stack === StackControlsValue.Expand;\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series = [];\n  const forcePercentFormatter = Boolean(contributionMode || isAreaExpand);\n  const percentFormatter = forcePercentFormatter ?\n  getPercentFormatter(yAxisFormat) :\n  getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const defaultFormatter = currencyFormat != null && currencyFormat.symbol ?\n  new CurrencyFormatter({ d3Format: yAxisFormat, currency: currencyFormat }) :\n  getNumberFormatter(yAxisFormat);\n  const customFormatters = buildCustomFormatters(metrics, currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  const offsetLineWidths = {};\n  rawSeries.forEach((entry) => {var _getCustomFormatter, _labelMap$seriesName;\n    const derivedSeries = isDerivedSeries(entry, chartProps.rawFormData);\n    const lineStyle = {};\n    if (derivedSeries) {var _chartProps$rawFormDa3;\n      const offset = getTimeOffset(entry, ensureIsArray((_chartProps$rawFormDa3 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa3.time_compare));\n      if (!offsetLineWidths[offset]) {\n        offsetLineWidths[offset] = Object.keys(offsetLineWidths).length + 1;\n      }\n      lineStyle.type = 'dashed';\n      lineStyle.width = offsetLineWidths[offset];\n    }\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      connectNulls: derivedSeries,\n      filterState,\n      seriesContexts,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      legendState,\n      stack,\n      formatter: forcePercentFormatter ?\n      percentFormatter : (_getCustomFormatter =\n      getCustomFormatter(customFormatters, metrics, labelMap == null ? void 0 : (_labelMap$seriesName = labelMap[seriesName]) == null ? void 0 : _labelMap$seriesName[0])) != null ? _getCustomFormatter : defaultFormatter,\n      showValue,\n      onlyTotal,\n      totalStackedValues: sortedTotalValues,\n      showValueIndexes,\n      thresholdValues,\n      richTooltip,\n      sliceId,\n      isHorizontal,\n      lineStyle,\n      timeCompare: array\n    });\n    if (transformedSeries) {\n      if (stack === StackControlsValue.Stream) {\n        // bug in Echarts - `stackStrategy: 'all'` doesn't work with nulls, so we cast them to 0\n        series.push({\n          ...transformedSeries,\n          data: transformedSeries.data.map((row) => {var _row$;return [row[0], (_row$ = row[1]) != null ? _row$ : 0];})\n        });\n      } else\n      {\n        series.push(transformedSeries);\n      }\n    }\n  });\n  if (stack === StackControlsValue.Stream) {\n    const baselineSeries = getBaselineSeriesForStream(series.map((entry) => entry.data), seriesType);\n    series.unshift(baselineSeries);\n  }\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = series.findIndex(({ name }) => name === selectedValue);\n    return {\n      ...acc,\n      [index]: selectedValue\n    };\n  }, {});\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data, xAxisLabel, xAxisType, colorScale, sliceId));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data, annotationData, colorScale, sliceId));\n    }\n  });\n  // axis bounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n  // default to 0-100% range when doing row-level contribution chart\n  if ((contributionMode === 'row' || isAreaExpand) && stack) {\n    if (yAxisMin === undefined)\n    yAxisMin = 0;\n    if (yAxisMax === undefined)\n    yAxisMax = 1;\n  } else\n  if (logAxis &&\n  yAxisMin === undefined &&\n  minPositiveValue !== undefined) {\n    yAxisMin = calculateLowerLogTick(minPositiveValue);\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const { setDataMask = () => {}, setControlValue = () => {}, onContextMenu, onLegendStateChanged } = hooks;\n  const addYAxisLabelOffset = !!yAxisTitle;\n  const addXAxisLabelOffset = !!xAxisTitle;\n  const padding = getPadding(showLegend, legendOrientation, addYAxisLabelOffset, zoomable, legendMargin, addXAxisLabelOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin), isHorizontal);\n  const legendData = rawSeries.\n  filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n  ForecastSeriesEnum.Observation).\n  map((entry) => entry.name || '').\n  concat(extractAnnotationLabels(annotationLayers, annotationData));\n  let xAxis = {\n    type: xAxisType,\n    name: xAxisTitle,\n    nameGap: convertInteger(xAxisTitleMargin),\n    nameLocation: 'middle',\n    axisLabel: {\n      hideOverlap: true,\n      formatter: xAxisFormatter,\n      rotate: xAxisLabelRotation\n    },\n    minorTick: { show: minorTicks },\n    minInterval: xAxisType === AxisType.Time && timeGrainSqla ?\n    TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n    0,\n    ...getMinAndMaxFromBounds(xAxisType, truncateXAxis, xAxisMin, xAxisMax, seriesType)\n  };\n  let yAxis = {\n    ...defaultYAxis,\n    type: logAxis ? AxisType.Log : AxisType.Value,\n    min: yAxisMin,\n    max: yAxisMax,\n    minorTick: { show: minorTicks },\n    minorSplitLine: { show: minorSplitLine },\n    axisLabel: {\n      formatter: getYAxisFormatter(metrics, forcePercentFormatter, customFormatters, defaultFormatter, yAxisFormat)\n    },\n    scale: truncateYAxis,\n    name: yAxisTitle,\n    nameGap: convertInteger(yAxisTitleMargin),\n    nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end'\n  };\n  if (isHorizontal) {\n    [xAxis, yAxis] = [yAxis, xAxis];\n    [padding.bottom, padding.left] = [padding.left, padding.bottom];\n    yAxis.inverse = true;\n  }\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...padding\n    },\n    xAxis,\n    yAxis,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {var _getCustomFormatter2;\n        const [xIndex, yIndex] = isHorizontal ? [1, 0] : [0, 1];\n        const xValue = richTooltip ?\n        params[0].value[xIndex] :\n        params.value[xIndex];\n        const forecastValue = richTooltip ? params : [params];\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[yIndex] - a.data[yIndex]);\n        }\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue, isHorizontal);\n        const isForecast = Object.values(forecastValues).some((value) => value.forecastTrend || value.forecastLower || value.forecastUpper);\n        const formatter = forcePercentFormatter ?\n        percentFormatter : (_getCustomFormatter2 =\n        getCustomFormatter(customFormatters, metrics)) != null ? _getCustomFormatter2 : defaultFormatter;\n        const rows = [];\n        const total = Object.values(forecastValues).reduce((acc, value) => value.observation !== undefined ? acc + value.observation : acc, 0);\n        const showTotal = Boolean(isMultiSeries) && richTooltip && !isForecast;\n        const showPercentage = showTotal && !forcePercentFormatter;\n        const keys = Object.keys(forecastValues);\n        keys.forEach((key) => {\n          const value = forecastValues[key];\n          if (value.observation === 0 && stack) {\n            return;\n          }\n          const row = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter\n          });\n          if (showPercentage && value.observation !== undefined) {\n            row.push(percentFormatter.format(value.observation / (total || 1)));\n          }\n          rows.push(row);\n        });\n        if (stack) {\n          keys.reverse();\n          rows.reverse();\n        }\n        if (showTotal) {\n          const totalRow = ['Total', formatter.format(total)];\n          if (showPercentage) {\n            totalRow.push(percentFormatter.format(1));\n          }\n          rows.push(totalRow);\n        }\n        return tooltipHtml(rows, tooltipFormatter(xValue), keys.findIndex((key) => key === focusedSeries));\n      }\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable, legendState),\n      data: legendData\n    },\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          ...(stack ? { yAxisIndex: false } : {}),\n          title: {\n            zoom: t('zoom area'),\n            back: t('restore zoom')\n          }\n        }\n      }\n    },\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom,\n      yAxisIndex: isHorizontal ? 0 : undefined\n    },\n    {\n      type: 'inside',\n      yAxisIndex: 0,\n      zoomOnMouseWheel: false,\n      moveOnMouseWheel: true\n    },\n    {\n      type: 'inside',\n      xAxisIndex: 0,\n      zoomOnMouseWheel: false,\n      moveOnMouseWheel: true\n    }] :\n\n    []\n  };\n  const onFocusedSeries = (seriesName) => {\n    focusedSeries = seriesName;\n  };\n  return {\n    echartOptions,\n    emitCrossFilters,\n    formData,\n    groupby: groupBy,\n    height,\n    labelMap,\n    selectedValues,\n    setDataMask,\n    setControlValue,\n    width,\n    legendData,\n    onContextMenu,\n    onLegendStateChanged,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType\n    },\n    refs,\n    coltypeMapping: dataTypes\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(transformProps, \"transformProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","AxisType","buildCustomFormatters","CategoricalColorNamespace","CurrencyFormatter","ensureIsArray","tooltipHtml","GenericDataType","getCustomFormatter","getMetricLabel","getNumberFormatter","getXAxisLabel","isDefined","isEventAnnotationLayer","isFormulaAnnotationLayer","isIntervalAnnotationLayer","isPhysicalColumn","isTimeseriesAnnotationLayer","t","NumberFormats","extractExtraMetrics","getOriginalSeries","isDerivedSeries","getTimeOffset","OrientationType","DEFAULT_FORM_DATA","ForecastSeriesEnum","parseAxisBound","calculateLowerLogTick","dedupSeries","extractDataTotalValues","extractSeries","extractShowValueIndexes","getAxisType","getColtypesMapping","getLegendProps","getMinAndMaxFromBounds","extractAnnotationLabels","getAnnotationData","extractForecastSeriesContext","extractForecastSeriesContexts","extractForecastValuesFromTooltipParams","formatForecastTooltipSeries","rebaseForecastDatum","convertInteger","defaultGrid","defaultYAxis","getBaselineSeriesForStream","getPadding","transformEventAnnotation","transformFormulaAnnotation","transformIntervalAnnotation","transformSeries","transformTimeseriesAnnotation","StackControlsValue","TIMEGRAIN_TO_TIMESTAMP","TIMESERIES_CONSTANTS","getDefaultTooltip","getPercentFormatter","getTooltipTimeFormatter","getXAxisFormatter","getYAxisFormatter","transformProps","chartProps","_chartProps$rawFormDa","_dataTypes$xAxisLabel","_chartProps$rawFormDa2","width","height","filterState","legendState","formData","hooks","queriesData","datasource","theme","inContextMenu","emitCrossFilters","focusedSeries","verboseMap","columnFormats","currencyFormats","queryData","data","label_map","dataTypes","annotationData","area","annotationLayers","colorScheme","contributionMode","forecastEnabled","groupby","legendOrientation","legendType","legendMargin","logAxis","markerEnabled","markerSize","metrics","minorSplitLine","minorTicks","onlyTotal","opacity","orientation","percentageThreshold","richTooltip","seriesType","showLegend","showValue","sliceId","sortSeriesType","sortSeriesAscending","timeGrainSqla","timeCompare","stack","tooltipTimeFormat","tooltipSortByMetric","truncateXAxis","truncateYAxis","xAxis","xAxisOrig","xAxisBounds","xAxisForceCategorical","xAxisLabelRotation","xAxisSortSeries","xAxisSortSeriesAscending","xAxisTimeFormat","xAxisTitle","xAxisTitleMargin","yAxisBounds","yAxisFormat","currencyFormat","yAxisTitle","yAxisTitleMargin","yAxisTitlePosition","zoomable","refs","groupBy","labelMap","Object","entries","reduce","acc","entry","length","Array","isArray","includes","shift","colorScale","getScale","rebasedData","xAxisLabel","rawFormData","x_axis","isHorizontal","Horizontal","totalStackedValues","thresholdValues","xAxisCol","extraMetricLabels","map","isMultiSeries","rawSeries","sortedTotalValues","minPositiveValue","fillNeighborValue","showValueIndexes","seriesContexts","values","series","name","isAreaExpand","Expand","xAxisDataType","xAxisType","forcePercentFormatter","Boolean","percentFormatter","PERCENT_2_POINT","defaultFormatter","symbol","d3Format","currency","customFormatters","array","time_compare","inverted","_invert","offsetLineWidths","forEach","_getCustomFormatter","_labelMap$seriesName","derivedSeries","lineStyle","_chartProps$rawFormDa3","offset","keys","type","entryName","String","seriesName","colorScaleKey","transformedSeries","connectNulls","areaOpacity","formatter","Stream","push","row","_row$","baselineSeries","unshift","selectedValues","selectedValue","index","findIndex","filter","layer","show","xAxisMin","xAxisMax","yAxisMin","yAxisMax","tooltipFormatter","Temporal","xAxisFormatter","setDataMask","setControlValue","onContextMenu","onLegendStateChanged","addYAxisLabelOffset","addXAxisLabelOffset","padding","legendData","Observation","concat","nameGap","nameLocation","axisLabel","hideOverlap","rotate","minorTick","minInterval","Time","yAxis","Log","Value","min","max","scale","bottom","left","inverse","echartOptions","useUTC","grid","tooltip","trigger","params","_getCustomFormatter2","xIndex","yIndex","xValue","value","forecastValue","sort","b","forecastValues","isForecast","some","forecastTrend","forecastLower","forecastUpper","rows","total","observation","showTotal","showPercentage","key","format","reverse","totalRow","legend","toolbox","top","toolboxTop","right","toolboxRight","feature","dataZoom","yAxisIndex","title","zoom","back","start","dataZoomStart","end","dataZoomEnd","zoomBottom","zoomOnMouseWheel","moveOnMouseWheel","xAxisIndex","onFocusedSeries","xValueFormatter","label","coltypeMapping","reactHotLoader","register","leaveModule"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { invert } from 'lodash';\nimport {\n  AnnotationLayer,\n  AxisType,\n  buildCustomFormatters,\n  CategoricalColorNamespace,\n  CurrencyFormatter,\n  ensureIsArray,\n  tooltipHtml,\n  GenericDataType,\n  getCustomFormatter,\n  getMetricLabel,\n  getNumberFormatter,\n  getXAxisLabel,\n  isDefined,\n  isEventAnnotationLayer,\n  isFormulaAnnotationLayer,\n  isIntervalAnnotationLayer,\n  isPhysicalColumn,\n  isTimeseriesAnnotationLayer,\n  t,\n  TimeseriesChartDataResponseResult,\n  NumberFormats,\n} from '@superset-ui/core';\nimport {\n  extractExtraMetrics,\n  getOriginalSeries,\n  isDerivedSeries,\n  getTimeOffset,\n} from '@superset-ui/chart-controls';\nimport { EChartsCoreOption, SeriesOption } from 'echarts';\nimport { LineStyleOption } from 'echarts/types/src/util/types';\nimport {\n  EchartsTimeseriesChartProps,\n  EchartsTimeseriesFormData,\n  OrientationType,\n  TimeseriesChartTransformedProps,\n} from './types';\nimport { DEFAULT_FORM_DATA } from './constants';\nimport { ForecastSeriesEnum, ForecastValue, Refs } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport {\n  calculateLowerLogTick,\n  dedupSeries,\n  extractDataTotalValues,\n  extractSeries,\n  extractShowValueIndexes,\n  getAxisType,\n  getColtypesMapping,\n  getLegendProps,\n  getMinAndMaxFromBounds,\n} from '../utils/series';\nimport {\n  extractAnnotationLabels,\n  getAnnotationData,\n} from '../utils/annotation';\nimport {\n  extractForecastSeriesContext,\n  extractForecastSeriesContexts,\n  extractForecastValuesFromTooltipParams,\n  formatForecastTooltipSeries,\n  rebaseForecastDatum,\n} from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport {\n  getBaselineSeriesForStream,\n  getPadding,\n  transformEventAnnotation,\n  transformFormulaAnnotation,\n  transformIntervalAnnotation,\n  transformSeries,\n  transformTimeseriesAnnotation,\n} from './transformers';\nimport {\n  StackControlsValue,\n  TIMEGRAIN_TO_TIMESTAMP,\n  TIMESERIES_CONSTANTS,\n} from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport {\n  getPercentFormatter,\n  getTooltipTimeFormatter,\n  getXAxisFormatter,\n  getYAxisFormatter,\n} from '../utils/formatters';\n\nexport default function transformProps(\n  chartProps: EchartsTimeseriesChartProps,\n): TimeseriesChartTransformedProps {\n  const {\n    width,\n    height,\n    filterState,\n    legendState,\n    formData,\n    hooks,\n    queriesData,\n    datasource,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n\n  let focusedSeries: string | null = null;\n\n  const {\n    verboseMap = {},\n    columnFormats = {},\n    currencyFormats = {},\n  } = datasource;\n  const [queryData] = queriesData;\n  const { data = [], label_map = {} } =\n    queryData as TimeseriesChartDataResponseResult;\n\n  const dataTypes = getColtypesMapping(queryData);\n  const annotationData = getAnnotationData(chartProps);\n\n  const {\n    area,\n    annotationLayers,\n    colorScheme,\n    contributionMode,\n    forecastEnabled,\n    groupby,\n    legendOrientation,\n    legendType,\n    legendMargin,\n    logAxis,\n    markerEnabled,\n    markerSize,\n    metrics,\n    minorSplitLine,\n    minorTicks,\n    onlyTotal,\n    opacity,\n    orientation,\n    percentageThreshold,\n    richTooltip,\n    seriesType,\n    showLegend,\n    showValue,\n    sliceId,\n    sortSeriesType,\n    sortSeriesAscending,\n    timeGrainSqla,\n    timeCompare,\n    stack,\n    tooltipTimeFormat,\n    tooltipSortByMetric,\n    truncateXAxis,\n    truncateYAxis,\n    xAxis: xAxisOrig,\n    xAxisBounds,\n    xAxisForceCategorical,\n    xAxisLabelRotation,\n    xAxisSortSeries,\n    xAxisSortSeriesAscending,\n    xAxisTimeFormat,\n    xAxisTitle,\n    xAxisTitleMargin,\n    yAxisBounds,\n    yAxisFormat,\n    currencyFormat,\n    yAxisTitle,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    zoomable,\n  }: EchartsTimeseriesFormData = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs: Refs = {};\n  const groupBy = ensureIsArray(groupby);\n  const labelMap = Object.entries(label_map).reduce((acc, entry) => {\n    if (\n      entry[1].length > groupBy.length &&\n      Array.isArray(timeCompare) &&\n      timeCompare.includes(entry[1][0])\n    ) {\n      entry[1].shift();\n    }\n    return { ...acc, [entry[0]]: entry[1] };\n  }, {});\n\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme as string);\n  const rebasedData = rebaseForecastDatum(data, verboseMap);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData) as string;\n  if (\n    isPhysicalColumn(chartProps.rawFormData?.x_axis) &&\n    isDefined(verboseMap[xAxisLabel])\n  ) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(\n    rebasedData,\n    {\n      stack,\n      percentageThreshold,\n      xAxisCol: xAxisLabel,\n      legendState,\n    },\n  );\n  const extraMetricLabels = extractExtraMetrics(chartProps.rawFormData).map(\n    getMetricLabel,\n  );\n\n  const isMultiSeries = groupBy.length || metrics?.length > 1;\n\n  const [rawSeries, sortedTotalValues, minPositiveValue] = extractSeries(\n    rebasedData,\n    {\n      fillNeighborValue: stack && !forecastEnabled ? 0 : undefined,\n      xAxis: xAxisLabel,\n      extraMetricLabels,\n      stack,\n      totalStackedValues,\n      isHorizontal,\n      sortSeriesType,\n      sortSeriesAscending,\n      xAxisSortSeries: isMultiSeries ? xAxisSortSeries : undefined,\n      xAxisSortSeriesAscending: isMultiSeries\n        ? xAxisSortSeriesAscending\n        : undefined,\n    },\n  );\n  const showValueIndexes = extractShowValueIndexes(rawSeries, {\n    stack,\n    onlyTotal,\n    isHorizontal,\n    legendState,\n  });\n  const seriesContexts = extractForecastSeriesContexts(\n    Object.values(rawSeries).map(series => series.name as string),\n  );\n  const isAreaExpand = stack === StackControlsValue.Expand;\n  const xAxisDataType = dataTypes?.[xAxisLabel] ?? dataTypes?.[xAxisOrig];\n\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series: SeriesOption[] = [];\n\n  const forcePercentFormatter = Boolean(contributionMode || isAreaExpand);\n  const percentFormatter = forcePercentFormatter\n    ? getPercentFormatter(yAxisFormat)\n    : getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const defaultFormatter = currencyFormat?.symbol\n    ? new CurrencyFormatter({ d3Format: yAxisFormat, currency: currencyFormat })\n    : getNumberFormatter(yAxisFormat);\n  const customFormatters = buildCustomFormatters(\n    metrics,\n    currencyFormats,\n    columnFormats,\n    yAxisFormat,\n    currencyFormat,\n  );\n\n  const array = ensureIsArray(chartProps.rawFormData?.time_compare);\n  const inverted = invert(verboseMap);\n\n  const offsetLineWidths = {};\n\n  rawSeries.forEach(entry => {\n    const derivedSeries = isDerivedSeries(entry, chartProps.rawFormData);\n    const lineStyle: LineStyleOption = {};\n    if (derivedSeries) {\n      const offset = getTimeOffset(\n        entry,\n        ensureIsArray(chartProps.rawFormData?.time_compare),\n      )!;\n      if (!offsetLineWidths[offset]) {\n        offsetLineWidths[offset] = Object.keys(offsetLineWidths).length + 1;\n      }\n      lineStyle.type = 'dashed';\n      lineStyle.width = offsetLineWidths[offset];\n    }\n\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area,\n        connectNulls: derivedSeries,\n        filterState,\n        seriesContexts,\n        markerEnabled,\n        markerSize,\n        areaOpacity: opacity,\n        seriesType,\n        legendState,\n        stack,\n        formatter: forcePercentFormatter\n          ? percentFormatter\n          : getCustomFormatter(\n              customFormatters,\n              metrics,\n              labelMap?.[seriesName]?.[0],\n            ) ?? defaultFormatter,\n        showValue,\n        onlyTotal,\n        totalStackedValues: sortedTotalValues,\n        showValueIndexes,\n        thresholdValues,\n        richTooltip,\n        sliceId,\n        isHorizontal,\n        lineStyle,\n        timeCompare: array,\n      },\n    );\n    if (transformedSeries) {\n      if (stack === StackControlsValue.Stream) {\n        // bug in Echarts - `stackStrategy: 'all'` doesn't work with nulls, so we cast them to 0\n        series.push({\n          ...transformedSeries,\n          data: (transformedSeries.data as any).map(\n            (row: [string | number, number]) => [row[0], row[1] ?? 0],\n          ),\n        });\n      } else {\n        series.push(transformedSeries);\n      }\n    }\n  });\n\n  if (stack === StackControlsValue.Stream) {\n    const baselineSeries = getBaselineSeriesForStream(\n      series.map(entry => entry.data) as [string | number, number][][],\n      seriesType,\n    );\n\n    series.unshift(baselineSeries);\n  }\n  const selectedValues = (filterState.selectedValues || []).reduce(\n    (acc: Record<string, number>, selectedValue: string) => {\n      const index = series.findIndex(({ name }) => name === selectedValue);\n      return {\n        ...acc,\n        [index]: selectedValue,\n      };\n    },\n    {},\n  );\n\n  annotationLayers\n    .filter((layer: AnnotationLayer) => layer.show)\n    .forEach((layer: AnnotationLayer) => {\n      if (isFormulaAnnotationLayer(layer))\n        series.push(\n          transformFormulaAnnotation(\n            layer,\n            data,\n            xAxisLabel,\n            xAxisType,\n            colorScale,\n            sliceId,\n          ),\n        );\n      else if (isIntervalAnnotationLayer(layer)) {\n        series.push(\n          ...transformIntervalAnnotation(\n            layer,\n            data,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isEventAnnotationLayer(layer)) {\n        series.push(\n          ...transformEventAnnotation(\n            layer,\n            data,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isTimeseriesAnnotationLayer(layer)) {\n        series.push(\n          ...transformTimeseriesAnnotation(\n            layer,\n            markerSize,\n            data,\n            annotationData,\n            colorScale,\n            sliceId,\n          ),\n        );\n      }\n    });\n\n  // axis bounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n\n  // default to 0-100% range when doing row-level contribution chart\n  if ((contributionMode === 'row' || isAreaExpand) && stack) {\n    if (yAxisMin === undefined) yAxisMin = 0;\n    if (yAxisMax === undefined) yAxisMax = 1;\n  } else if (\n    logAxis &&\n    yAxisMin === undefined &&\n    minPositiveValue !== undefined\n  ) {\n    yAxisMin = calculateLowerLogTick(minPositiveValue);\n  }\n\n  const tooltipFormatter =\n    xAxisDataType === GenericDataType.Temporal\n      ? getTooltipTimeFormatter(tooltipTimeFormat)\n      : String;\n  const xAxisFormatter =\n    xAxisDataType === GenericDataType.Temporal\n      ? getXAxisFormatter(xAxisTimeFormat)\n      : String;\n\n  const {\n    setDataMask = () => {},\n    setControlValue = () => {},\n    onContextMenu,\n    onLegendStateChanged,\n  } = hooks;\n\n  const addYAxisLabelOffset = !!yAxisTitle;\n  const addXAxisLabelOffset = !!xAxisTitle;\n  const padding = getPadding(\n    showLegend,\n    legendOrientation,\n    addYAxisLabelOffset,\n    zoomable,\n    legendMargin,\n    addXAxisLabelOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n    isHorizontal,\n  );\n\n  const legendData = rawSeries\n    .filter(\n      entry =>\n        extractForecastSeriesContext(entry.name || '').type ===\n        ForecastSeriesEnum.Observation,\n    )\n    .map(entry => entry.name || '')\n    .concat(extractAnnotationLabels(annotationLayers, annotationData));\n\n  let xAxis: any = {\n    type: xAxisType,\n    name: xAxisTitle,\n    nameGap: convertInteger(xAxisTitleMargin),\n    nameLocation: 'middle',\n    axisLabel: {\n      hideOverlap: true,\n      formatter: xAxisFormatter,\n      rotate: xAxisLabelRotation,\n    },\n    minorTick: { show: minorTicks },\n    minInterval:\n      xAxisType === AxisType.Time && timeGrainSqla\n        ? TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla]\n        : 0,\n    ...getMinAndMaxFromBounds(\n      xAxisType,\n      truncateXAxis,\n      xAxisMin,\n      xAxisMax,\n      seriesType,\n    ),\n  };\n\n  let yAxis: any = {\n    ...defaultYAxis,\n    type: logAxis ? AxisType.Log : AxisType.Value,\n    min: yAxisMin,\n    max: yAxisMax,\n    minorTick: { show: minorTicks },\n    minorSplitLine: { show: minorSplitLine },\n    axisLabel: {\n      formatter: getYAxisFormatter(\n        metrics,\n        forcePercentFormatter,\n        customFormatters,\n        defaultFormatter,\n        yAxisFormat,\n      ),\n    },\n    scale: truncateYAxis,\n    name: yAxisTitle,\n    nameGap: convertInteger(yAxisTitleMargin),\n    nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n  };\n\n  if (isHorizontal) {\n    [xAxis, yAxis] = [yAxis, xAxis];\n    [padding.bottom, padding.left] = [padding.left, padding.bottom];\n    yAxis.inverse = true;\n  }\n\n  const echartOptions: EChartsCoreOption = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...padding,\n    },\n    xAxis,\n    yAxis,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params: any) => {\n        const [xIndex, yIndex] = isHorizontal ? [1, 0] : [0, 1];\n        const xValue: number = richTooltip\n          ? params[0].value[xIndex]\n          : params.value[xIndex];\n        const forecastValue: any[] = richTooltip ? params : [params];\n\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[yIndex] - a.data[yIndex]);\n        }\n\n        const forecastValues: Record<string, ForecastValue> =\n          extractForecastValuesFromTooltipParams(forecastValue, isHorizontal);\n\n        const isForecast = Object.values(forecastValues).some(\n          value =>\n            value.forecastTrend || value.forecastLower || value.forecastUpper,\n        );\n\n        const formatter = forcePercentFormatter\n          ? percentFormatter\n          : getCustomFormatter(customFormatters, metrics) ?? defaultFormatter;\n\n        const rows: string[][] = [];\n        const total = Object.values(forecastValues).reduce(\n          (acc, value) =>\n            value.observation !== undefined ? acc + value.observation : acc,\n          0,\n        );\n        const showTotal = Boolean(isMultiSeries) && richTooltip && !isForecast;\n        const showPercentage = showTotal && !forcePercentFormatter;\n        const keys = Object.keys(forecastValues);\n        keys.forEach(key => {\n          const value = forecastValues[key];\n          if (value.observation === 0 && stack) {\n            return;\n          }\n          const row = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter,\n          });\n          if (showPercentage && value.observation !== undefined) {\n            row.push(percentFormatter.format(value.observation / (total || 1)));\n          }\n          rows.push(row);\n        });\n        if (stack) {\n          keys.reverse();\n          rows.reverse();\n        }\n        if (showTotal) {\n          const totalRow = ['Total', formatter.format(total)];\n          if (showPercentage) {\n            totalRow.push(percentFormatter.format(1));\n          }\n          rows.push(totalRow);\n        }\n        return tooltipHtml(\n          rows,\n          tooltipFormatter(xValue),\n          keys.findIndex(key => key === focusedSeries),\n        );\n      },\n    },\n    legend: {\n      ...getLegendProps(\n        legendType,\n        legendOrientation,\n        showLegend,\n        theme,\n        zoomable,\n        legendState,\n      ),\n      data: legendData as string[],\n    },\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          ...(stack ? { yAxisIndex: false } : {}), // disable y-axis zoom for stacked charts\n          title: {\n            zoom: t('zoom area'),\n            back: t('restore zoom'),\n          },\n        },\n      },\n    },\n    dataZoom: zoomable\n      ? [\n          {\n            type: 'slider',\n            start: TIMESERIES_CONSTANTS.dataZoomStart,\n            end: TIMESERIES_CONSTANTS.dataZoomEnd,\n            bottom: TIMESERIES_CONSTANTS.zoomBottom,\n            yAxisIndex: isHorizontal ? 0 : undefined,\n          },\n          {\n            type: 'inside',\n            yAxisIndex: 0,\n            zoomOnMouseWheel: false,\n            moveOnMouseWheel: true,\n          },\n          {\n            type: 'inside',\n            xAxisIndex: 0,\n            zoomOnMouseWheel: false,\n            moveOnMouseWheel: true,\n          },\n        ]\n      : [],\n  };\n\n  const onFocusedSeries = (seriesName: string | null) => {\n    focusedSeries = seriesName;\n  };\n\n  return {\n    echartOptions,\n    emitCrossFilters,\n    formData,\n    groupby: groupBy,\n    height,\n    labelMap,\n    selectedValues,\n    setDataMask,\n    setControlValue,\n    width,\n    legendData,\n    onContextMenu,\n    onLegendStateChanged,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType,\n    },\n    refs,\n    coltypeMapping: dataTypes,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}