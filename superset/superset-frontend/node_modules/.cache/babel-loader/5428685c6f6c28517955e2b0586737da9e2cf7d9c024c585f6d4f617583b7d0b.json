{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { log } from '@deck.gl/core';\nimport { Texture2D } from '@luma.gl/core';\nimport { equals } from '@math.gl/core';\nimport MaskPass from './mask-pass';\nimport { joinLayerBounds, getRenderBounds, makeViewport } from '../utils/projection-utils';\nexport default class MaskEffect {\n  constructor() {\n    _defineProperty(this, \"id\", 'mask-effect');\n\n    _defineProperty(this, \"props\", null);\n\n    _defineProperty(this, \"useInPicking\", true);\n\n    _defineProperty(this, \"order\", 0);\n\n    _defineProperty(this, \"dummyMaskMap\", void 0);\n\n    _defineProperty(this, \"channels\", []);\n\n    _defineProperty(this, \"masks\", null);\n\n    _defineProperty(this, \"maskPass\", void 0);\n\n    _defineProperty(this, \"maskMap\", void 0);\n\n    _defineProperty(this, \"lastViewport\", void 0);\n  }\n\n  preRender(gl, {\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views,\n    isPicking\n  }) {\n    let didRender = false;\n\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    if (isPicking) {\n      return {\n        didRender\n      };\n    }\n\n    const maskLayers = layers.filter((l) => l.props.visible && l.props.operation.includes('mask'));\n\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {\n        didRender\n      };\n    }\n\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {\n        id: 'default-mask'\n      });\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    const channelMap = this._sortMaskChannels(maskLayers);\n\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {\n        didRender\n      };\n    }\n\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n\n      didRender || (didRender = result);\n    }\n\n    return {\n      didRender\n    };\n  }\n\n  _renderChannel(channelInfo, {\n    layerFilter,\n    onViewportActive,\n    views,\n    viewport,\n    viewportChanged\n  }) {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n\n    const maskChanged = channelInfo === oldChannelInfo || channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i) => layer !== oldChannelInfo.layers[i] || layer.props.transitions) || channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      this.lastViewport = viewport;\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        const {\n          maskPass,\n          maskMap\n        } = this;\n        const maskViewport = layerBounds && makeViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height,\n          border: 1\n        });\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n        didRender = true;\n      }\n    }\n\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n    return didRender;\n  }\n\n  _sortMaskChannels(maskLayers) {\n    const channelMap = {};\n    let channelCount = 0;\n\n    for (const layer of maskLayers) {\n      const {\n        id\n      } = layer.root;\n      let channelInfo = channelMap[id];\n\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue;\n        }\n\n        channelInfo = {\n          id,\n          index: this.channels.findIndex((c) => (c === null || c === void 0 ? void 0 : c.id) === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex((c) => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n\n    return channelMap;\n  }\n\n  getModuleParameters() {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup() {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(MaskEffect, \"MaskEffect\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/mask/mask-effect.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["log","Texture2D","equals","MaskPass","joinLayerBounds","getRenderBounds","makeViewport","MaskEffect","constructor","_defineProperty","preRender","gl","layers","layerFilter","viewports","onViewportActive","views","isPicking","didRender","dummyMaskMap","width","height","maskLayers","filter","l","props","visible","operation","includes","length","masks","channels","maskPass","id","maskMap","channelMap","_sortMaskChannels","viewport","viewportChanged","lastViewport","resolution","undefined","warn","maskId","result","_renderChannel","channelInfo","oldChannelInfo","index","maskChanged","some","layer","i","transitions","layerBounds","b","bounds","maskBounds","maskViewport","border","getBounds","render","pass","channel","moduleParameters","devicePixelRatio","coordinateOrigin","coordinateSystem","channelCount","root","findIndex","c","push","getModuleParameters","maskChannels","cleanup","delete","__reactstandin__regenerateByEval","key","code","eval","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["../../../src/mask/mask-effect.ts"],"sourcesContent":["import {Layer, Viewport, Effect, PreRenderOptions, CoordinateSystem, log} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from './mask-pass';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\n// import {debugFBO} from '../utils/debug';\n\ntype Mask = {\n  /** The channel index */\n  index: number;\n  bounds: Bounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: number;\n  layers: Layer[];\n  bounds: Bounds | null;\n  maskBounds: Bounds;\n  layerBounds: Bounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\nexport type MaskPreRenderStats = {\n  didRender: boolean;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n  order = 0;\n\n  private dummyMaskMap?: Texture2D;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views, isPicking}: PreRenderOptions\n  ): MaskPreRenderStats {\n    let didRender = false;\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return {didRender};\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {didRender};\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {didRender};\n    }\n\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender ||= result;\n    }\n\n    // debugFBO(this.maskMap, {opaque: true});\n    return {didRender};\n  }\n\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ): boolean {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      channelInfo.layers.length !== oldChannelInfo.layers.length ||\n      channelInfo.layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a mask layer,\n          // for example getRadius+updateTriggers, radiusScale, modelMatrix\n          layer !== oldChannelInfo.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions\n      ) ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport =\n          layerBounds &&\n          makeViewport({\n            bounds: channelInfo.bounds!,\n            viewport,\n            width: maskMap.width,\n            height: maskMap.height,\n            border: 1\n          });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n\n        didRender = true;\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n\n    return didRender;\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters(): {\n    maskMap: Texture2D;\n    maskChannels: Record<string, Mask> | null;\n  } {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}