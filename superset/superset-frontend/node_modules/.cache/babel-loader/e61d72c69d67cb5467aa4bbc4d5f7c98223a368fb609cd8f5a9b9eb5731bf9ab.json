{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport LayersPass from './layers-pass';\nimport { withParameters } from '@luma.gl/core';\nimport log from '../utils/log';\nconst PICKING_PARAMETERS = {\n  blendFunc: [1, 0, 32771, 0],\n  blendEquation: 32774\n};\nexport default class PickLayersPass extends LayersPass {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"pickZ\", void 0);\n\n    _defineProperty(this, \"_colorEncoderState\", null);\n  }\n\n  render(props) {\n    if ('pickingFBO' in props) {\n      return this._drawPickingBuffer(props);\n    }\n\n    return super.render(props);\n  }\n\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {\n      x,\n      y,\n      width,\n      height\n    },\n    cullRect,\n    effects,\n    pass = 'picking',\n    pickZ,\n    moduleParameters\n  }) {\n    const gl = this.gl;\n    this.pickZ = pickZ;\n\n    const colorEncoderState = this._resetColorEncoder(pickZ);\n\n    const renderStatus = withParameters(gl, {\n      scissorTest: true,\n      scissor: [x, y, width, height],\n      clearColor: [0, 0, 0, 0],\n      depthMask: true,\n      depthTest: true,\n      depthRange: [0, 1],\n      colorMask: [true, true, true, true],\n      ...PICKING_PARAMETERS,\n      blend: !pickZ\n    }, () => super.render({\n      target: pickingFBO,\n      layers,\n      layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      cullRect,\n      effects: effects === null || effects === void 0 ? void 0 : effects.filter((e) => e.useInPicking),\n      pass,\n      isPicking: true,\n      moduleParameters\n    }));\n    this._colorEncoderState = null;\n    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);\n    return {\n      decodePickingColor,\n      stats: renderStatus\n    };\n  }\n\n  shouldDrawLayer(layer) {\n    const {\n      pickable,\n      operation\n    } = layer.props;\n    return pickable && operation.includes('draw') || operation.includes('terrain');\n  }\n\n  getModuleParameters() {\n    return {\n      pickingActive: 1,\n      pickingAttribute: this.pickZ,\n      lightSources: {}\n    };\n  }\n\n  getLayerParameters(layer, layerIndex, viewport) {\n    const pickParameters = { ...layer.props.parameters\n    };\n    const {\n      pickable,\n      operation\n    } = layer.props;\n\n    if (!this._colorEncoderState) {\n      pickParameters.blend = false;\n    } else if (pickable && operation.includes('draw')) {\n      Object.assign(pickParameters, PICKING_PARAMETERS);\n      pickParameters.blend = true;\n      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);\n    }\n\n    if (operation.includes('terrain')) {\n      pickParameters.blend = false;\n    }\n\n    return pickParameters;\n  }\n\n  _resetColorEncoder(pickZ) {\n    this._colorEncoderState = pickZ ? null : {\n      byLayer: new Map(),\n      byAlpha: []\n    };\n    return this._colorEncoderState;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\nfunction encodeColor(encoded, layer, viewport) {\n  const {\n    byLayer,\n    byAlpha\n  } = encoded;\n  let a;\n  let entry = byLayer.get(layer);\n\n  if (entry) {\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n\n    if (a <= 255) {\n      entry = {\n        a,\n        layer,\n        viewports: [viewport]\n      };\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n\n  return [0, 0, 0, a / 255];\n}\n\nfunction decodeColor(encoded, pickedColor) {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return entry && {\n    pickedLayer: entry.layer,\n    pickedViewports: entry.viewports,\n    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(PICKING_PARAMETERS, \"PICKING_PARAMETERS\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js\");reactHotLoader.register(PickLayersPass, \"PickLayersPass\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js\");reactHotLoader.register(encodeColor, \"encodeColor\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js\");reactHotLoader.register(decodeColor, \"decodeColor\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["LayersPass","withParameters","log","PICKING_PARAMETERS","blendFunc","blendEquation","PickLayersPass","constructor","args","_defineProperty","render","props","_drawPickingBuffer","layers","layerFilter","views","viewports","onViewportActive","pickingFBO","deviceRect","x","y","width","height","cullRect","effects","pass","pickZ","moduleParameters","gl","colorEncoderState","_resetColorEncoder","renderStatus","scissorTest","scissor","clearColor","depthMask","depthTest","depthRange","colorMask","blend","target","filter","e","useInPicking","isPicking","_colorEncoderState","decodePickingColor","decodeColor","bind","stats","shouldDrawLayer","layer","pickable","operation","includes","getModuleParameters","pickingActive","pickingAttribute","lightSources","getLayerParameters","layerIndex","viewport","pickParameters","parameters","Object","assign","blendColor","encodeColor","byLayer","Map","byAlpha","__reactstandin__regenerateByEval","key","code","eval","encoded","a","entry","get","push","size","set","warn","pickedColor","pickedLayer","pickedViewports","pickedObjectIndex","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["../../../src/passes/pick-layers-pass.ts"],"sourcesContent":["import LayersPass, {LayersPassRenderOptions, RenderStats, Rect} from './layers-pass';\nimport {withParameters} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport log from '../utils/log';\n\nimport type {Framebuffer} from '@luma.gl/core';\nimport type Viewport from '../viewports/viewport';\nimport type Layer from '../lib/layer';\n\nconst PICKING_PARAMETERS = {\n  blendFunc: [GL.ONE, GL.ZERO, GL.CONSTANT_ALPHA, GL.ZERO],\n  blendEquation: GL.FUNC_ADD\n};\n\ntype PickLayersPassRenderOptions = LayersPassRenderOptions & {\n  pickingFBO: Framebuffer;\n  deviceRect: Rect;\n  pickZ: boolean;\n};\n\ntype EncodedPickingColors = {\n  a: number;\n  layer: Layer;\n  viewports: Viewport[];\n};\n\nexport type PickingColorDecoder = (pickedColor: number[] | Uint8Array) =>\n  | {\n      pickedLayer: Layer;\n      pickedViewports: Viewport[];\n      pickedObjectIndex: number;\n    }\n  | undefined;\n\nexport default class PickLayersPass extends LayersPass {\n  private pickZ?: boolean;\n  private _colorEncoderState: {\n    byLayer: Map<Layer, EncodedPickingColors>;\n    byAlpha: EncodedPickingColors[];\n  } | null = null;\n\n  render(props: LayersPassRenderOptions | PickLayersPassRenderOptions) {\n    if ('pickingFBO' in props) {\n      // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n      return this._drawPickingBuffer(props);\n    }\n    // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n    return super.render(props);\n  }\n\n  // Private\n  // Draws list of layers and viewports into the picking buffer\n  // Note: does not sample the buffer, that has to be done by the caller\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {x, y, width, height},\n    cullRect,\n    effects,\n    pass = 'picking',\n    pickZ,\n    moduleParameters\n  }: PickLayersPassRenderOptions): {\n    decodePickingColor: PickingColorDecoder | null;\n    stats: RenderStats;\n  } {\n    const gl = this.gl;\n    this.pickZ = pickZ;\n    const colorEncoderState = this._resetColorEncoder(pickZ);\n\n    // Make sure we clear scissor test and fbo bindings in case of exceptions\n    // We are only interested in one pixel, no need to render anything else\n    // Note that the callback here is called synchronously.\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    const renderStatus = withParameters(\n      gl,\n      {\n        scissorTest: true,\n        scissor: [x, y, width, height],\n        clearColor: [0, 0, 0, 0],\n        // When used as Mapbox custom layer, the context state may be dirty\n        // TODO - Remove when mapbox fixes this issue\n        // https://github.com/mapbox/mapbox-gl-js/issues/7801\n        depthMask: true,\n        depthTest: true,\n        depthRange: [0, 1],\n        colorMask: [true, true, true, true],\n        // Blending\n        ...PICKING_PARAMETERS,\n        blend: !pickZ\n      },\n      () =>\n        super.render({\n          target: pickingFBO,\n          layers,\n          layerFilter,\n          views,\n          viewports,\n          onViewportActive,\n          cullRect,\n          effects: effects?.filter(e => e.useInPicking),\n          pass,\n          isPicking: true,\n          moduleParameters\n        })\n    );\n\n    // Clear the temp field\n    this._colorEncoderState = null;\n    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);\n    return {decodePickingColor, stats: renderStatus};\n  }\n\n  shouldDrawLayer(layer: Layer): boolean {\n    const {pickable, operation} = layer.props;\n    return (pickable && operation.includes('draw')) || operation.includes('terrain');\n  }\n\n  protected getModuleParameters() {\n    return {\n      pickingActive: 1,\n      pickingAttribute: this.pickZ,\n      // turn off lighting by adding empty light source object\n      // lights shader module relies on the `lightSources` to turn on/off lighting\n      lightSources: {}\n    };\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): any {\n    const pickParameters = {...layer.props.parameters};\n    const {pickable, operation} = layer.props;\n\n    if (!this._colorEncoderState) {\n      pickParameters.blend = false;\n    } else if (pickable && operation.includes('draw')) {\n      Object.assign(pickParameters, PICKING_PARAMETERS);\n      pickParameters.blend = true;\n      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);\n    }\n    if (operation.includes('terrain')) {\n      pickParameters.blend = false;\n    }\n\n    return pickParameters;\n  }\n\n  protected _resetColorEncoder(pickZ: boolean) {\n    // Track encoded layer indices\n    this._colorEncoderState = pickZ\n      ? null\n      : {\n          byLayer: new Map<Layer, EncodedPickingColors>(),\n          byAlpha: []\n        };\n    // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n    return this._colorEncoderState;\n  }\n}\n\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(\n  encoded: {\n    byLayer: Map<Layer, EncodedPickingColors>;\n    byAlpha: EncodedPickingColors[];\n  },\n  layer: Layer,\n  viewport: Viewport\n): number[] {\n  const {byLayer, byAlpha} = encoded;\n  let a;\n\n  // Encode layerIndex in the alpha channel\n  // TODO - combine small layers to better utilize the picking color space\n  let entry = byLayer.get(layer);\n  if (entry) {\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n    if (a <= 255) {\n      entry = {a, layer, viewports: [viewport]};\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n  return [0, 0, 0, a / 255];\n}\n\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(\n  encoded: {\n    byLayer: Map<Layer, EncodedPickingColors>;\n    byAlpha: EncodedPickingColors[];\n  },\n  pickedColor: number[] | Uint8Array\n):\n  | {\n      pickedLayer: Layer;\n      pickedViewports: Viewport[];\n      pickedObjectIndex: number;\n    }\n  | undefined {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return (\n    entry && {\n      pickedLayer: entry.layer,\n      pickedViewports: entry.viewports,\n      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n    }\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}