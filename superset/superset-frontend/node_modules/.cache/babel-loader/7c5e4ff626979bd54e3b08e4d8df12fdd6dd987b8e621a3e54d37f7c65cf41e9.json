{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { AnnotationOpacity, isTimeseriesAnnotationResult } from '@superset-ui/core';\nimport { extractForecastSeriesContext } from '../utils/forecast';\nimport { EchartsTimeseriesSeriesType, ForecastSeriesEnum, LegendOrientation } from '../types';\nimport { evalFormula, extractRecordAnnotations, formatAnnotationLabel, parseAnnotationOpacity } from '../utils/annotation';\nimport { getChartPadding, getTimeCompareStackId } from '../utils/series';\nimport { OpacityEnum, StackControlsValue, TIMESERIES_CONSTANTS } from '../constants';\n// based on weighted wiggle algorithm\n// source: https://ieeexplore.ieee.org/document/4658136\nexport const getBaselineSeriesForStream = (series, seriesType) => {\n  const seriesLength = series[0].length;\n  const baselineSeriesDelta = new Array(seriesLength).fill([0, 0]);\n  const getVal = (value) => value != null ? value : 0;\n  for (let i = 0; i < seriesLength; i += 1) {\n    let seriesSum = 0;\n    let weightedSeriesSum = 0;\n    for (let j = 0; j < series.length; j += 1) {\n      const delta = i > 0 ?\n      getVal(series[j][i][1]) - getVal(series[j][i - 1][1]) :\n      getVal(series[j][i][1]);\n      let deltaPrev = 0;\n      for (let k = 1; k < j - 1; k += 1) {\n        deltaPrev +=\n        i > 0 ?\n        getVal(series[k][i][1]) - getVal(series[k][i - 1][1]) :\n        getVal(series[k][i][1]);\n      }\n      weightedSeriesSum += (0.5 * delta + deltaPrev) * getVal(series[j][i][1]);\n      seriesSum += getVal(series[j][i][1]);\n    }\n    baselineSeriesDelta[i] = [series[0][i][0], -weightedSeriesSum / seriesSum];\n  }\n  const baselineSeries = baselineSeriesDelta.reduce((acc, curr, i) => {\n    if (i === 0) {\n      acc.push(curr);\n    } else\n    {\n      acc.push([curr[0], acc[i - 1][1] + curr[1]]);\n    }\n    return acc;\n  }, []);\n  return {\n    data: baselineSeries,\n    name: 'baseline',\n    stack: 'obs',\n    stackStrategy: 'all',\n    type: 'line',\n    lineStyle: {\n      opacity: 0\n    },\n    tooltip: {\n      show: false\n    },\n    silent: true,\n    showSymbol: false,\n    areaStyle: {\n      opacity: 0\n    },\n    step: [\n    EchartsTimeseriesSeriesType.Start,\n    EchartsTimeseriesSeriesType.Middle,\n    EchartsTimeseriesSeriesType.End].\n    includes(seriesType) ?\n    seriesType :\n    undefined,\n    smooth: seriesType === EchartsTimeseriesSeriesType.Smooth\n  };\n};\nexport function transformSeries(series, colorScale, colorScaleKey, opts) {\n  const { name } = series;\n  const { area, connectNulls, filterState, seriesContexts = {}, markerEnabled, markerSize, areaOpacity = 1, seriesType, stack, yAxisIndex = 0, showValue, onlyTotal, formatter, legendState, totalStackedValues = [], showValueIndexes = [], thresholdValues = [], richTooltip, sliceId, isHorizontal = false, queryIndex = 0, timeCompare = [] } = opts;\n  const contexts = seriesContexts[name || ''] || [];\n  const hasForecast = contexts.includes(ForecastSeriesEnum.ForecastTrend) ||\n  contexts.includes(ForecastSeriesEnum.ForecastLower) ||\n  contexts.includes(ForecastSeriesEnum.ForecastUpper);\n  const forecastSeries = extractForecastSeriesContext(name || '');\n  const isConfidenceBand = forecastSeries.type === ForecastSeriesEnum.ForecastLower ||\n  forecastSeries.type === ForecastSeriesEnum.ForecastUpper;\n  const isFiltered = (filterState == null ? void 0 : filterState.selectedValues) && !(filterState != null && filterState.selectedValues.includes(name));\n  const opacity = isFiltered ?\n  OpacityEnum.SemiTransparent :\n  OpacityEnum.NonTransparent;\n  // don't create a series if doing a stack or area chart and the result\n  // is a confidence band\n  if ((stack || area) && isConfidenceBand)\n  return undefined;\n  const isObservation = forecastSeries.type === ForecastSeriesEnum.Observation;\n  const isTrend = forecastSeries.type === ForecastSeriesEnum.ForecastTrend;\n  let stackId;\n  if (isConfidenceBand) {\n    stackId = forecastSeries.name;\n  } else\n  if (stack && isObservation) {\n    // the suffix of the observation series is '' (falsy), which disables\n    // stacking. Therefore we need to set something that is truthy.\n    stackId = getTimeCompareStackId('obs', timeCompare, name);\n  } else\n  if (stack && isTrend) {\n    stackId = getTimeCompareStackId(forecastSeries.type, timeCompare, name);\n  }\n  let plotType;\n  if (!isConfidenceBand && (\n  seriesType === 'scatter' || hasForecast && isObservation)) {\n    plotType = 'scatter';\n  } else\n  if (isConfidenceBand) {\n    plotType = 'line';\n  } else\n  {\n    plotType = seriesType === 'bar' ? 'bar' : 'line';\n  }\n  // forcing the colorScale to return a different color for same metrics across different queries\n  const itemStyle = {\n    color: colorScale(colorScaleKey, sliceId),\n    opacity\n  };\n  let emphasis = {};\n  let showSymbol = false;\n  if (!isConfidenceBand) {\n    if (plotType === 'scatter') {\n      showSymbol = true;\n    } else\n    if (hasForecast && isObservation) {\n      showSymbol = true;\n    } else\n    if (plotType === 'line' && showValue) {\n      showSymbol = true;\n    } else\n    if (plotType === 'line' && !richTooltip && !markerEnabled) {\n      // this is hack to make timeseries line chart clickable when tooltip trigger is 'item'\n      // so that the chart can emit cross-filtering\n      showSymbol = true;\n      itemStyle.opacity = 0;\n      emphasis = {\n        itemStyle: {\n          opacity: 1\n        }\n      };\n    } else\n    if (markerEnabled) {\n      showSymbol = true;\n    }\n  }\n  const lineStyle = isConfidenceBand || stack === StackControlsValue.Stream && area ?\n  { ...opts.lineStyle, opacity: OpacityEnum.Transparent } :\n  { ...opts.lineStyle, opacity };\n  return {\n    ...series,\n    connectNulls,\n    queryIndex,\n    yAxisIndex,\n    name: forecastSeries.name,\n    itemStyle,\n    // @ts-ignore\n    type: plotType,\n    smooth: seriesType === 'smooth',\n    triggerLineEvent: true,\n    // @ts-ignore\n    step: ['start', 'middle', 'end'].includes(seriesType) ?\n    seriesType :\n    undefined,\n    stack: stackId,\n    stackStrategy: isConfidenceBand || stack === StackControlsValue.Stream ?\n    'all' :\n    'samesign',\n    lineStyle,\n    areaStyle: area || forecastSeries.type === ForecastSeriesEnum.ForecastUpper ?\n    {\n      opacity: opacity * areaOpacity\n    } :\n    undefined,\n    emphasis: {\n      // bold on hover as required since 5.3.0 to retain backwards feature parity:\n      // https://apache.github.io/echarts-handbook/en/basics/release-note/5-3-0/#removing-the-default-bolding-emphasis-effect-in-the-line-chart\n      // TODO: should consider only adding emphasis to currently hovered series\n      lineStyle: {\n        width: 'bolder'\n      },\n      ...emphasis\n    },\n    showSymbol,\n    symbolSize: markerSize,\n    label: {\n      show: !!showValue,\n      position: isHorizontal ? 'right' : 'top',\n      formatter: (params) => {\n        const { value, dataIndex, seriesIndex, seriesName } = params;\n        const numericValue = isHorizontal ? value[0] : value[1];\n        const isSelectedLegend = !legendState || legendState[seriesName];\n        const isAreaExpand = stack === StackControlsValue.Expand;\n        if (!formatter) {\n          return numericValue;\n        }\n        if (!stack && isSelectedLegend) {\n          return formatter(numericValue);\n        }\n        if (!onlyTotal) {\n          if (numericValue >= (\n          thresholdValues[dataIndex] || Number.MIN_SAFE_INTEGER)) {\n            return formatter(numericValue);\n          }\n          return '';\n        }\n        if (seriesIndex === showValueIndexes[dataIndex]) {\n          return formatter(isAreaExpand ? 1 : totalStackedValues[dataIndex]);\n        }\n        return '';\n      }\n    }\n  };\n}\nexport function transformFormulaAnnotation(layer, data, xAxisCol, xAxisType, colorScale, sliceId) {\n  const { name, color, opacity, width, style } = layer;\n  return {\n    name,\n    id: name,\n    itemStyle: {\n      color: color || colorScale(name, sliceId)\n    },\n    lineStyle: {\n      opacity: parseAnnotationOpacity(opacity),\n      type: style,\n      width\n    },\n    type: 'line',\n    smooth: true,\n    data: evalFormula(layer, data, xAxisCol, xAxisType),\n    symbolSize: 0\n  };\n}\nexport function transformIntervalAnnotation(layer, data, annotationData, colorScale, theme, sliceId) {\n  const series = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach((annotation) => {\n    const { name, color, opacity, showLabel } = layer;\n    const { descriptions, intervalEnd, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const intervalData = [\n    [\n    {\n      name: label,\n      xAxis: time\n    },\n    {\n      xAxis: intervalEnd\n    }]];\n\n\n    const intervalLabel = showLabel ?\n    {\n      show: true,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideTop',\n      verticalAlign: 'top',\n      fontWeight: 'bold',\n      // @ts-ignore\n      emphasis: {\n        position: 'insideTop',\n        verticalAlign: 'top',\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    } :\n    {\n      show: false,\n      color: theme.colors.grayscale.dark2,\n      // @ts-ignore\n      emphasis: {\n        fontWeight: 'bold',\n        show: true,\n        position: 'insideTop',\n        verticalAlign: 'top',\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    };\n    series.push({\n      id: `Interval - ${label}`,\n      type: 'line',\n      animation: false,\n      markArea: {\n        silent: false,\n        itemStyle: {\n          color: color || colorScale(name, sliceId),\n          opacity: parseAnnotationOpacity(opacity || AnnotationOpacity.Medium),\n          emphasis: {\n            opacity: 0.8\n          }\n        },\n        label: intervalLabel,\n        data: intervalData\n      }\n    });\n  });\n  return series;\n}\nexport function transformEventAnnotation(layer, data, annotationData, colorScale, theme, sliceId) {\n  const series = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach((annotation) => {\n    const { name, color, opacity, style, width, showLabel } = layer;\n    const { descriptions, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const eventData = [\n    {\n      name: label,\n      xAxis: time\n    }];\n\n    const lineStyle = {\n      width,\n      type: style,\n      color: color || colorScale(name, sliceId),\n      opacity: parseAnnotationOpacity(opacity),\n      emphasis: {\n        width: width ? width + 1 : width,\n        opacity: 1\n      }\n    };\n    const eventLabel = showLabel ?\n    {\n      show: true,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideEndTop',\n      fontWeight: 'bold',\n      formatter: (params) => params.name,\n      // @ts-ignore\n      emphasis: {\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    } :\n    {\n      show: false,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideEndTop',\n      // @ts-ignore\n      emphasis: {\n        formatter: (params) => params.name,\n        fontWeight: 'bold',\n        show: true,\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    };\n    series.push({\n      id: `Event - ${label}`,\n      type: 'line',\n      animation: false,\n      markLine: {\n        silent: false,\n        symbol: 'none',\n        lineStyle,\n        label: eventLabel,\n        data: eventData\n      }\n    });\n  });\n  return series;\n}\nexport function transformTimeseriesAnnotation(layer, markerSize, data, annotationData, colorScale, sliceId) {\n  const series = [];\n  const { hideLine, name, opacity, showMarkers, style, width, color } = layer;\n  const result = annotationData[name];\n  if (isTimeseriesAnnotationResult(result)) {\n    result.forEach((annotation) => {\n      const { key, values } = annotation;\n      series.push({\n        type: 'line',\n        id: key,\n        name: key,\n        data: values.map((row) => [row.x, row.y]),\n        symbolSize: showMarkers ? markerSize : 0,\n        lineStyle: {\n          opacity: parseAnnotationOpacity(opacity),\n          type: style,\n          width: hideLine ? 0 : width,\n          color: color || colorScale(name, sliceId)\n        }\n      });\n    });\n  }\n  return series;\n}\nexport function getPadding(showLegend, legendOrientation, addYAxisTitleOffset, zoomable, margin, addXAxisTitleOffset, yAxisTitlePosition, yAxisTitleMargin, xAxisTitleMargin, isHorizontal) {\n  const yAxisOffset = addYAxisTitleOffset ?\n  TIMESERIES_CONSTANTS.yAxisLabelTopOffset :\n  0;\n  const xAxisOffset = addXAxisTitleOffset ? Number(xAxisTitleMargin) || 0 : 0;\n  const showLegendTopOffset = isHorizontal && showLegend && legendOrientation === LegendOrientation.Top ?\n  100 :\n  0;\n  return getChartPadding(showLegend, legendOrientation, margin, {\n    top: yAxisTitlePosition && yAxisTitlePosition === 'Top' ?\n    TIMESERIES_CONSTANTS.gridOffsetTop +\n    showLegendTopOffset + (\n    Number(yAxisTitleMargin) || 0) :\n    TIMESERIES_CONSTANTS.gridOffsetTop +\n    showLegendTopOffset +\n    yAxisOffset,\n    bottom: zoomable && !isHorizontal ?\n    TIMESERIES_CONSTANTS.gridOffsetBottomZoomable + xAxisOffset :\n    TIMESERIES_CONSTANTS.gridOffsetBottom + xAxisOffset,\n    left: yAxisTitlePosition === 'Left' ?\n    TIMESERIES_CONSTANTS.gridOffsetLeft + (\n    Number(yAxisTitleMargin) || 0) :\n    TIMESERIES_CONSTANTS.gridOffsetLeft,\n    right: showLegend && legendOrientation === LegendOrientation.Right ?\n    0 :\n    TIMESERIES_CONSTANTS.gridOffsetRight\n  }, isHorizontal);\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getBaselineSeriesForStream, \"getBaselineSeriesForStream\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformSeries, \"transformSeries\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformFormulaAnnotation, \"transformFormulaAnnotation\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformIntervalAnnotation, \"transformIntervalAnnotation\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformEventAnnotation, \"transformEventAnnotation\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformTimeseriesAnnotation, \"transformTimeseriesAnnotation\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(getPadding, \"getPadding\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["AnnotationOpacity","isTimeseriesAnnotationResult","extractForecastSeriesContext","EchartsTimeseriesSeriesType","ForecastSeriesEnum","LegendOrientation","evalFormula","extractRecordAnnotations","formatAnnotationLabel","parseAnnotationOpacity","getChartPadding","getTimeCompareStackId","OpacityEnum","StackControlsValue","TIMESERIES_CONSTANTS","getBaselineSeriesForStream","series","seriesType","seriesLength","length","baselineSeriesDelta","Array","fill","getVal","value","i","seriesSum","weightedSeriesSum","j","delta","deltaPrev","k","baselineSeries","reduce","acc","curr","push","data","name","stack","stackStrategy","type","lineStyle","opacity","tooltip","show","silent","showSymbol","areaStyle","step","Start","Middle","End","includes","undefined","smooth","Smooth","transformSeries","colorScale","colorScaleKey","opts","area","connectNulls","filterState","seriesContexts","markerEnabled","markerSize","areaOpacity","yAxisIndex","showValue","onlyTotal","formatter","legendState","totalStackedValues","showValueIndexes","thresholdValues","richTooltip","sliceId","isHorizontal","queryIndex","timeCompare","contexts","hasForecast","ForecastTrend","ForecastLower","ForecastUpper","forecastSeries","isConfidenceBand","isFiltered","selectedValues","SemiTransparent","NonTransparent","isObservation","Observation","isTrend","stackId","plotType","itemStyle","color","emphasis","Stream","Transparent","triggerLineEvent","width","symbolSize","label","position","params","dataIndex","seriesIndex","seriesName","numericValue","isSelectedLegend","isAreaExpand","Expand","Number","MIN_SAFE_INTEGER","transformFormulaAnnotation","layer","xAxisCol","xAxisType","style","id","transformIntervalAnnotation","annotationData","theme","annotations","forEach","annotation","showLabel","descriptions","intervalEnd","time","title","intervalData","xAxis","intervalLabel","colors","grayscale","dark2","verticalAlign","fontWeight","backgroundColor","light5","animation","markArea","Medium","transformEventAnnotation","eventData","eventLabel","markLine","symbol","transformTimeseriesAnnotation","hideLine","showMarkers","result","key","values","map","row","x","y","getPadding","showLegend","legendOrientation","addYAxisTitleOffset","zoomable","margin","addXAxisTitleOffset","yAxisTitlePosition","yAxisTitleMargin","xAxisTitleMargin","yAxisOffset","yAxisLabelTopOffset","xAxisOffset","showLegendTopOffset","Top","top","gridOffsetTop","bottom","gridOffsetBottomZoomable","gridOffsetBottom","left","gridOffsetLeft","right","Right","gridOffsetRight","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AnnotationData,\n  AnnotationOpacity,\n  AxisType,\n  CategoricalColorScale,\n  EventAnnotationLayer,\n  FilterState,\n  FormulaAnnotationLayer,\n  IntervalAnnotationLayer,\n  isTimeseriesAnnotationResult,\n  LegendState,\n  SupersetTheme,\n  TimeseriesAnnotationLayer,\n  TimeseriesDataRecord,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport { SeriesOption } from 'echarts';\nimport {\n  CallbackDataParams,\n  DefaultStatesMixin,\n  ItemStyleOption,\n  LineStyleOption,\n  OptionName,\n  SeriesLabelOption,\n  SeriesLineLabelOption,\n  ZRLineType,\n} from 'echarts/types/src/util/types';\nimport {\n  MarkArea1DDataItemOption,\n  MarkArea2DDataItemOption,\n} from 'echarts/types/src/component/marker/MarkAreaModel';\nimport { MarkLine1DDataItemOption } from 'echarts/types/src/component/marker/MarkLineModel';\nimport { extractForecastSeriesContext } from '../utils/forecast';\nimport {\n  EchartsTimeseriesSeriesType,\n  ForecastSeriesEnum,\n  LegendOrientation,\n  StackType,\n} from '../types';\n\nimport {\n  evalFormula,\n  extractRecordAnnotations,\n  formatAnnotationLabel,\n  parseAnnotationOpacity,\n} from '../utils/annotation';\nimport { getChartPadding, getTimeCompareStackId } from '../utils/series';\nimport {\n  OpacityEnum,\n  StackControlsValue,\n  TIMESERIES_CONSTANTS,\n} from '../constants';\n\n// based on weighted wiggle algorithm\n// source: https://ieeexplore.ieee.org/document/4658136\nexport const getBaselineSeriesForStream = (\n  series: [string | number, number][][],\n  seriesType: EchartsTimeseriesSeriesType,\n) => {\n  const seriesLength = series[0].length;\n  const baselineSeriesDelta = new Array(seriesLength).fill([0, 0]);\n  const getVal = (value: number | null) => value ?? 0;\n  for (let i = 0; i < seriesLength; i += 1) {\n    let seriesSum = 0;\n    let weightedSeriesSum = 0;\n    for (let j = 0; j < series.length; j += 1) {\n      const delta =\n        i > 0\n          ? getVal(series[j][i][1]) - getVal(series[j][i - 1][1])\n          : getVal(series[j][i][1]);\n      let deltaPrev = 0;\n      for (let k = 1; k < j - 1; k += 1) {\n        deltaPrev +=\n          i > 0\n            ? getVal(series[k][i][1]) - getVal(series[k][i - 1][1])\n            : getVal(series[k][i][1]);\n      }\n      weightedSeriesSum += (0.5 * delta + deltaPrev) * getVal(series[j][i][1]);\n      seriesSum += getVal(series[j][i][1]);\n    }\n    baselineSeriesDelta[i] = [series[0][i][0], -weightedSeriesSum / seriesSum];\n  }\n  const baselineSeries = baselineSeriesDelta.reduce((acc, curr, i) => {\n    if (i === 0) {\n      acc.push(curr);\n    } else {\n      acc.push([curr[0], acc[i - 1][1] + curr[1]]);\n    }\n    return acc;\n  }, []);\n  return {\n    data: baselineSeries,\n    name: 'baseline',\n    stack: 'obs',\n    stackStrategy: 'all' as const,\n    type: 'line' as const,\n    lineStyle: {\n      opacity: 0,\n    },\n    tooltip: {\n      show: false,\n    },\n    silent: true,\n    showSymbol: false,\n    areaStyle: {\n      opacity: 0,\n    },\n    step: [\n      EchartsTimeseriesSeriesType.Start,\n      EchartsTimeseriesSeriesType.Middle,\n      EchartsTimeseriesSeriesType.End,\n    ].includes(seriesType)\n      ? (seriesType as\n          | EchartsTimeseriesSeriesType.Start\n          | EchartsTimeseriesSeriesType.Middle\n          | EchartsTimeseriesSeriesType.End)\n      : undefined,\n    smooth: seriesType === EchartsTimeseriesSeriesType.Smooth,\n  };\n};\n\nexport function transformSeries(\n  series: SeriesOption,\n  colorScale: CategoricalColorScale,\n  colorScaleKey: string,\n  opts: {\n    area?: boolean;\n    connectNulls?: boolean;\n    filterState?: FilterState;\n    seriesContexts?: { [key: string]: ForecastSeriesEnum[] };\n    markerEnabled?: boolean;\n    markerSize?: number;\n    areaOpacity?: number;\n    seriesType?: EchartsTimeseriesSeriesType;\n    stack?: StackType;\n    yAxisIndex?: number;\n    showValue?: boolean;\n    onlyTotal?: boolean;\n    legendState?: LegendState;\n    formatter?: ValueFormatter;\n    totalStackedValues?: number[];\n    showValueIndexes?: number[];\n    thresholdValues?: number[];\n    richTooltip?: boolean;\n    seriesKey?: OptionName;\n    sliceId?: number;\n    isHorizontal?: boolean;\n    lineStyle?: LineStyleOption;\n    queryIndex?: number;\n    timeCompare?: string[];\n  },\n): SeriesOption | undefined {\n  const { name } = series;\n  const {\n    area,\n    connectNulls,\n    filterState,\n    seriesContexts = {},\n    markerEnabled,\n    markerSize,\n    areaOpacity = 1,\n    seriesType,\n    stack,\n    yAxisIndex = 0,\n    showValue,\n    onlyTotal,\n    formatter,\n    legendState,\n    totalStackedValues = [],\n    showValueIndexes = [],\n    thresholdValues = [],\n    richTooltip,\n    sliceId,\n    isHorizontal = false,\n    queryIndex = 0,\n    timeCompare = [],\n  } = opts;\n  const contexts = seriesContexts[name || ''] || [];\n  const hasForecast =\n    contexts.includes(ForecastSeriesEnum.ForecastTrend) ||\n    contexts.includes(ForecastSeriesEnum.ForecastLower) ||\n    contexts.includes(ForecastSeriesEnum.ForecastUpper);\n\n  const forecastSeries = extractForecastSeriesContext(name || '');\n  const isConfidenceBand =\n    forecastSeries.type === ForecastSeriesEnum.ForecastLower ||\n    forecastSeries.type === ForecastSeriesEnum.ForecastUpper;\n  const isFiltered =\n    filterState?.selectedValues && !filterState?.selectedValues.includes(name);\n  const opacity = isFiltered\n    ? OpacityEnum.SemiTransparent\n    : OpacityEnum.NonTransparent;\n\n  // don't create a series if doing a stack or area chart and the result\n  // is a confidence band\n  if ((stack || area) && isConfidenceBand) return undefined;\n\n  const isObservation = forecastSeries.type === ForecastSeriesEnum.Observation;\n  const isTrend = forecastSeries.type === ForecastSeriesEnum.ForecastTrend;\n  let stackId;\n  if (isConfidenceBand) {\n    stackId = forecastSeries.name;\n  } else if (stack && isObservation) {\n    // the suffix of the observation series is '' (falsy), which disables\n    // stacking. Therefore we need to set something that is truthy.\n    stackId = getTimeCompareStackId('obs', timeCompare, name);\n  } else if (stack && isTrend) {\n    stackId = getTimeCompareStackId(forecastSeries.type, timeCompare, name);\n  }\n  let plotType;\n  if (\n    !isConfidenceBand &&\n    (seriesType === 'scatter' || (hasForecast && isObservation))\n  ) {\n    plotType = 'scatter';\n  } else if (isConfidenceBand) {\n    plotType = 'line';\n  } else {\n    plotType = seriesType === 'bar' ? 'bar' : 'line';\n  }\n  // forcing the colorScale to return a different color for same metrics across different queries\n  const itemStyle = {\n    color: colorScale(colorScaleKey, sliceId),\n    opacity,\n  };\n  let emphasis = {};\n  let showSymbol = false;\n  if (!isConfidenceBand) {\n    if (plotType === 'scatter') {\n      showSymbol = true;\n    } else if (hasForecast && isObservation) {\n      showSymbol = true;\n    } else if (plotType === 'line' && showValue) {\n      showSymbol = true;\n    } else if (plotType === 'line' && !richTooltip && !markerEnabled) {\n      // this is hack to make timeseries line chart clickable when tooltip trigger is 'item'\n      // so that the chart can emit cross-filtering\n      showSymbol = true;\n      itemStyle.opacity = 0;\n      emphasis = {\n        itemStyle: {\n          opacity: 1,\n        },\n      };\n    } else if (markerEnabled) {\n      showSymbol = true;\n    }\n  }\n  const lineStyle =\n    isConfidenceBand || (stack === StackControlsValue.Stream && area)\n      ? { ...opts.lineStyle, opacity: OpacityEnum.Transparent }\n      : { ...opts.lineStyle, opacity };\n  return {\n    ...series,\n    connectNulls,\n    queryIndex,\n    yAxisIndex,\n    name: forecastSeries.name,\n    itemStyle,\n    // @ts-ignore\n    type: plotType,\n    smooth: seriesType === 'smooth',\n    triggerLineEvent: true,\n    // @ts-ignore\n    step: ['start', 'middle', 'end'].includes(seriesType as string)\n      ? seriesType\n      : undefined,\n    stack: stackId,\n    stackStrategy:\n      isConfidenceBand || stack === StackControlsValue.Stream\n        ? 'all'\n        : 'samesign',\n    lineStyle,\n    areaStyle:\n      area || forecastSeries.type === ForecastSeriesEnum.ForecastUpper\n        ? {\n            opacity: opacity * areaOpacity,\n          }\n        : undefined,\n    emphasis: {\n      // bold on hover as required since 5.3.0 to retain backwards feature parity:\n      // https://apache.github.io/echarts-handbook/en/basics/release-note/5-3-0/#removing-the-default-bolding-emphasis-effect-in-the-line-chart\n      // TODO: should consider only adding emphasis to currently hovered series\n      lineStyle: {\n        width: 'bolder',\n      },\n      ...emphasis,\n    },\n    showSymbol,\n    symbolSize: markerSize,\n    label: {\n      show: !!showValue,\n      position: isHorizontal ? 'right' : 'top',\n      formatter: (params: any) => {\n        const { value, dataIndex, seriesIndex, seriesName } = params;\n        const numericValue = isHorizontal ? value[0] : value[1];\n        const isSelectedLegend = !legendState || legendState[seriesName];\n        const isAreaExpand = stack === StackControlsValue.Expand;\n        if (!formatter) {\n          return numericValue;\n        }\n        if (!stack && isSelectedLegend) {\n          return formatter(numericValue);\n        }\n        if (!onlyTotal) {\n          if (\n            numericValue >=\n            (thresholdValues[dataIndex] || Number.MIN_SAFE_INTEGER)\n          ) {\n            return formatter(numericValue);\n          }\n          return '';\n        }\n        if (seriesIndex === showValueIndexes[dataIndex]) {\n          return formatter(isAreaExpand ? 1 : totalStackedValues[dataIndex]);\n        }\n        return '';\n      },\n    },\n  };\n}\n\nexport function transformFormulaAnnotation(\n  layer: FormulaAnnotationLayer,\n  data: TimeseriesDataRecord[],\n  xAxisCol: string,\n  xAxisType: AxisType,\n  colorScale: CategoricalColorScale,\n  sliceId?: number,\n): SeriesOption {\n  const { name, color, opacity, width, style } = layer;\n  return {\n    name,\n    id: name,\n    itemStyle: {\n      color: color || colorScale(name, sliceId),\n    },\n    lineStyle: {\n      opacity: parseAnnotationOpacity(opacity),\n      type: style as ZRLineType,\n      width,\n    },\n    type: 'line',\n    smooth: true,\n    data: evalFormula(layer, data, xAxisCol, xAxisType),\n    symbolSize: 0,\n  };\n}\n\nexport function transformIntervalAnnotation(\n  layer: IntervalAnnotationLayer,\n  data: TimeseriesDataRecord[],\n  annotationData: AnnotationData,\n  colorScale: CategoricalColorScale,\n  theme: SupersetTheme,\n  sliceId?: number,\n): SeriesOption[] {\n  const series: SeriesOption[] = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach(annotation => {\n    const { name, color, opacity, showLabel } = layer;\n    const { descriptions, intervalEnd, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const intervalData: (\n      | MarkArea1DDataItemOption\n      | MarkArea2DDataItemOption\n    )[] = [\n      [\n        {\n          name: label,\n          xAxis: time,\n        },\n        {\n          xAxis: intervalEnd,\n        },\n      ],\n    ];\n    const intervalLabel: SeriesLabelOption = showLabel\n      ? {\n          show: true,\n          color: theme.colors.grayscale.dark2,\n          position: 'insideTop',\n          verticalAlign: 'top',\n          fontWeight: 'bold',\n          // @ts-ignore\n          emphasis: {\n            position: 'insideTop',\n            verticalAlign: 'top',\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        }\n      : {\n          show: false,\n          color: theme.colors.grayscale.dark2,\n          // @ts-ignore\n          emphasis: {\n            fontWeight: 'bold',\n            show: true,\n            position: 'insideTop',\n            verticalAlign: 'top',\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        };\n    series.push({\n      id: `Interval - ${label}`,\n      type: 'line',\n      animation: false,\n      markArea: {\n        silent: false,\n        itemStyle: {\n          color: color || colorScale(name, sliceId),\n          opacity: parseAnnotationOpacity(opacity || AnnotationOpacity.Medium),\n          emphasis: {\n            opacity: 0.8,\n          },\n        } as ItemStyleOption,\n        label: intervalLabel,\n        data: intervalData,\n      },\n    });\n  });\n  return series;\n}\n\nexport function transformEventAnnotation(\n  layer: EventAnnotationLayer,\n  data: TimeseriesDataRecord[],\n  annotationData: AnnotationData,\n  colorScale: CategoricalColorScale,\n  theme: SupersetTheme,\n  sliceId?: number,\n): SeriesOption[] {\n  const series: SeriesOption[] = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach(annotation => {\n    const { name, color, opacity, style, width, showLabel } = layer;\n    const { descriptions, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const eventData: MarkLine1DDataItemOption[] = [\n      {\n        name: label,\n        xAxis: time,\n      },\n    ];\n\n    const lineStyle: LineStyleOption & DefaultStatesMixin['emphasis'] = {\n      width,\n      type: style as ZRLineType,\n      color: color || colorScale(name, sliceId),\n      opacity: parseAnnotationOpacity(opacity),\n      emphasis: {\n        width: width ? width + 1 : width,\n        opacity: 1,\n      },\n    };\n\n    const eventLabel: SeriesLineLabelOption = showLabel\n      ? {\n          show: true,\n          color: theme.colors.grayscale.dark2,\n          position: 'insideEndTop',\n          fontWeight: 'bold',\n          formatter: (params: CallbackDataParams) => params.name,\n          // @ts-ignore\n          emphasis: {\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        }\n      : {\n          show: false,\n          color: theme.colors.grayscale.dark2,\n          position: 'insideEndTop',\n          // @ts-ignore\n          emphasis: {\n            formatter: (params: CallbackDataParams) => params.name,\n            fontWeight: 'bold',\n            show: true,\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        };\n\n    series.push({\n      id: `Event - ${label}`,\n      type: 'line',\n      animation: false,\n      markLine: {\n        silent: false,\n        symbol: 'none',\n        lineStyle,\n        label: eventLabel,\n        data: eventData,\n      },\n    });\n  });\n  return series;\n}\n\nexport function transformTimeseriesAnnotation(\n  layer: TimeseriesAnnotationLayer,\n  markerSize: number,\n  data: TimeseriesDataRecord[],\n  annotationData: AnnotationData,\n  colorScale: CategoricalColorScale,\n  sliceId?: number,\n): SeriesOption[] {\n  const series: SeriesOption[] = [];\n  const { hideLine, name, opacity, showMarkers, style, width, color } = layer;\n  const result = annotationData[name];\n  if (isTimeseriesAnnotationResult(result)) {\n    result.forEach(annotation => {\n      const { key, values } = annotation;\n      series.push({\n        type: 'line',\n        id: key,\n        name: key,\n        data: values.map(row => [row.x, row.y] as [OptionName, number]),\n        symbolSize: showMarkers ? markerSize : 0,\n        lineStyle: {\n          opacity: parseAnnotationOpacity(opacity),\n          type: style as ZRLineType,\n          width: hideLine ? 0 : width,\n          color: color || colorScale(name, sliceId),\n        },\n      });\n    });\n  }\n  return series;\n}\n\nexport function getPadding(\n  showLegend: boolean,\n  legendOrientation: LegendOrientation,\n  addYAxisTitleOffset: boolean,\n  zoomable: boolean,\n  margin?: string | number | null,\n  addXAxisTitleOffset?: boolean,\n  yAxisTitlePosition?: string,\n  yAxisTitleMargin?: number,\n  xAxisTitleMargin?: number,\n  isHorizontal?: boolean,\n): {\n  bottom: number;\n  left: number;\n  right: number;\n  top: number;\n} {\n  const yAxisOffset = addYAxisTitleOffset\n    ? TIMESERIES_CONSTANTS.yAxisLabelTopOffset\n    : 0;\n  const xAxisOffset = addXAxisTitleOffset ? Number(xAxisTitleMargin) || 0 : 0;\n  const showLegendTopOffset =\n    isHorizontal && showLegend && legendOrientation === LegendOrientation.Top\n      ? 100\n      : 0;\n\n  return getChartPadding(\n    showLegend,\n    legendOrientation,\n    margin,\n    {\n      top:\n        yAxisTitlePosition && yAxisTitlePosition === 'Top'\n          ? TIMESERIES_CONSTANTS.gridOffsetTop +\n            showLegendTopOffset +\n            (Number(yAxisTitleMargin) || 0)\n          : TIMESERIES_CONSTANTS.gridOffsetTop +\n            showLegendTopOffset +\n            yAxisOffset,\n      bottom:\n        zoomable && !isHorizontal\n          ? TIMESERIES_CONSTANTS.gridOffsetBottomZoomable + xAxisOffset\n          : TIMESERIES_CONSTANTS.gridOffsetBottom + xAxisOffset,\n      left:\n        yAxisTitlePosition === 'Left'\n          ? TIMESERIES_CONSTANTS.gridOffsetLeft +\n            (Number(yAxisTitleMargin) || 0)\n          : TIMESERIES_CONSTANTS.gridOffsetLeft,\n      right:\n        showLegend && legendOrientation === LegendOrientation.Right\n          ? 0\n          : TIMESERIES_CONSTANTS.gridOffsetRight,\n    },\n    isHorizontal,\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}