{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _uniq from \"lodash/uniq\";import _isEqual from \"lodash/isEqual\";import _debounce from \"lodash/debounce\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { forwardRef, useEffect, useMemo, useState, useCallback } from 'react';\nimport { ensureIsArray, formatNumber, NumberFormats, t, usePrevious } from '@superset-ui/core';\nimport AntdSelect from 'antd/lib/select';\n\nimport { FAST_DEBOUNCE } from 'src/constants';\nimport { getValue, hasOption, isLabeledValue, renderSelectOptions, sortSelectedFirstHelper, sortComparatorWithSearchHelper, handleFilterOptionHelper, dropDownRenderHelper, getSuffixIcon, SELECT_ALL_VALUE, selectAllOption, mapValues, mapOptions, hasCustomLabels, getOption, isObject, isEqual as utilsIsEqual } from './utils';\nimport { StyledCheckOutlined, StyledContainer, StyledHeader, StyledSelect, StyledStopOutlined } from './styles';\nimport { EMPTY_OPTIONS, MAX_TAG_COUNT, TOKEN_SEPARATORS, DEFAULT_SORT_COMPARATOR } from './constants';\nimport { customTagRender } from './CustomTag';\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst Select = /*#__PURE__*/forwardRef(__signature__(({ allowClear, allowNewOptions = false, allowSelectAll = true, ariaLabel, autoClearSearchValue = false, filterOption = true, header = null, headerPosition = 'top', helperText, invertSelection = false, labelInValue = false, loading, mode = 'single', name, notFoundContent, onBlur, onChange, onClear, onDropdownVisibleChange, onDeselect, onSearch, onSelect, optionFilterProps = ['label', 'value'], options, placeholder = t('Select ...'), showSearch = true, sortComparator = DEFAULT_SORT_COMPARATOR, tokenSeparators = TOKEN_SEPARATORS, value, getPopupContainer, oneLine, maxTagCount: propsMaxTagCount, ...props }, ref) => {\n  const isSingleMode = mode === 'single';\n  const shouldShowSearch = allowNewOptions ? true : showSearch;\n  const [selectValue, setSelectValue] = useState(value);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [maxTagCount, setMaxTagCount] = useState(propsMaxTagCount != null ? propsMaxTagCount : MAX_TAG_COUNT);\n  const [onChangeCount, setOnChangeCount] = useState(0);\n  const previousChangeCount = usePrevious(onChangeCount, 0);\n  const fireOnChange = useCallback(() => setOnChangeCount(onChangeCount + 1), [onChangeCount]);\n  useEffect(() => {\n    if (oneLine) {\n      setMaxTagCount(isDropdownVisible ? 0 : 1);\n    }\n  }, [isDropdownVisible, oneLine]);\n  const mappedMode = isSingleMode ? undefined : 'multiple';\n  const { Option } = AntdSelect;\n  const sortSelectedFirst = useCallback((a, b) => sortSelectedFirstHelper(a, b, selectValue), [selectValue]);\n  const sortComparatorWithSearch = useCallback((a, b) => sortComparatorWithSearchHelper(a, b, inputValue, sortSelectedFirst, sortComparator), [inputValue, sortComparator, sortSelectedFirst]);\n  const initialOptions = useMemo(() => Array.isArray(options) ? options.slice() : EMPTY_OPTIONS, [options]);\n  const initialOptionsSorted = useMemo(() => initialOptions.slice().sort(sortSelectedFirst), [initialOptions, sortSelectedFirst]);\n  const [selectOptions, setSelectOptions] = useState(initialOptionsSorted);\n  // add selected values to options list if they are not in it\n  const fullSelectOptions = useMemo(() => {\n    const missingValues = ensureIsArray(selectValue).\n    filter((opt) => !hasOption(getValue(opt), selectOptions)).\n    map((opt) => isLabeledValue(opt) ? opt : { value: opt, label: String(opt) });\n    const result = missingValues.length > 0 ?\n    missingValues.concat(selectOptions) :\n    selectOptions;\n    return result.filter((opt) => opt.value !== SELECT_ALL_VALUE);\n  }, [selectOptions, selectValue]);\n  const enabledOptions = useMemo(() => fullSelectOptions.filter((option) => !option.disabled), [fullSelectOptions]);\n  const selectAllEligible = useMemo(() => fullSelectOptions.filter((option) => hasOption(option.value, selectValue) || !option.disabled), [fullSelectOptions, selectValue]);\n  const selectAllEnabled = useMemo(() => !isSingleMode &&\n  allowSelectAll &&\n  selectOptions.length > 0 &&\n  enabledOptions.length > 1 &&\n  !inputValue, [\n  isSingleMode,\n  allowSelectAll,\n  selectOptions.length,\n  enabledOptions.length,\n  inputValue]\n  );\n  const selectAllMode = useMemo(() => ensureIsArray(selectValue).length === selectAllEligible.length + 1, [selectValue, selectAllEligible]);\n  const handleOnSelect = (selectedItem, option) => {\n    if (isSingleMode) {\n      // on select is fired in single value mode if the same value is selected\n      const valueChanged = !utilsIsEqual(selectedItem, selectValue, 'value');\n      setSelectValue(selectedItem);\n      if (valueChanged) {\n        fireOnChange();\n      }\n    } else\n    {\n      setSelectValue((previousState) => {\n        const array = ensureIsArray(previousState);\n        const value = getValue(selectedItem);\n        // Tokenized values can contain duplicated values\n        if (value === getValue(SELECT_ALL_VALUE)) {\n          if (isLabeledValue(selectedItem)) {\n            return [\n            ...selectAllEligible,\n            selectAllOption];\n\n          }\n          return [\n          SELECT_ALL_VALUE,\n          ...selectAllEligible.map((opt) => opt.value)];\n\n        }\n        if (!hasOption(value, array)) {\n          const result = [...array, selectedItem];\n          if (result.length === selectAllEligible.length &&\n          selectAllEnabled) {\n            return isLabeledValue(selectedItem) ?\n            [...result, selectAllOption] :\n            [...result, SELECT_ALL_VALUE];\n          }\n          return result;\n        }\n        return previousState;\n      });\n      fireOnChange();\n    }\n    onSelect == null ? void 0 : onSelect(selectedItem, option);\n  };\n  const clear = () => {\n    if (isSingleMode) {\n      setSelectValue(undefined);\n    } else\n    {\n      setSelectValue(fullSelectOptions.\n      filter((option) => option.disabled && hasOption(option.value, selectValue)).\n      map((option) => labelInValue ?\n      { label: option.label, value: option.value } :\n      option.value));\n    }\n    fireOnChange();\n  };\n  const handleOnDeselect = (value, option) => {\n    if (Array.isArray(selectValue)) {\n      if (getValue(value) === getValue(SELECT_ALL_VALUE)) {\n        clear();\n      } else\n      {\n        let array = selectValue;\n        array = array.filter((element) => getValue(element) !== getValue(value));\n        // if this was not a new item, deselect select all option\n        if (selectAllMode && !option.isNewOption) {\n          array = array.filter((element) => getValue(element) !== SELECT_ALL_VALUE);\n        }\n        setSelectValue(array);\n        // removes new option\n        if (option.isNewOption) {\n          setSelectOptions(fullSelectOptions.filter((option) => getValue(option.value) !== getValue(value)));\n        }\n      }\n    }\n    fireOnChange();\n    onDeselect == null ? void 0 : onDeselect(value, option);\n  };\n  const handleOnSearch = _debounce((search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, fullSelectOptions, true) && {\n        label: searchValue,\n        value: searchValue,\n        isNewOption: true\n      };\n      const cleanSelectOptions = ensureIsArray(fullSelectOptions).filter((opt) => !opt.isNewOption || hasOption(opt.value, selectValue));\n      const newOptions = newOption ?\n      [newOption, ...cleanSelectOptions] :\n      cleanSelectOptions;\n      setSelectOptions(newOptions);\n    }\n    setInputValue(searchValue);\n    onSearch == null ? void 0 : onSearch(searchValue);\n  }, FAST_DEBOUNCE);\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n  const handleFilterOption = (search, option) => handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    // if no search input value, force sort options because it won't be sorted by\n    // `filterSort`.\n    if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n      if (!_isEqual(initialOptionsSorted, selectOptions)) {\n        setSelectOptions(initialOptionsSorted);\n      }\n    }\n    if (onDropdownVisibleChange) {\n      onDropdownVisibleChange(isDropdownVisible);\n    }\n  };\n  const dropdownRender = (originNode) => dropDownRenderHelper(originNode, isDropdownVisible, isLoading, fullSelectOptions.length, helperText);\n  const handleClear = () => {\n    clear();\n    if (onClear) {\n      onClear();\n    }\n  };\n  useEffect(() => {\n    // when `options` list is updated from component prop, reset states\n    setSelectOptions(initialOptions);\n  }, [initialOptions]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  useEffect(() => {\n    // if all values are selected, add select all to value\n    if (selectAllEnabled &&\n    ensureIsArray(value).length === selectAllEligible.length) {\n      setSelectValue(labelInValue ?\n      [...ensureIsArray(value), selectAllOption] :\n      [...ensureIsArray(value), SELECT_ALL_VALUE]);\n    }\n  }, [labelInValue, selectAllEligible.length, selectAllEnabled, value]);\n  useEffect(() => {\n    const checkSelectAll = ensureIsArray(selectValue).some((v) => getValue(v) === SELECT_ALL_VALUE);\n    if (checkSelectAll && !selectAllMode) {\n      const optionsToSelect = selectAllEligible.map((option) => labelInValue ? option : option.value);\n      optionsToSelect.push(labelInValue ? selectAllOption : SELECT_ALL_VALUE);\n      setSelectValue(optionsToSelect);\n      fireOnChange();\n    }\n  }, [\n  selectValue,\n  selectAllMode,\n  labelInValue,\n  selectAllEligible,\n  fireOnChange]\n  );\n  const selectAllLabel = useMemo(() => () =>\n  // TODO: localize\n  `${SELECT_ALL_VALUE} (${formatNumber(NumberFormats.INTEGER, selectAllEligible.length)})`, [selectAllEligible]);\n  const handleOnBlur = (event) => {\n    setInputValue('');\n    onBlur == null ? void 0 : onBlur(event);\n  };\n  const handleOnChange = useCallback((values, options) => {\n    // intercept onChange call to handle the select all case\n    // if the \"select all\" option is selected, we want to send all options to the onChange,\n    // otherwise we want to remove\n    let newValues = values;\n    let newOptions = options;\n    if (!isSingleMode) {\n      if (ensureIsArray(newValues).some((val) => getValue(val) === SELECT_ALL_VALUE)) {\n        // send all options to onchange if all are not currently there\n        if (!selectAllMode) {\n          newValues = mapValues(selectAllEligible, labelInValue);\n          newOptions = mapOptions(selectAllEligible);\n        } else\n        {\n          newValues = ensureIsArray(values).filter((val) => getValue(val) !== SELECT_ALL_VALUE);\n        }\n      } else\n      if (ensureIsArray(values).length === selectAllEligible.length &&\n      selectAllMode) {\n        const array = selectAllEligible.filter((option) => hasOption(option.value, selectValue) && option.disabled);\n        newValues = mapValues(array, labelInValue);\n        newOptions = mapOptions(array);\n      }\n    }\n    onChange == null ? void 0 : onChange(newValues, newOptions);\n  }, [\n  isSingleMode,\n  labelInValue,\n  onChange,\n  selectAllEligible,\n  selectAllMode,\n  selectValue]\n  );\n  useEffect(() => {\n    if (onChangeCount !== previousChangeCount) {\n      const array = ensureIsArray(selectValue);\n      const set = new Set(array.map(getValue));\n      const options = mapOptions(fullSelectOptions.filter((opt) => set.has(opt.value)));\n      if (isSingleMode) {\n        handleOnChange(selectValue, selectValue ? options[0] : undefined);\n      } else\n      {\n        handleOnChange(array, options);\n      }\n    }\n  }, [\n  fullSelectOptions,\n  handleOnChange,\n  isSingleMode,\n  onChange,\n  onChangeCount,\n  previousChangeCount,\n  selectValue]\n  );\n  const shouldRenderChildrenOptions = useMemo(() => selectAllEnabled || hasCustomLabels(options), [selectAllEnabled, options]);\n  const omittedCount = useMemo(() => {\n    const num_selected = ensureIsArray(selectValue).length;\n    const num_shown = maxTagCount;\n    return num_selected - num_shown - (selectAllMode ? 1 : 0);\n  }, [maxTagCount, selectAllMode, selectValue]);\n  const customMaxTagPlaceholder = () => `+ ${omittedCount > 0 ? omittedCount : 1} ...`;\n  // We can't remove the + tag so when Select All\n  // is the only item omitted, we subtract one from maxTagCount\n  let actualMaxTagCount = maxTagCount;\n  if (actualMaxTagCount !== 'responsive' &&\n  omittedCount === 0 &&\n  selectAllMode) {\n    actualMaxTagCount -= 1;\n  }\n  const getPastedTextValue = useCallback((text) => {\n    const option = getOption(text, fullSelectOptions, true);\n    if (!option && !allowNewOptions) {\n      return undefined;\n    }\n    if (labelInValue) {\n      const value = {\n        label: text,\n        value: text\n      };\n      if (option) {\n        value.label = isObject(option) ? option.label : option;\n        value.value = isObject(option) ? option.value : option;\n      }\n      return value;\n    }\n    return option ? isObject(option) ? option.value : option : text;\n  }, [allowNewOptions, fullSelectOptions, labelInValue]);\n  const onPaste = (e) => {\n    const pastedText = e.clipboardData.getData('text');\n    if (isSingleMode) {\n      const value = getPastedTextValue(pastedText);\n      if (value) {\n        setSelectValue(value);\n      }\n    } else\n    {\n      const token = tokenSeparators.find((token) => pastedText.includes(token));\n      const array = token ? _uniq(pastedText.split(token)) : [pastedText];\n      const values = array.\n      map((item) => getPastedTextValue(item)).\n      filter((item) => item !== undefined);\n      if (labelInValue) {\n        setSelectValue((previous) => [\n        ...(previous || []),\n        ...values]\n        );\n      } else\n      {\n        setSelectValue((previous) => [\n        ...(previous || []),\n        ...values]\n        );\n      }\n    }\n    fireOnChange();\n  };\n  return ___EmotionJSX(StyledContainer, { headerPosition: headerPosition },\n  header && ___EmotionJSX(StyledHeader, { headerPosition: headerPosition }, header),\n  ___EmotionJSX(StyledSelect, _extends({ allowClear: !isLoading && allowClear, \"aria-label\": ariaLabel || name, autoClearSearchValue: autoClearSearchValue, dropdownRender: dropdownRender, filterOption: handleFilterOption, filterSort: sortComparatorWithSearch, getPopupContainer: getPopupContainer || ((triggerNode) => triggerNode.parentNode), headerPosition: headerPosition, labelInValue: labelInValue, maxTagCount: actualMaxTagCount, maxTagPlaceholder: customMaxTagPlaceholder, mode: mappedMode, notFoundContent: isLoading ? t('Loading...') : notFoundContent, onBlur: handleOnBlur, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange\n    // @ts-ignore\n    , onPaste: onPaste, onPopupScroll: undefined, onSearch: shouldShowSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, placeholder: placeholder, showSearch: shouldShowSearch, showArrow: true, tokenSeparators: tokenSeparators, value: selectValue, suffixIcon: getSuffixIcon(isLoading, shouldShowSearch, isDropdownVisible), menuItemSelectedIcon: invertSelection ? ___EmotionJSX(StyledStopOutlined, { iconSize: \"m\", \"aria-label\": \"stop\" }) : ___EmotionJSX(StyledCheckOutlined, { iconSize: \"m\", \"aria-label\": \"check\" }), options: shouldRenderChildrenOptions ? undefined : fullSelectOptions, oneLine: oneLine, tagRender: customTagRender }, props, { ref: ref }),\n  selectAllEnabled && ___EmotionJSX(Option, { id: \"select-all\", className: \"select-all\", key: SELECT_ALL_VALUE, value: SELECT_ALL_VALUE },\n  selectAllLabel()\n  ),\n  shouldRenderChildrenOptions &&\n  renderSelectOptions(fullSelectOptions)\n  )\n  );\n}, \"useState{[selectValue, setSelectValue](value)}\\nuseState{[inputValue, setInputValue]('')}\\nuseState{[isLoading, setIsLoading](loading)}\\nuseState{[isDropdownVisible, setIsDropdownVisible](false)}\\nuseState{[maxTagCount, setMaxTagCount](propsMaxTagCount ?? MAX_TAG_COUNT)}\\nuseState{[onChangeCount, setOnChangeCount](0)}\\nusePrevious{previousChangeCount}\\nuseCallback{fireOnChange}\\nuseEffect{}\\nuseCallback{sortSelectedFirst}\\nuseCallback{sortComparatorWithSearch}\\nuseMemo{initialOptions}\\nuseMemo{initialOptionsSorted}\\nuseState{[selectOptions, setSelectOptions](initialOptionsSorted)}\\nuseMemo{fullSelectOptions}\\nuseMemo{enabledOptions}\\nuseMemo{selectAllEligible}\\nuseMemo{selectAllEnabled}\\nuseMemo{selectAllMode}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseMemo{selectAllLabel}\\nuseCallback{handleOnChange}\\nuseEffect{}\\nuseMemo{shouldRenderChildrenOptions}\\nuseMemo{omittedCount}\\nuseCallback{getPastedTextValue}\", () => [usePrevious]));const _default =\nSelect;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Select, \"Select\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(_default, \"default\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/components/Select/Select.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["React","forwardRef","useEffect","useMemo","useState","useCallback","ensureIsArray","formatNumber","NumberFormats","t","usePrevious","AntdSelect","FAST_DEBOUNCE","getValue","hasOption","isLabeledValue","renderSelectOptions","sortSelectedFirstHelper","sortComparatorWithSearchHelper","handleFilterOptionHelper","dropDownRenderHelper","getSuffixIcon","SELECT_ALL_VALUE","selectAllOption","mapValues","mapOptions","hasCustomLabels","getOption","isObject","isEqual","utilsIsEqual","StyledCheckOutlined","StyledContainer","StyledHeader","StyledSelect","StyledStopOutlined","EMPTY_OPTIONS","MAX_TAG_COUNT","TOKEN_SEPARATORS","DEFAULT_SORT_COMPARATOR","customTagRender","jsx","___EmotionJSX","Select","__signature__","allowClear","allowNewOptions","allowSelectAll","ariaLabel","autoClearSearchValue","filterOption","header","headerPosition","helperText","invertSelection","labelInValue","loading","mode","name","notFoundContent","onBlur","onChange","onClear","onDropdownVisibleChange","onDeselect","onSearch","onSelect","optionFilterProps","options","placeholder","showSearch","sortComparator","tokenSeparators","value","getPopupContainer","oneLine","maxTagCount","propsMaxTagCount","props","ref","isSingleMode","shouldShowSearch","selectValue","setSelectValue","inputValue","setInputValue","isLoading","setIsLoading","isDropdownVisible","setIsDropdownVisible","setMaxTagCount","onChangeCount","setOnChangeCount","previousChangeCount","fireOnChange","mappedMode","undefined","Option","sortSelectedFirst","a","b","sortComparatorWithSearch","initialOptions","Array","isArray","slice","initialOptionsSorted","sort","selectOptions","setSelectOptions","fullSelectOptions","missingValues","filter","opt","map","label","String","result","length","concat","enabledOptions","option","disabled","selectAllEligible","selectAllEnabled","selectAllMode","handleOnSelect","selectedItem","valueChanged","previousState","array","clear","handleOnDeselect","element","isNewOption","handleOnSearch","_debounce","search","searchValue","trim","newOption","cleanSelectOptions","newOptions","cancel","handleFilterOption","handleOnDropdownVisibleChange","_isEqual","dropdownRender","originNode","handleClear","checkSelectAll","some","v","optionsToSelect","push","selectAllLabel","INTEGER","handleOnBlur","event","handleOnChange","values","newValues","val","set","Set","has","shouldRenderChildrenOptions","omittedCount","num_selected","num_shown","customMaxTagPlaceholder","actualMaxTagCount","getPastedTextValue","text","onPaste","e","pastedText","clipboardData","getData","token","find","includes","_uniq","split","item","previous","_extends","filterSort","triggerNode","parentNode","maxTagPlaceholder","onPopupScroll","showArrow","suffixIcon","menuItemSelectedIcon","iconSize","tagRender","id","className","key","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/src/components/Select/Select.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, {\n  forwardRef,\n  ReactElement,\n  RefObject,\n  useEffect,\n  useMemo,\n  useState,\n  useCallback,\n  ClipboardEvent,\n} from 'react';\nimport {\n  ensureIsArray,\n  formatNumber,\n  NumberFormats,\n  t,\n  usePrevious,\n} from '@superset-ui/core';\nimport AntdSelect, { LabeledValue as AntdLabeledValue } from 'antd/lib/select';\nimport { debounce, isEqual, uniq } from 'lodash';\nimport { FAST_DEBOUNCE } from 'src/constants';\nimport {\n  getValue,\n  hasOption,\n  isLabeledValue,\n  renderSelectOptions,\n  sortSelectedFirstHelper,\n  sortComparatorWithSearchHelper,\n  handleFilterOptionHelper,\n  dropDownRenderHelper,\n  getSuffixIcon,\n  SELECT_ALL_VALUE,\n  selectAllOption,\n  mapValues,\n  mapOptions,\n  hasCustomLabels,\n  getOption,\n  isObject,\n  isEqual as utilsIsEqual,\n} from './utils';\nimport { RawValue, SelectOptionsType, SelectProps } from './types';\nimport {\n  StyledCheckOutlined,\n  StyledContainer,\n  StyledHeader,\n  StyledSelect,\n  StyledStopOutlined,\n} from './styles';\nimport {\n  EMPTY_OPTIONS,\n  MAX_TAG_COUNT,\n  TOKEN_SEPARATORS,\n  DEFAULT_SORT_COMPARATOR,\n} from './constants';\nimport { customTagRender } from './CustomTag';\n\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst Select = forwardRef(\n  (\n    {\n      allowClear,\n      allowNewOptions = false,\n      allowSelectAll = true,\n      ariaLabel,\n      autoClearSearchValue = false,\n      filterOption = true,\n      header = null,\n      headerPosition = 'top',\n      helperText,\n      invertSelection = false,\n      labelInValue = false,\n      loading,\n      mode = 'single',\n      name,\n      notFoundContent,\n      onBlur,\n      onChange,\n      onClear,\n      onDropdownVisibleChange,\n      onDeselect,\n      onSearch,\n      onSelect,\n      optionFilterProps = ['label', 'value'],\n      options,\n      placeholder = t('Select ...'),\n      showSearch = true,\n      sortComparator = DEFAULT_SORT_COMPARATOR,\n      tokenSeparators = TOKEN_SEPARATORS,\n      value,\n      getPopupContainer,\n      oneLine,\n      maxTagCount: propsMaxTagCount,\n      ...props\n    }: SelectProps,\n    ref: RefObject<HTMLInputElement>,\n  ) => {\n    const isSingleMode = mode === 'single';\n    const shouldShowSearch = allowNewOptions ? true : showSearch;\n    const [selectValue, setSelectValue] = useState(value);\n    const [inputValue, setInputValue] = useState('');\n    const [isLoading, setIsLoading] = useState(loading);\n    const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n    const [maxTagCount, setMaxTagCount] = useState(\n      propsMaxTagCount ?? MAX_TAG_COUNT,\n    );\n    const [onChangeCount, setOnChangeCount] = useState(0);\n    const previousChangeCount = usePrevious(onChangeCount, 0);\n\n    const fireOnChange = useCallback(\n      () => setOnChangeCount(onChangeCount + 1),\n      [onChangeCount],\n    );\n\n    useEffect(() => {\n      if (oneLine) {\n        setMaxTagCount(isDropdownVisible ? 0 : 1);\n      }\n    }, [isDropdownVisible, oneLine]);\n\n    const mappedMode = isSingleMode ? undefined : 'multiple';\n\n    const { Option } = AntdSelect;\n\n    const sortSelectedFirst = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortSelectedFirstHelper(a, b, selectValue),\n      [selectValue],\n    );\n    const sortComparatorWithSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorWithSearchHelper(\n          a,\n          b,\n          inputValue,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [inputValue, sortComparator, sortSelectedFirst],\n    );\n\n    const initialOptions = useMemo(\n      () => (Array.isArray(options) ? options.slice() : EMPTY_OPTIONS),\n      [options],\n    );\n    const initialOptionsSorted = useMemo(\n      () => initialOptions.slice().sort(sortSelectedFirst),\n      [initialOptions, sortSelectedFirst],\n    );\n\n    const [selectOptions, setSelectOptions] =\n      useState<SelectOptionsType>(initialOptionsSorted);\n\n    // add selected values to options list if they are not in it\n    const fullSelectOptions = useMemo(() => {\n      const missingValues: SelectOptionsType = ensureIsArray(selectValue)\n        .filter(opt => !hasOption(getValue(opt), selectOptions))\n        .map(opt =>\n          isLabeledValue(opt) ? opt : { value: opt, label: String(opt) },\n        );\n      const result =\n        missingValues.length > 0\n          ? missingValues.concat(selectOptions)\n          : selectOptions;\n      return result.filter(opt => opt.value !== SELECT_ALL_VALUE);\n    }, [selectOptions, selectValue]);\n\n    const enabledOptions = useMemo(\n      () => fullSelectOptions.filter(option => !option.disabled),\n      [fullSelectOptions],\n    );\n\n    const selectAllEligible = useMemo(\n      () =>\n        fullSelectOptions.filter(\n          option => hasOption(option.value, selectValue) || !option.disabled,\n        ),\n      [fullSelectOptions, selectValue],\n    );\n\n    const selectAllEnabled = useMemo(\n      () =>\n        !isSingleMode &&\n        allowSelectAll &&\n        selectOptions.length > 0 &&\n        enabledOptions.length > 1 &&\n        !inputValue,\n      [\n        isSingleMode,\n        allowSelectAll,\n        selectOptions.length,\n        enabledOptions.length,\n        inputValue,\n      ],\n    );\n\n    const selectAllMode = useMemo(\n      () => ensureIsArray(selectValue).length === selectAllEligible.length + 1,\n      [selectValue, selectAllEligible],\n    );\n\n    const handleOnSelect: SelectProps['onSelect'] = (selectedItem, option) => {\n      if (isSingleMode) {\n        // on select is fired in single value mode if the same value is selected\n        const valueChanged = !utilsIsEqual(\n          selectedItem,\n          selectValue as RawValue | AntdLabeledValue,\n          'value',\n        );\n        setSelectValue(selectedItem);\n        if (valueChanged) {\n          fireOnChange();\n        }\n      } else {\n        setSelectValue(previousState => {\n          const array = ensureIsArray(previousState);\n          const value = getValue(selectedItem);\n          // Tokenized values can contain duplicated values\n          if (value === getValue(SELECT_ALL_VALUE)) {\n            if (isLabeledValue(selectedItem)) {\n              return [\n                ...selectAllEligible,\n                selectAllOption,\n              ] as AntdLabeledValue[];\n            }\n            return [\n              SELECT_ALL_VALUE,\n              ...selectAllEligible.map(opt => opt.value),\n            ] as AntdLabeledValue[];\n          }\n          if (!hasOption(value, array)) {\n            const result = [...array, selectedItem];\n            if (\n              result.length === selectAllEligible.length &&\n              selectAllEnabled\n            ) {\n              return isLabeledValue(selectedItem)\n                ? ([...result, selectAllOption] as AntdLabeledValue[])\n                : ([...result, SELECT_ALL_VALUE] as (string | number)[]);\n            }\n            return result as AntdLabeledValue[];\n          }\n          return previousState;\n        });\n        fireOnChange();\n      }\n      onSelect?.(selectedItem, option);\n    };\n\n    const clear = () => {\n      if (isSingleMode) {\n        setSelectValue(undefined);\n      } else {\n        setSelectValue(\n          fullSelectOptions\n            .filter(\n              option => option.disabled && hasOption(option.value, selectValue),\n            )\n            .map(option =>\n              labelInValue\n                ? { label: option.label, value: option.value }\n                : option.value,\n            ),\n        );\n      }\n      fireOnChange();\n    };\n\n    const handleOnDeselect: SelectProps['onDeselect'] = (value, option) => {\n      if (Array.isArray(selectValue)) {\n        if (getValue(value) === getValue(SELECT_ALL_VALUE)) {\n          clear();\n        } else {\n          let array = selectValue as AntdLabeledValue[];\n          array = array.filter(\n            element => getValue(element) !== getValue(value),\n          );\n          // if this was not a new item, deselect select all option\n          if (selectAllMode && !option.isNewOption) {\n            array = array.filter(\n              element => getValue(element) !== SELECT_ALL_VALUE,\n            );\n          }\n          setSelectValue(array);\n\n          // removes new option\n          if (option.isNewOption) {\n            setSelectOptions(\n              fullSelectOptions.filter(\n                option => getValue(option.value) !== getValue(value),\n              ),\n            );\n          }\n        }\n      }\n      fireOnChange();\n      onDeselect?.(value, option);\n    };\n\n    const handleOnSearch = debounce((search: string) => {\n      const searchValue = search.trim();\n      if (allowNewOptions) {\n        const newOption = searchValue &&\n          !hasOption(searchValue, fullSelectOptions, true) && {\n            label: searchValue,\n            value: searchValue,\n            isNewOption: true,\n          };\n        const cleanSelectOptions = ensureIsArray(fullSelectOptions).filter(\n          opt => !opt.isNewOption || hasOption(opt.value, selectValue),\n        );\n        const newOptions = newOption\n          ? [newOption, ...cleanSelectOptions]\n          : cleanSelectOptions;\n        setSelectOptions(newOptions);\n      }\n      setInputValue(searchValue);\n      onSearch?.(searchValue);\n    }, FAST_DEBOUNCE);\n\n    useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n\n    const handleFilterOption = (search: string, option: AntdLabeledValue) =>\n      handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n\n    const handleOnDropdownVisibleChange = (isDropdownVisible: boolean) => {\n      setIsDropdownVisible(isDropdownVisible);\n\n      // if no search input value, force sort options because it won't be sorted by\n      // `filterSort`.\n      if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n        if (!isEqual(initialOptionsSorted, selectOptions)) {\n          setSelectOptions(initialOptionsSorted);\n        }\n      }\n      if (onDropdownVisibleChange) {\n        onDropdownVisibleChange(isDropdownVisible);\n      }\n    };\n\n    const dropdownRender = (\n      originNode: ReactElement & { ref?: RefObject<HTMLElement> },\n    ) =>\n      dropDownRenderHelper(\n        originNode,\n        isDropdownVisible,\n        isLoading,\n        fullSelectOptions.length,\n        helperText,\n      );\n\n    const handleClear = () => {\n      clear();\n      if (onClear) {\n        onClear();\n      }\n    };\n\n    useEffect(() => {\n      // when `options` list is updated from component prop, reset states\n      setSelectOptions(initialOptions);\n    }, [initialOptions]);\n\n    useEffect(() => {\n      if (loading !== undefined && loading !== isLoading) {\n        setIsLoading(loading);\n      }\n    }, [isLoading, loading]);\n\n    useEffect(() => {\n      setSelectValue(value);\n    }, [value]);\n\n    useEffect(() => {\n      // if all values are selected, add select all to value\n      if (\n        selectAllEnabled &&\n        ensureIsArray(value).length === selectAllEligible.length\n      ) {\n        setSelectValue(\n          labelInValue\n            ? ([...ensureIsArray(value), selectAllOption] as AntdLabeledValue[])\n            : ([...ensureIsArray(value), SELECT_ALL_VALUE] as RawValue[]),\n        );\n      }\n    }, [labelInValue, selectAllEligible.length, selectAllEnabled, value]);\n\n    useEffect(() => {\n      const checkSelectAll = ensureIsArray(selectValue).some(\n        v => getValue(v) === SELECT_ALL_VALUE,\n      );\n      if (checkSelectAll && !selectAllMode) {\n        const optionsToSelect = selectAllEligible.map(option =>\n          labelInValue ? option : option.value,\n        );\n        optionsToSelect.push(labelInValue ? selectAllOption : SELECT_ALL_VALUE);\n        setSelectValue(optionsToSelect);\n        fireOnChange();\n      }\n    }, [\n      selectValue,\n      selectAllMode,\n      labelInValue,\n      selectAllEligible,\n      fireOnChange,\n    ]);\n\n    const selectAllLabel = useMemo(\n      () => () =>\n        // TODO: localize\n        `${SELECT_ALL_VALUE} (${formatNumber(\n          NumberFormats.INTEGER,\n          selectAllEligible.length,\n        )})`,\n      [selectAllEligible],\n    );\n\n    const handleOnBlur = (event: React.FocusEvent<HTMLElement>) => {\n      setInputValue('');\n      onBlur?.(event);\n    };\n\n    const handleOnChange = useCallback(\n      (values: any, options: any) => {\n        // intercept onChange call to handle the select all case\n        // if the \"select all\" option is selected, we want to send all options to the onChange,\n        // otherwise we want to remove\n        let newValues = values;\n        let newOptions = options;\n        if (!isSingleMode) {\n          if (\n            ensureIsArray(newValues).some(\n              val => getValue(val) === SELECT_ALL_VALUE,\n            )\n          ) {\n            // send all options to onchange if all are not currently there\n            if (!selectAllMode) {\n              newValues = mapValues(selectAllEligible, labelInValue);\n              newOptions = mapOptions(selectAllEligible);\n            } else {\n              newValues = ensureIsArray(values).filter(\n                (val: any) => getValue(val) !== SELECT_ALL_VALUE,\n              );\n            }\n          } else if (\n            ensureIsArray(values).length === selectAllEligible.length &&\n            selectAllMode\n          ) {\n            const array = selectAllEligible.filter(\n              option => hasOption(option.value, selectValue) && option.disabled,\n            );\n            newValues = mapValues(array, labelInValue);\n            newOptions = mapOptions(array);\n          }\n        }\n        onChange?.(newValues, newOptions);\n      },\n      [\n        isSingleMode,\n        labelInValue,\n        onChange,\n        selectAllEligible,\n        selectAllMode,\n        selectValue,\n      ],\n    );\n\n    useEffect(() => {\n      if (onChangeCount !== previousChangeCount) {\n        const array = ensureIsArray(selectValue);\n        const set = new Set(array.map(getValue));\n        const options = mapOptions(\n          fullSelectOptions.filter(opt => set.has(opt.value)),\n        );\n        if (isSingleMode) {\n          handleOnChange(selectValue, selectValue ? options[0] : undefined);\n        } else {\n          handleOnChange(array, options);\n        }\n      }\n    }, [\n      fullSelectOptions,\n      handleOnChange,\n      isSingleMode,\n      onChange,\n      onChangeCount,\n      previousChangeCount,\n      selectValue,\n    ]);\n\n    const shouldRenderChildrenOptions = useMemo(\n      () => selectAllEnabled || hasCustomLabels(options),\n      [selectAllEnabled, options],\n    );\n\n    const omittedCount = useMemo(() => {\n      const num_selected = ensureIsArray(selectValue).length;\n      const num_shown = maxTagCount as number;\n      return num_selected - num_shown - (selectAllMode ? 1 : 0);\n    }, [maxTagCount, selectAllMode, selectValue]);\n\n    const customMaxTagPlaceholder = () =>\n      `+ ${omittedCount > 0 ? omittedCount : 1} ...`;\n\n    // We can't remove the + tag so when Select All\n    // is the only item omitted, we subtract one from maxTagCount\n    let actualMaxTagCount = maxTagCount;\n    if (\n      actualMaxTagCount !== 'responsive' &&\n      omittedCount === 0 &&\n      selectAllMode\n    ) {\n      actualMaxTagCount -= 1;\n    }\n\n    const getPastedTextValue = useCallback(\n      (text: string) => {\n        const option = getOption(text, fullSelectOptions, true);\n        if (!option && !allowNewOptions) {\n          return undefined;\n        }\n        if (labelInValue) {\n          const value: AntdLabeledValue = {\n            label: text,\n            value: text,\n          };\n          if (option) {\n            value.label = isObject(option) ? option.label : option;\n            value.value = isObject(option) ? option.value! : option;\n          }\n          return value;\n        }\n        return option ? (isObject(option) ? option.value! : option) : text;\n      },\n      [allowNewOptions, fullSelectOptions, labelInValue],\n    );\n\n    const onPaste = (e: ClipboardEvent<HTMLInputElement>) => {\n      const pastedText = e.clipboardData.getData('text');\n      if (isSingleMode) {\n        const value = getPastedTextValue(pastedText);\n        if (value) {\n          setSelectValue(value);\n        }\n      } else {\n        const token = tokenSeparators.find(token => pastedText.includes(token));\n        const array = token ? uniq(pastedText.split(token)) : [pastedText];\n        const values = array\n          .map(item => getPastedTextValue(item))\n          .filter(item => item !== undefined);\n        if (labelInValue) {\n          setSelectValue(previous => [\n            ...((previous || []) as AntdLabeledValue[]),\n            ...(values as AntdLabeledValue[]),\n          ]);\n        } else {\n          setSelectValue(previous => [\n            ...((previous || []) as string[]),\n            ...(values as string[]),\n          ]);\n        }\n      }\n      fireOnChange();\n    };\n\n    return (\n      <StyledContainer headerPosition={headerPosition}>\n        {header && (\n          <StyledHeader headerPosition={headerPosition}>{header}</StyledHeader>\n        )}\n        <StyledSelect\n          allowClear={!isLoading && allowClear}\n          aria-label={ariaLabel || name}\n          autoClearSearchValue={autoClearSearchValue}\n          dropdownRender={dropdownRender}\n          filterOption={handleFilterOption}\n          filterSort={sortComparatorWithSearch}\n          getPopupContainer={\n            getPopupContainer || (triggerNode => triggerNode.parentNode)\n          }\n          headerPosition={headerPosition}\n          labelInValue={labelInValue}\n          maxTagCount={actualMaxTagCount}\n          maxTagPlaceholder={customMaxTagPlaceholder}\n          mode={mappedMode}\n          notFoundContent={isLoading ? t('Loading...') : notFoundContent}\n          onBlur={handleOnBlur}\n          onDeselect={handleOnDeselect}\n          onDropdownVisibleChange={handleOnDropdownVisibleChange}\n          // @ts-ignore\n          onPaste={onPaste}\n          onPopupScroll={undefined}\n          onSearch={shouldShowSearch ? handleOnSearch : undefined}\n          onSelect={handleOnSelect}\n          onClear={handleClear}\n          placeholder={placeholder}\n          showSearch={shouldShowSearch}\n          showArrow\n          tokenSeparators={tokenSeparators}\n          value={selectValue}\n          suffixIcon={getSuffixIcon(\n            isLoading,\n            shouldShowSearch,\n            isDropdownVisible,\n          )}\n          menuItemSelectedIcon={\n            invertSelection ? (\n              <StyledStopOutlined iconSize=\"m\" aria-label=\"stop\" />\n            ) : (\n              <StyledCheckOutlined iconSize=\"m\" aria-label=\"check\" />\n            )\n          }\n          options={shouldRenderChildrenOptions ? undefined : fullSelectOptions}\n          oneLine={oneLine}\n          tagRender={customTagRender}\n          {...props}\n          ref={ref}\n        >\n          {selectAllEnabled && (\n            <Option\n              id=\"select-all\"\n              className=\"select-all\"\n              key={SELECT_ALL_VALUE}\n              value={SELECT_ALL_VALUE}\n            >\n              {selectAllLabel()}\n            </Option>\n          )}\n          {shouldRenderChildrenOptions &&\n            renderSelectOptions(fullSelectOptions)}\n        </StyledSelect>\n      </StyledContainer>\n    );\n  },\n);\n\nexport default Select;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}