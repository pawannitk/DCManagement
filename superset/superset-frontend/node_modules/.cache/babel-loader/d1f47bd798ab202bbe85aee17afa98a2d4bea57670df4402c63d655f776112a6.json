{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { LayerExtension } from '@deck.gl/core';\nimport { TerrainEffect } from './terrain-effect';\nimport { terrainModule } from './shader-module';\nconst defaultProps = {\n  terrainDrawMode: undefined\n};\nexport default class TerrainExtension extends LayerExtension {\n  getShaders() {\n    return {\n      modules: [terrainModule]\n    };\n  }\n\n  initializeState() {\n    var _this$context$deck;\n\n    (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new TerrainEffect());\n  }\n\n  updateState(params) {\n    const {\n      props,\n      oldProps\n    } = params;\n\n    if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && props.extruded === oldProps.extruded) {\n      return;\n    }\n\n    let {\n      terrainDrawMode\n    } = props;\n\n    if (!terrainDrawMode) {\n      var _this$getAttributeMan;\n\n      const is3d = this.props.extruded;\n      const attributes = (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.attributes;\n      const hasAnchor = attributes && 'instancePositions' in attributes;\n      terrainDrawMode = is3d || hasAnchor ? 'offset' : 'drape';\n    }\n\n    this.setState({\n      terrainDrawMode\n    });\n  }\n\n  onNeedsRedraw() {\n    const state = this.state;\n\n    if (state.terrainDrawMode === 'drape') {\n      state.terrainCoverNeedsRedraw = true;\n    }\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\n_defineProperty(TerrainExtension, \"defaultProps\", defaultProps);\n\n_defineProperty(TerrainExtension, \"extensionName\", 'TerrainExtension');;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(defaultProps, \"defaultProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-extension.js\");reactHotLoader.register(TerrainExtension, \"TerrainExtension\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-extension.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["LayerExtension","TerrainEffect","terrainModule","defaultProps","terrainDrawMode","undefined","TerrainExtension","getShaders","modules","initializeState","_this$context$deck","context","deck","_addDefaultEffect","updateState","params","props","oldProps","state","extruded","_this$getAttributeMan","is3d","attributes","getAttributeManager","hasAnchor","setState","onNeedsRedraw","terrainCoverNeedsRedraw","__reactstandin__regenerateByEval","key","code","eval","reactHotLoader","register","leaveModule","reactHotLoaderGlobal","module"],"sources":["../../../src/terrain/terrain-extension.ts"],"sourcesContent":["import {LayerExtension, UpdateParameters} from '@deck.gl/core';\nimport {TerrainEffect} from './terrain-effect';\nimport {terrainModule} from './shader-module';\n\nimport type {Layer} from '@deck.gl/core';\n\nconst defaultProps = {\n  terrainDrawMode: undefined\n};\n\nexport type TerrainExtensionProps = {\n  /**\n   * controls whether an object is drawn over the terrain surface by its anchor (usually defined by an accessor called `getPosition`, e.g. icon, scatterplot) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  terrainDrawMode?: 'offset' | 'drape';\n};\n\ntype TerrainExtensionState = {\n  /** Resolved fitting mode */\n  terrainDrawMode: 'offset' | 'drape';\n  /** Set when a layer is flagged as needs redraw */\n  terrainCoverNeedsRedraw: boolean;\n};\n\n/** Allows layers to show/hide objects by a geofence. */\nexport default class TerrainExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'TerrainExtension';\n\n  getShaders(this: Layer<TerrainExtensionProps>): any {\n    return {\n      modules: [terrainModule]\n    };\n  }\n\n  initializeState(this: Layer<TerrainExtensionProps>) {\n    this.context.deck?._addDefaultEffect(new TerrainEffect());\n  }\n\n  updateState(\n    this: Layer<TerrainExtensionProps>,\n    params: UpdateParameters<Layer<TerrainExtensionProps>>\n  ) {\n    const {props, oldProps} = params;\n\n    if (\n      this.state.terrainDrawMode &&\n      props.terrainDrawMode === oldProps.terrainDrawMode &&\n      // @ts-ignore `extruded` may not exist in props\n      props.extruded === oldProps.extruded\n    ) {\n      return;\n    }\n\n    let {terrainDrawMode} = props;\n    if (!terrainDrawMode) {\n      // props.extruded is used as an indication that the layer is 2.5D\n      // @ts-ignore `extruded` may not exist in props\n      const is3d = this.props.extruded as boolean;\n      const attributes = this.getAttributeManager()?.attributes;\n      const hasAnchor = attributes && 'instancePositions' in attributes;\n      terrainDrawMode = is3d || hasAnchor ? 'offset' : 'drape';\n    }\n    this.setState({terrainDrawMode});\n  }\n\n  onNeedsRedraw(this: Layer<{}>): void {\n    const state = this.state as TerrainExtensionState;\n    if (state.terrainDrawMode === 'drape') {\n      state.terrainCoverNeedsRedraw = true;\n    }\n  }\n}\n"],"mappings":";AAAA,SAAQA,cAAR,QAA+C,eAA/C;AACA,SAAQC,aAAR,QAA4B,kBAA5B;AACA,SAAQC,aAAR,QAA4B,iBAA5B;AAIA,MAAMC,YAAY,GAAG;EACnBC,eAAe,EAAEC;AADE,CAArB;AAoBA,eAAe,MAAMC,gBAAN,SAA+BN,cAA/B,CAA8C;EAI3DO,UAAUA,CAAA,EAA0C;IAClD,OAAO;MACLC,OAAO,EAAE,CAACN,aAAD;IADJ,CAAP;EAGD;;EAEDO,eAAeA,CAAA,EAAqC;IAAA,IAAAC,kBAAA;;IAClD,CAAAA,kBAAA,QAAKC,OAAL,CAAaC,IAAb,cAAAF,kBAAA,uBAAAA,kBAAA,CAAmBG,iBAAnB,CAAqC,IAAIZ,aAAJ,EAArC;EACD;;EAEDa,WAAWA,CAETC,MAFS,EAGT;IACA,MAAM;MAACC,KAAD;MAAQC;IAAR,IAAoBF,MAA1B;;IAEA,IACE,KAAKG,KAAL,CAAWd,eAAX,IACAY,KAAK,CAACZ,eAAN,KAA0Ba,QAAQ,CAACb,eADnC,IAGAY,KAAK,CAACG,QAAN,KAAmBF,QAAQ,CAACE,QAJ9B,EAKE;MACA;IACD;;IAED,IAAI;MAACf;IAAD,IAAoBY,KAAxB;;IACA,IAAI,CAACZ,eAAL,EAAsB;MAAA,IAAAgB,qBAAA;;MAGpB,MAAMC,IAAI,GAAG,KAAKL,KAAL,CAAWG,QAAxB;MACA,MAAMG,UAAU,IAAAF,qBAAA,GAAG,KAAKG,mBAAL,EAAH,cAAAH,qBAAA,uBAAGA,qBAAA,CAA4BE,UAA/C;MACA,MAAME,SAAS,GAAGF,UAAU,IAAI,uBAAuBA,UAAvD;MACAlB,eAAe,GAAGiB,IAAI,IAAIG,SAAR,GAAoB,QAApB,GAA+B,OAAjD;IACD;;IACD,KAAKC,QAAL,CAAc;MAACrB;IAAD,CAAd;EACD;;EAEDsB,aAAaA,CAAA,EAAwB;IACnC,MAAMR,KAAK,GAAG,KAAKA,KAAnB;;IACA,IAAIA,KAAK,CAACd,eAAN,KAA0B,OAA9B,EAAuC;MACrCc,KAAK,CAACS,uBAAN,GAAgC,IAAhC;IACD;EACF;EAAAC,iCAAAC,GAAA,EAAAC,IAAA;IAAA,KAAAD,GAAA,IAAAE,IAAA,CAAAD,IAAA,GA9C0D;;gBAAxCxB,gB,kBACGH,Y;;gBADHG,gB,mBAEI,kB,mLAtBnBH,YAAY,sLAAA6B,cAAA,CAAAC,QAAA,CAoBG3B,gBAAN,kNAAA4B,WAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAD,WAAA,GAAA7B,SAAA,CAAA6B,WAAA,IAAAA,WAAA,CAAAE,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}