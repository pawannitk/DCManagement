{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n  ),\n  zoom: PropTypes.number\n};\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: (location) => [location[0], location[1]],\n  renderWhileDragging: true\n};\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options = {}) {\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false\n    } = options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw({ width, height, ctx, isDragging, project }) {\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom\n    } = this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n          location.properties,\n          aggregation\n        );\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter((v) => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n        roundDecimal(pixel[0], 1),\n        roundDecimal(pixel[1], 1)];\n\n\n        if (\n        pixelRounded[0] + radius >= 0 &&\n        pixelRounded[0] - radius < width &&\n        pixelRounded[1] + radius >= 0 &&\n        pixelRounded[1] - radius < height)\n        {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n              (clusterLabel / maxLabel) ** 0.5 * radius,\n              1\n            );\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n              x,\n              y,\n              scaledRadius,\n              x,\n              y,\n              0\n            );\n\n            gradient.addColorStop(\n              1,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`\n            );\n            gradient.addColorStop(\n              0,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`\n            );\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              scaledRadius,\n              0,\n              Math.PI * 2\n            );\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true\n              });\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n            radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                  pointRadius * MILES_PER_KM,\n                  pointLatitude,\n                  zoom\n                );\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric)) ?\n              roundDecimal(pointMetric, 2) :\n              pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              roundDecimal(pointRadius, 1),\n              0,\n              Math.PI * 2\n            );\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false\n              });\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return ___EmotionJSX(CanvasOverlay, { redraw: this.redraw });\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;const _default =\n\nScatterPlotGlowOverlay;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(propTypes, \"propTypes\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");reactHotLoader.register(defaultProps, \"defaultProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");reactHotLoader.register(computeClusterLabel, \"computeClusterLabel\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");reactHotLoader.register(ScatterPlotGlowOverlay, \"ScatterPlotGlowOverlay\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");reactHotLoader.register(_default, \"default\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["PropTypes","React","CanvasOverlay","kmToPixels","MILES_PER_KM","roundDecimal","luminanceFromRGB","jsx","___EmotionJSX","propTypes","aggregation","string","compositeOperation","dotRadius","number","lngLatAccessor","func","locations","arrayOf","object","isRequired","pointRadiusUnit","renderWhileDragging","bool","rgb","oneOfType","zoom","defaultProps","location","computeClusterLabel","properties","count","point_count","sum","mean","Math","round","squaredSum","variance","sqrt","ScatterPlotGlowOverlay","PureComponent","constructor","props","redraw","bind","drawText","ctx","pixel","options","IS_DARK_THRESHOLD","fontHeight","label","radius","shadow","maxWidth","luminance","globalCompositeOperation","fillStyle","font","textAlign","textBaseline","shadowBlur","shadowColor","textWidth","measureText","width","scale","fillText","height","isDragging","project","clusterLabelMap","forEach","i","cluster","maxLabel","max","filter","v","Number","isNaN","clearRect","_forEach","pixelRounded","beginPath","clusterLabel","scaledRadius","x","y","gradient","createRadialGradient","addColorStop","arc","PI","fill","isFinite","parseFloat","defaultRadius","radiusProperty","pointMetric","metric","pointRadius","pointLabel","pointLatitude","undefined","render","__reactstandin__regenerateByEval","key","code","eval","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  zoom: PropTypes.number,\n};\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: location => [location[0], location[1]],\n  renderWhileDragging: true,\n};\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options = {}) {\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false,\n    } = options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw({ width, height, ctx, isDragging, project }) {\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom,\n    } = this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n          location.properties,\n          aggregation,\n        );\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter(v => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n          roundDecimal(pixel[0], 1),\n          roundDecimal(pixel[1], 1),\n        ];\n\n        if (\n          pixelRounded[0] + radius >= 0 &&\n          pixelRounded[0] - radius < width &&\n          pixelRounded[1] + radius >= 0 &&\n          pixelRounded[1] - radius < height\n        ) {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n              (clusterLabel / maxLabel) ** 0.5 * radius,\n              1,\n            );\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n              x,\n              y,\n              scaledRadius,\n              x,\n              y,\n              0,\n            );\n\n            gradient.addColorStop(\n              1,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`,\n            );\n            gradient.addColorStop(\n              0,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`,\n            );\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              scaledRadius,\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true,\n              });\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n              radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                  pointRadius * MILES_PER_KM,\n                  pointLatitude,\n                  zoom,\n                );\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric))\n                ? roundDecimal(pointMetric, 2)\n                : pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              roundDecimal(pointRadius, 1),\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false,\n              });\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return <CanvasOverlay redraw={this.redraw} />;\n  }\n}\n\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;\n\nexport default ScatterPlotGlowOverlay;\n"],"mappings":"wSAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,SAAS,MAAM,YAAY;AAClC,OAAOC,KAAK,MAAM,OAAO;AACzB,SAASC,aAAa,QAAQ,cAAc;AAC5C,SAASC,UAAU,EAAEC,YAAY,QAAQ,aAAa;AACtD,OAAOC,YAAY,MAAM,sBAAsB;AAC/C,OAAOC,gBAAgB,MAAM,0BAA0B;AACvD,OAAO,8BAA8B,CAAC,SAAAC,GAAA,IAAAC,aAAA;;AAEtC,MAAMC,SAAS,GAAG;EAChBC,WAAW,EAAEV,SAAS,CAACW,MAAM;EAC7BC,kBAAkB,EAAEZ,SAAS,CAACW,MAAM;EACpCE,SAAS,EAAEb,SAAS,CAACc,MAAM;EAC3BC,cAAc,EAAEf,SAAS,CAACgB,IAAI;EAC9BC,SAAS,EAAEjB,SAAS,CAACkB,OAAO,CAAClB,SAAS,CAACmB,MAAM,CAAC,CAACC,UAAU;EACzDC,eAAe,EAAErB,SAAS,CAACW,MAAM;EACjCW,mBAAmB,EAAEtB,SAAS,CAACuB,IAAI;EACnCC,GAAG,EAAExB,SAAS,CAACkB,OAAO;IACpBlB,SAAS,CAACyB,SAAS,CAAC,CAACzB,SAAS,CAACW,MAAM,EAAEX,SAAS,CAACc,MAAM,CAAC;EAC1D,CAAC;EACDY,IAAI,EAAE1B,SAAS,CAACc;AAClB,CAAC;;AAED,MAAMa,YAAY,GAAG;EACnB;EACAf,kBAAkB,EAAE,aAAa;EACjCC,SAAS,EAAE,CAAC;EACZE,cAAc,EAAEA,CAAAa,QAAQ,KAAI,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;EACtDN,mBAAmB,EAAE;AACvB,CAAC;;AAED,MAAMO,mBAAmB,GAAGA,CAACC,UAAU,EAAEpB,WAAW,KAAK;EACvD,MAAMqB,KAAK,GAAGD,UAAU,CAACE,WAAW;EACpC,IAAI,CAACtB,WAAW,EAAE;IAChB,OAAOqB,KAAK;EACd;EACA,IAAIrB,WAAW,KAAK,KAAK,IAAIA,WAAW,KAAK,KAAK,IAAIA,WAAW,KAAK,KAAK,EAAE;IAC3E,OAAOoB,UAAU,CAACpB,WAAW,CAAC;EAChC;EACA,MAAM,EAAEuB,GAAG,CAAC,CAAC,GAAGH,UAAU;EAC1B,MAAMI,IAAI,GAAGD,GAAG,GAAGF,KAAK;EACxB,IAAIrB,WAAW,KAAK,MAAM,EAAE;IAC1B,OAAOyB,IAAI,CAACC,KAAK,CAAC,GAAG,GAAGF,IAAI,CAAC,GAAG,GAAG;EACrC;EACA,MAAM,EAAEG,UAAU,CAAC,CAAC,GAAGP,UAAU;EACjC,MAAMQ,QAAQ,GAAGD,UAAU,GAAGN,KAAK,GAAG,CAACE,GAAG,GAAGF,KAAK,KAAK,CAAC;EACxD,IAAIrB,WAAW,KAAK,KAAK,EAAE;IACzB,OAAOyB,IAAI,CAACC,KAAK,CAAC,GAAG,GAAGE,QAAQ,CAAC,GAAG,GAAG;EACzC;EACA,IAAI5B,WAAW,KAAK,OAAO,EAAE;IAC3B,OAAOyB,IAAI,CAACC,KAAK,CAAC,GAAG,GAAGD,IAAI,CAACI,IAAI,CAACD,QAAQ,CAAC,CAAC,GAAG,GAAG;EACpD;;EAEA;EACA,OAAOP,KAAK;AACd,CAAC;;AAED,MAAMS,sBAAsB,SAASvC,KAAK,CAACwC,aAAa,CAAC;EACvDC,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;IACZ,IAAI,CAACC,MAAM,GAAG,IAAI,CAACA,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC;EACtC;;EAEAC,QAAQA,CAACC,GAAG,EAAEC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACjC,MAAMC,iBAAiB,GAAG,GAAG;IAC7B,MAAM;MACJC,UAAU,GAAG,CAAC;MACdC,KAAK,GAAG,EAAE;MACVC,MAAM,GAAG,CAAC;MACV7B,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACf8B,MAAM,GAAG;IACX,CAAC,GAAGL,OAAO;IACX,MAAMM,QAAQ,GAAGF,MAAM,GAAG,GAAG;IAC7B,MAAMG,SAAS,GAAGlD,gBAAgB,CAACkB,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;;IAE1DuB,GAAG,CAACU,wBAAwB,GAAG,aAAa;IAC5CV,GAAG,CAACW,SAAS,GAAGF,SAAS,IAAIN,iBAAiB,GAAG,OAAO,GAAG,OAAO;IAClEH,GAAG,CAACY,IAAI,GAAI,GAAER,UAAW,eAAc;IACvCJ,GAAG,CAACa,SAAS,GAAG,QAAQ;IACxBb,GAAG,CAACc,YAAY,GAAG,QAAQ;IAC3B,IAAIP,MAAM,EAAE;MACVP,GAAG,CAACe,UAAU,GAAG,EAAE;MACnBf,GAAG,CAACgB,WAAW,GAAGP,SAAS,IAAIN,iBAAiB,GAAG,OAAO,GAAG,EAAE;IACjE;;IAEA,MAAMc,SAAS,GAAGjB,GAAG,CAACkB,WAAW,CAACb,KAAK,CAAC,CAACc,KAAK;IAC9C,IAAIF,SAAS,GAAGT,QAAQ,EAAE;MACxB,MAAMY,KAAK,GAAGhB,UAAU,GAAGa,SAAS;MACpCjB,GAAG,CAACY,IAAI,GAAI,GAAEQ,KAAK,GAAGZ,QAAS,eAAc;IAC/C;;IAEA,MAAM,EAAE3C,kBAAkB,CAAC,CAAC,GAAG,IAAI,CAAC+B,KAAK;;IAEzCI,GAAG,CAACqB,QAAQ,CAAChB,KAAK,EAAEJ,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;IACvCD,GAAG,CAACU,wBAAwB,GAAG7C,kBAAkB;IACjDmC,GAAG,CAACe,UAAU,GAAG,CAAC;IAClBf,GAAG,CAACgB,WAAW,GAAG,EAAE;EACtB;;EAEA;EACAnB,MAAMA,CAAC,EAAEsB,KAAK,EAAEG,MAAM,EAAEtB,GAAG,EAAEuB,UAAU,EAAEC,OAAO,CAAC,CAAC,EAAE;IAClD,MAAM;MACJ7D,WAAW;MACXE,kBAAkB;MAClBC,SAAS;MACTE,cAAc;MACdE,SAAS;MACTI,eAAe;MACfC,mBAAmB;MACnBE,GAAG;MACHE;IACF,CAAC,GAAG,IAAI,CAACiB,KAAK;;IAEd,MAAMU,MAAM,GAAGxC,SAAS;IACxB,MAAM2D,eAAe,GAAG,EAAE;;IAE1BvD,SAAS,CAACwD,OAAO,CAAC,CAAC7C,QAAQ,EAAE8C,CAAC,KAAK;MACjC,IAAI9C,QAAQ,CAACE,UAAU,CAAC6C,OAAO,EAAE;QAC/BH,eAAe,CAACE,CAAC,CAAC,GAAG7C,mBAAmB;UACtCD,QAAQ,CAACE,UAAU;UACnBpB;QACF,CAAC;MACH;IACF,CAAC,EAAE,IAAI,CAAC;;IAER,MAAMkE,QAAQ,GAAGzC,IAAI,CAAC0C,GAAG,CAAC,GAAGL,eAAe,CAACM,MAAM,CAAC,CAAAC,CAAC,KAAI,CAACC,MAAM,CAACC,KAAK,CAACF,CAAC,CAAC,CAAC,CAAC;;IAE3EhC,GAAG,CAACmC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEhB,KAAK,EAAEG,MAAM,CAAC;IAClCtB,GAAG,CAACU,wBAAwB,GAAG7C,kBAAkB;;IAEjD,IAAI,CAACU,mBAAmB,IAAI,CAACgD,UAAU,KAAKrD,SAAS,EAAE;MACrDA,SAAS,CAACwD,OAAO,CAAC,SAASU,QAAQA,CAACvD,QAAQ,EAAE8C,CAAC,EAAE;QAC/C,MAAM1B,KAAK,GAAGuB,OAAO,CAACxD,cAAc,CAACa,QAAQ,CAAC,CAAC;QAC/C,MAAMwD,YAAY,GAAG;QACnB/E,YAAY,CAAC2C,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QACzB3C,YAAY,CAAC2C,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAC1B;;;QAED;QACEoC,YAAY,CAAC,CAAC,CAAC,GAAG/B,MAAM,IAAI,CAAC;QAC7B+B,YAAY,CAAC,CAAC,CAAC,GAAG/B,MAAM,GAAGa,KAAK;QAChCkB,YAAY,CAAC,CAAC,CAAC,GAAG/B,MAAM,IAAI,CAAC;QAC7B+B,YAAY,CAAC,CAAC,CAAC,GAAG/B,MAAM,GAAGgB,MAAM;QACjC;UACAtB,GAAG,CAACsC,SAAS,CAAC,CAAC;UACf,IAAIzD,QAAQ,CAACE,UAAU,CAAC6C,OAAO,EAAE;YAC/B,IAAIW,YAAY,GAAGd,eAAe,CAACE,CAAC,CAAC;YACrC,MAAMa,YAAY,GAAGlF,YAAY;cAC/B,CAACiF,YAAY,GAAGV,QAAQ,KAAK,GAAG,GAAGvB,MAAM;cACzC;YACF,CAAC;YACD,MAAMF,UAAU,GAAG9C,YAAY,CAACkF,YAAY,GAAG,GAAG,EAAE,CAAC,CAAC;YACtD,MAAM,CAACC,CAAC,EAAEC,CAAC,CAAC,GAAGL,YAAY;YAC3B,MAAMM,QAAQ,GAAG3C,GAAG,CAAC4C,oBAAoB;cACvCH,CAAC;cACDC,CAAC;cACDF,YAAY;cACZC,CAAC;cACDC,CAAC;cACD;YACF,CAAC;;YAEDC,QAAQ,CAACE,YAAY;cACnB,CAAC;cACA,QAAOpE,GAAG,CAAC,CAAC,CAAE,KAAIA,GAAG,CAAC,CAAC,CAAE,KAAIA,GAAG,CAAC,CAAC,CAAE;YACvC,CAAC;YACDkE,QAAQ,CAACE,YAAY;cACnB,CAAC;cACA,QAAOpE,GAAG,CAAC,CAAC,CAAE,KAAIA,GAAG,CAAC,CAAC,CAAE,KAAIA,GAAG,CAAC,CAAC,CAAE;YACvC,CAAC;YACDuB,GAAG,CAAC8C,GAAG;cACLT,YAAY,CAAC,CAAC,CAAC;cACfA,YAAY,CAAC,CAAC,CAAC;cACfG,YAAY;cACZ,CAAC;cACDpD,IAAI,CAAC2D,EAAE,GAAG;YACZ,CAAC;YACD/C,GAAG,CAACW,SAAS,GAAGgC,QAAQ;YACxB3C,GAAG,CAACgD,IAAI,CAAC,CAAC;;YAEV,IAAIf,MAAM,CAACgB,QAAQ,CAACC,UAAU,CAACX,YAAY,CAAC,CAAC,EAAE;cAC7C,IAAIA,YAAY,IAAI,KAAK,EAAE;gBACzBA,YAAY,GAAI,GAAEnD,IAAI,CAACC,KAAK,CAACkD,YAAY,GAAG,IAAI,CAAE,GAAE;cACtD,CAAC,MAAM,IAAIA,YAAY,IAAI,IAAI,EAAE;gBAC/BA,YAAY,GAAI,GAAEnD,IAAI,CAACC,KAAK,CAACkD,YAAY,GAAG,GAAG,CAAC,GAAG,EAAG,GAAE;cAC1D;cACA,IAAI,CAACxC,QAAQ,CAACC,GAAG,EAAEqC,YAAY,EAAE;gBAC/BjC,UAAU;gBACVC,KAAK,EAAEkC,YAAY;gBACnBjC,MAAM,EAAEkC,YAAY;gBACpB/D,GAAG;gBACH8B,MAAM,EAAE;cACV,CAAC,CAAC;YACJ;UACF,CAAC,MAAM;YACL,MAAM4C,aAAa,GAAG7C,MAAM,GAAG,CAAC;YAChC,MAAM8C,cAAc,GAAGvE,QAAQ,CAACE,UAAU,CAACuB,MAAM;YACjD,MAAM+C,WAAW,GAAGxE,QAAQ,CAACE,UAAU,CAACuE,MAAM;YAC9C,IAAIC,WAAW;YACbH,cAAc,KAAK,IAAI,GAAGD,aAAa,GAAGC,cAAc;YAC1D,IAAII,UAAU;;YAEd,IAAIJ,cAAc,KAAK,IAAI,EAAE;cAC3B,MAAMK,aAAa,GAAGzF,cAAc,CAACa,QAAQ,CAAC,CAAC,CAAC,CAAC;cACjD,IAAIP,eAAe,KAAK,YAAY,EAAE;gBACpCkF,UAAU,GAAI,GAAElG,YAAY,CAACiG,WAAW,EAAE,CAAC,CAAE,IAAG;gBAChDA,WAAW,GAAGnG,UAAU,CAACmG,WAAW,EAAEE,aAAa,EAAE9E,IAAI,CAAC;cAC5D,CAAC,MAAM,IAAIL,eAAe,KAAK,OAAO,EAAE;gBACtCkF,UAAU,GAAI,GAAElG,YAAY,CAACiG,WAAW,EAAE,CAAC,CAAE,IAAG;gBAChDA,WAAW,GAAGnG,UAAU;kBACtBmG,WAAW,GAAGlG,YAAY;kBAC1BoG,aAAa;kBACb9E;gBACF,CAAC;cACH;YACF;;YAEA,IAAI0E,WAAW,KAAK,IAAI,EAAE;cACxBG,UAAU,GAAGvB,MAAM,CAACgB,QAAQ,CAACC,UAAU,CAACG,WAAW,CAAC,CAAC;cACjD/F,YAAY,CAAC+F,WAAW,EAAE,CAAC,CAAC;cAC5BA,WAAW;YACjB;;YAEA;YACA,IAAI,CAACE,WAAW,EAAE;cAChBA,WAAW,GAAGJ,aAAa;YAC7B;;YAEAnD,GAAG,CAAC8C,GAAG;cACLT,YAAY,CAAC,CAAC,CAAC;cACfA,YAAY,CAAC,CAAC,CAAC;cACf/E,YAAY,CAACiG,WAAW,EAAE,CAAC,CAAC;cAC5B,CAAC;cACDnE,IAAI,CAAC2D,EAAE,GAAG;YACZ,CAAC;YACD/C,GAAG,CAACW,SAAS,GAAI,OAAMlC,GAAG,CAAC,CAAC,CAAE,KAAIA,GAAG,CAAC,CAAC,CAAE,KAAIA,GAAG,CAAC,CAAC,CAAE,GAAE;YACtDuB,GAAG,CAACgD,IAAI,CAAC,CAAC;;YAEV,IAAIQ,UAAU,KAAKE,SAAS,EAAE;cAC5B,IAAI,CAAC3D,QAAQ,CAACC,GAAG,EAAEqC,YAAY,EAAE;gBAC/BjC,UAAU,EAAE9C,YAAY,CAACiG,WAAW,EAAE,CAAC,CAAC;gBACxClD,KAAK,EAAEmD,UAAU;gBACjBlD,MAAM,EAAEiD,WAAW;gBACnB9E,GAAG;gBACH8B,MAAM,EAAE;cACV,CAAC,CAAC;YACJ;UACF;QACF;MACF,CAAC,EAAE,IAAI,CAAC;IACV;EACF;;EAEAoD,MAAMA,CAAA,EAAG;IACP,OAAOlG,aAAA,CAACN,aAAa,IAAC0C,MAAM,EAAE,IAAI,CAACA,MAAO,EAAE,CAAC;EAC/C,CAAC;EAAA+D,iCAAAC,GAAA,EAAAC,IAAA;IAAA,KAAAD,GAAA,IAAAE,IAAA,CAAAD,IAAA,GACH;AAEArE,sBAAsB,CAAC/B,SAAS,GAAGA,SAAS;AAC5C+B,sBAAsB,CAACb,YAAY,GAAGA,YAAY,CAAC,MAAAoF,QAAA;;AAEpCvE,sBAAsB,CAArC,eAAAuE,QAAA,CAAsC,mBAAAC,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAT,SAAA,MAAAO,cAAA,WAAAA,cAAA,CAAAG,QAAA,CA5PhC1G,SAAS,4IAAAuG,cAAA,CAAAG,QAAA,CAcTxF,YAAY,+IAAAqF,cAAA,CAAAG,QAAA,CAQZtF,mBAAmB,sJAAAmF,cAAA,CAAAG,QAAA,CA0BnB3E,sBAAsB,yJAAAwE,cAAA,CAAAG,QAAA,CAAAJ,QAAA,kKAAAK,WAAA,UAAAH,oBAAA,mBAAAA,oBAAA,CAAAG,WAAA,GAAAX,SAAA,CAAAW,WAAA,IAAAA,WAAA,CAAAC,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}