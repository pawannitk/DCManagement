{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { ensureIsArray } from '@superset-ui/core';\nimport { getSectionsToRender } from './getSectionsToRender';\nimport { getControlConfig } from './getControlConfig';\nfunction execControlValidator(control, processedState) {\n  const validators = control.validators;\n  const { externalValidationErrors = [] } = control;\n  const errors = [];\n  if (validators && validators.length > 0) {\n    validators.forEach((validator) => {\n      const error = validator.call(control, control.value, processedState);\n      if (error) {\n        errors.push(error);\n      }\n    });\n  }\n  const validationErrors = [...errors, ...externalValidationErrors];\n  // always reset validation errors even when there is no validator\n  return { ...control, validationErrors };\n}\n/**\n * Clear control values that are no longer in the `choices` list.\n */\nfunction handleMissingChoice(control) {\n  // If the value is not valid anymore based on choices, clear it\n  if (control.type === 'SelectControl' &&\n  !control.freeForm &&\n  control.choices &&\n  control.value) {\n    const alteredControl = { ...control };\n    const choices = control.choices;\n    const value = ensureIsArray(control.value);\n    const choiceValues = choices.map((c) => c[0]);\n    if (control.multi && value.length > 0) {\n      alteredControl.value = value.filter((el) => choiceValues.includes(el));\n      return alteredControl;\n    }\n    if (!control.multi && !choiceValues.includes(value[0])) {\n      alteredControl.value = null;\n      return alteredControl;\n    }\n  }\n  return control;\n}\nexport function applyMapStateToPropsToControl(controlState, controlPanelState) {\n  const { mapStateToProps } = controlState;\n  let state = { ...controlState };\n  let { value } = state; // value is current user-input value\n  if (mapStateToProps && controlPanelState) {\n    state = {\n      ...controlState,\n      ...mapStateToProps.call(controlState, controlPanelState, controlState)\n    };\n    // `mapStateToProps` may also provide a value\n    value = value || state.value;\n  }\n  // InitialValue is used for setting value for the control,\n  // this value is not recalculated. The default value will override it.\n  if (typeof state.initialValue === 'function') {\n    state.initialValue = state.initialValue(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.initialValue === 'function') {\n      delete state.initialValue;\n    }\n  }\n  if (state.initialValue) {\n    value = state.initialValue;\n    delete state.initialValue;\n  }\n  // If default is a function, evaluate it\n  if (typeof state.default === 'function') {\n    state.default = state.default(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.default === 'function') {\n      delete state.default;\n    }\n  }\n  // If no current value, set it as default\n  if (state.default && value === undefined) {\n    value = state.default;\n  }\n  // If a choice control went from multi=false to true, wrap value in array\n  if (value && state.multi && !Array.isArray(value)) {\n    value = [value];\n  }\n  state.value = value;\n  return execControlValidator(handleMissingChoice(state), state);\n}\nexport function getControlStateFromControlConfig(controlConfig, controlPanelState, value) {\n  // skip invalid config values\n  if (!controlConfig) {\n    return null;\n  }\n  const controlState = { ...controlConfig, value };\n  // only apply mapStateToProps when control states have been initialized\n  // or when explicitly didn't provide control panel state (mostly for testing)\n  if (controlPanelState != null && controlPanelState.controls || controlPanelState === null) {\n    return applyMapStateToPropsToControl(controlState, controlPanelState);\n  }\n  return controlState;\n}\nexport function getControlState(controlKey, vizType, state, value) {\n  return getControlStateFromControlConfig(getControlConfig(controlKey, vizType), state, value);\n}\nexport function getAllControlsState(vizType, datasourceType, state, formData) {\n  const controlsState = {};\n  getSectionsToRender(vizType, datasourceType).forEach((section) => section.controlSetRows.forEach((fieldsetRow) => fieldsetRow.forEach((field) => {\n    if (field != null && field.config && field.name) {\n      const { config, name } = field;\n      controlsState[name] = getControlStateFromControlConfig(config, state, formData[name]);\n    }\n  })));\n  return controlsState;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(execControlValidator, \"execControlValidator\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(handleMissingChoice, \"handleMissingChoice\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(applyMapStateToPropsToControl, \"applyMapStateToPropsToControl\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(getControlStateFromControlConfig, \"getControlStateFromControlConfig\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(getControlState, \"getControlState\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(getAllControlsState, \"getAllControlsState\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["ensureIsArray","getSectionsToRender","getControlConfig","execControlValidator","control","processedState","validators","externalValidationErrors","errors","length","forEach","validator","error","call","value","push","validationErrors","handleMissingChoice","type","freeForm","choices","alteredControl","choiceValues","map","c","multi","filter","el","includes","applyMapStateToPropsToControl","controlState","controlPanelState","mapStateToProps","state","initialValue","default","undefined","Array","isArray","getControlStateFromControlConfig","controlConfig","controls","getControlState","controlKey","vizType","getAllControlsState","datasourceType","formData","controlsState","section","controlSetRows","fieldsetRow","field","config","name","reactHotLoader","reactHotLoaderGlobal","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/controlUtils/getControlState.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ReactNode } from 'react';\nimport {\n  DatasourceType,\n  ensureIsArray,\n  JsonValue,\n  QueryFormData,\n} from '@superset-ui/core';\nimport {\n  ControlConfig,\n  ControlPanelState,\n  ControlState,\n  ControlType,\n  ControlValueValidator,\n  CustomControlItem,\n} from '@superset-ui/chart-controls';\nimport { getSectionsToRender } from './getSectionsToRender';\nimport { getControlConfig } from './getControlConfig';\n\ntype ValidationError = JsonValue;\n\nfunction execControlValidator<T = ControlType>(\n  control: ControlState<T>,\n  processedState: ControlState<T>,\n) {\n  const validators = control.validators as ControlValueValidator[] | undefined;\n  const { externalValidationErrors = [] } = control;\n  const errors: ValidationError[] = [];\n  if (validators && validators.length > 0) {\n    validators.forEach(validator => {\n      const error = validator.call(control, control.value, processedState);\n      if (error) {\n        errors.push(error);\n      }\n    });\n  }\n  const validationErrors = [...errors, ...externalValidationErrors];\n  // always reset validation errors even when there is no validator\n  return { ...control, validationErrors };\n}\n\n/**\n * Clear control values that are no longer in the `choices` list.\n */\nfunction handleMissingChoice<T = ControlType>(control: ControlState<T>) {\n  // If the value is not valid anymore based on choices, clear it\n  if (\n    control.type === 'SelectControl' &&\n    !control.freeForm &&\n    control.choices &&\n    control.value\n  ) {\n    const alteredControl = { ...control };\n    const choices = control.choices as [JsonValue, ReactNode][];\n    const value = ensureIsArray(control.value);\n    const choiceValues = choices.map(c => c[0]);\n    if (control.multi && value.length > 0) {\n      alteredControl.value = value.filter(el => choiceValues.includes(el));\n      return alteredControl;\n    }\n    if (!control.multi && !choiceValues.includes(value[0])) {\n      alteredControl.value = null;\n      return alteredControl;\n    }\n  }\n  return control;\n}\n\nexport function applyMapStateToPropsToControl<T = ControlType>(\n  controlState: ControlState<T>,\n  controlPanelState: Partial<ControlPanelState> | null,\n) {\n  const { mapStateToProps } = controlState;\n  let state = { ...controlState };\n  let { value } = state; // value is current user-input value\n  if (mapStateToProps && controlPanelState) {\n    state = {\n      ...controlState,\n      ...mapStateToProps.call(controlState, controlPanelState, controlState),\n    };\n    // `mapStateToProps` may also provide a value\n    value = value || state.value;\n  }\n\n  // InitialValue is used for setting value for the control,\n  // this value is not recalculated. The default value will override it.\n  if (typeof state.initialValue === 'function') {\n    state.initialValue = state.initialValue(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.initialValue === 'function') {\n      delete state.initialValue;\n    }\n  }\n  if (state.initialValue) {\n    value = state.initialValue;\n    delete state.initialValue;\n  }\n\n  // If default is a function, evaluate it\n  if (typeof state.default === 'function') {\n    state.default = state.default(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.default === 'function') {\n      delete state.default;\n    }\n  }\n  // If no current value, set it as default\n  if (state.default && value === undefined) {\n    value = state.default;\n  }\n  // If a choice control went from multi=false to true, wrap value in array\n  if (value && state.multi && !Array.isArray(value)) {\n    value = [value];\n  }\n  state.value = value;\n  return execControlValidator(handleMissingChoice(state), state);\n}\n\nexport function getControlStateFromControlConfig<T = ControlType>(\n  controlConfig: ControlConfig<T> | null,\n  controlPanelState: Partial<ControlPanelState> | null,\n  value?: JsonValue,\n) {\n  // skip invalid config values\n  if (!controlConfig) {\n    return null;\n  }\n  const controlState = { ...controlConfig, value } as ControlState<T>;\n  // only apply mapStateToProps when control states have been initialized\n  // or when explicitly didn't provide control panel state (mostly for testing)\n  if (controlPanelState?.controls || controlPanelState === null) {\n    return applyMapStateToPropsToControl(controlState, controlPanelState);\n  }\n  return controlState;\n}\n\nexport function getControlState(\n  controlKey: string,\n  vizType: string,\n  state: Partial<ControlPanelState>,\n  value?: JsonValue,\n) {\n  return getControlStateFromControlConfig(\n    getControlConfig(controlKey, vizType),\n    state,\n    value,\n  );\n}\n\nexport function getAllControlsState(\n  vizType: string,\n  datasourceType: DatasourceType,\n  state: ControlPanelState | null,\n  formData: QueryFormData,\n) {\n  const controlsState = {};\n  getSectionsToRender(vizType, datasourceType).forEach(section =>\n    section.controlSetRows.forEach(fieldsetRow =>\n      fieldsetRow.forEach((field: CustomControlItem) => {\n        if (field?.config && field.name) {\n          const { config, name } = field;\n          controlsState[name] = getControlStateFromControlConfig(\n            config,\n            state,\n            formData[name],\n          );\n        }\n      }),\n    ),\n  );\n  return controlsState;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}