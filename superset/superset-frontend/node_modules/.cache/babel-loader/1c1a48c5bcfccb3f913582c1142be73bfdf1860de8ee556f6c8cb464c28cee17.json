{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CurrencyFormatter, ensureIsArray, GenericDataType, getMetricLabel, getNumberFormatter, getTimeFormatter, isAdhocColumn, rgbToHex, tooltipHtml } from '@superset-ui/core';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { ASSIST_MARK, LEGEND, TOKEN, TOTAL_MARK } from './constants';\nimport { getColtypesMapping } from '../utils/series';\nimport { NULL_STRING } from '../constants';\nfunction formatTooltip({ params, breakdownName, defaultFormatter, xAxisFormatter }) {\n  const series = params.find((param) => param.seriesName !== ASSIST_MARK && param.data.value !== TOKEN);\n  // We may have no matching series depending on the legend state\n  if (!series) {\n    return '';\n  }\n  const isTotal = (series == null ? void 0 : series.seriesName) === LEGEND.TOTAL;\n  if (!series) {\n    return NULL_STRING;\n  }\n  const title = !isTotal || breakdownName ?\n  xAxisFormatter(series.name, series.dataIndex) :\n  undefined;\n  const rows = [];\n  if (!isTotal) {\n    rows.push([\n    series.seriesName,\n    defaultFormatter(series.data.originalValue)]\n    );\n  }\n  rows.push([TOTAL_MARK, defaultFormatter(series.data.totalSum)]);\n  return tooltipHtml(rows, title);\n}\nfunction transformer({ data, xAxis, metric, breakdown }) {\n  // Group by series (temporary map)\n  const groupedData = data.reduce((acc, cur) => {\n    const categoryLabel = cur[xAxis];\n    const categoryData = acc.get(categoryLabel) || [];\n    categoryData.push(cur);\n    acc.set(categoryLabel, categoryData);\n    return acc;\n  }, new Map());\n  const transformedData = [];\n  if (breakdown) {\n    groupedData.forEach((value, key) => {\n      const tempValue = value;\n      // Calc total per period\n      const sum = tempValue.reduce((acc, cur) => {var _cur$metric;return acc + ((_cur$metric = cur[metric]) != null ? _cur$metric : 0);}, 0);\n      // Push total per period to the end of period values array\n      tempValue.push({\n        [xAxis]: key,\n        [breakdown]: TOTAL_MARK,\n        [metric]: sum\n      });\n      transformedData.push(...tempValue);\n    });\n  } else\n  {\n    let total = 0;\n    groupedData.forEach((value, key) => {\n      const sum = value.reduce((acc, cur) => {var _cur$metric2;return acc + ((_cur$metric2 = cur[metric]) != null ? _cur$metric2 : 0);}, 0);\n      transformedData.push({\n        [xAxis]: key,\n        [metric]: sum\n      });\n      total += sum;\n    });\n    transformedData.push({\n      [xAxis]: TOTAL_MARK,\n      [metric]: total\n    });\n  }\n  return transformedData;\n}\nexport default function transformProps(chartProps) {\n  const { width, height, formData, legendState, queriesData, hooks, theme, inContextMenu } = chartProps;\n  const refs = {};\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { setDataMask = () => {}, onContextMenu, onLegendStateChanged } = hooks;\n  const { currencyFormat, granularitySqla = '', groupby, increaseColor = { r: 90, g: 193, b: 137 }, decreaseColor = { r: 224, g: 67, b: 85 }, totalColor = { r: 102, g: 102, b: 102 }, metric = '', xAxis, xTicksLayout, xAxisTimeFormat, showLegend, yAxisLabel, xAxisLabel, yAxisFormat, showValue } = formData;\n  const defaultFormatter = currencyFormat != null && currencyFormat.symbol ?\n  new CurrencyFormatter({ d3Format: yAxisFormat, currency: currencyFormat }) :\n  getNumberFormatter(yAxisFormat);\n  const seriesformatter = (params) => {\n    const { data } = params;\n    const { originalValue } = data;\n    return defaultFormatter(originalValue);\n  };\n  const groupbyArray = ensureIsArray(groupby);\n  const breakdownColumn = groupbyArray.length ? groupbyArray[0] : undefined;\n  const breakdownName = isAdhocColumn(breakdownColumn) ?\n  breakdownColumn.label :\n  breakdownColumn;\n  const xAxisColumn = xAxis || granularitySqla;\n  const xAxisName = isAdhocColumn(xAxisColumn) ?\n  xAxisColumn.label :\n  xAxisColumn;\n  const metricLabel = getMetricLabel(metric);\n  const transformedData = transformer({\n    data,\n    breakdown: breakdownName,\n    xAxis: xAxisName,\n    metric: metricLabel\n  });\n  const assistData = [];\n  const increaseData = [];\n  const decreaseData = [];\n  const totalData = [];\n  let previousTotal = 0;\n  transformedData.forEach((datum, index, self) => {\n    const totalSum = self.slice(0, index + 1).reduce((prev, cur, i) => {\n      if (breakdownName) {\n        if (cur[breakdownName] !== TOTAL_MARK || i === 0) {var _cur$metricLabel;\n          return prev + ((_cur$metricLabel = cur[metricLabel]) != null ? _cur$metricLabel : 0);\n        }\n      } else\n      if (cur[xAxisName] !== TOTAL_MARK) {var _cur$metricLabel2;\n        return prev + ((_cur$metricLabel2 = cur[metricLabel]) != null ? _cur$metricLabel2 : 0);\n      }\n      return prev;\n    }, 0);\n    const isTotal = breakdownName && datum[breakdownName] === TOTAL_MARK ||\n    datum[xAxisName] === TOTAL_MARK;\n    const originalValue = datum[metricLabel];\n    let value = originalValue;\n    const oppositeSigns = Math.sign(previousTotal) !== Math.sign(totalSum);\n    if (oppositeSigns) {\n      value = Math.sign(value) * (Math.abs(value) - Math.abs(previousTotal));\n    }\n    if (isTotal) {\n      increaseData.push({ value: TOKEN });\n      decreaseData.push({ value: TOKEN });\n      totalData.push({\n        value: totalSum,\n        originalValue: totalSum,\n        totalSum\n      });\n    } else\n    if (value < 0) {\n      increaseData.push({ value: TOKEN });\n      decreaseData.push({\n        value: totalSum < 0 ? value : -value,\n        originalValue,\n        totalSum\n      });\n      totalData.push({ value: TOKEN });\n    } else\n    {\n      increaseData.push({\n        value: totalSum > 0 ? value : -value,\n        originalValue,\n        totalSum\n      });\n      decreaseData.push({ value: TOKEN });\n      totalData.push({ value: TOKEN });\n    }\n    const color = oppositeSigns ?\n    value > 0 ?\n    rgbToHex(increaseColor.r, increaseColor.g, increaseColor.b) :\n    rgbToHex(decreaseColor.r, decreaseColor.g, decreaseColor.b) :\n    'transparent';\n    let opacity = 1;\n    if ((legendState == null ? void 0 : legendState[LEGEND.INCREASE]) === false && value > 0) {\n      opacity = 0;\n    } else\n    if ((legendState == null ? void 0 : legendState[LEGEND.DECREASE]) === false && value < 0) {\n      opacity = 0;\n    }\n    if (isTotal) {\n      assistData.push({ value: TOKEN });\n    } else\n    if (index === 0) {\n      assistData.push({\n        value: 0\n      });\n    } else\n    if (oppositeSigns || Math.abs(totalSum) > Math.abs(previousTotal)) {\n      assistData.push({\n        value: previousTotal,\n        itemStyle: { color, opacity }\n      });\n    } else\n    {\n      assistData.push({\n        value: totalSum,\n        itemStyle: { color, opacity }\n      });\n    }\n    previousTotal = totalSum;\n  });\n  const xAxisColumns = [];\n  const xAxisData = transformedData.map((row) => {\n    let column = xAxisName;\n    let value = row[xAxisName];\n    if (breakdownName && row[breakdownName] !== TOTAL_MARK) {\n      column = breakdownName;\n      value = row[breakdownName];\n    }\n    if (!value) {\n      value = NULL_STRING;\n    }\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      value = String(value);\n    }\n    xAxisColumns.push(column);\n    return value;\n  });\n  const xAxisFormatter = (value, index) => {\n    if (value === TOTAL_MARK) {\n      return TOTAL_MARK;\n    }\n    if (coltypeMapping[xAxisColumns[index]] === GenericDataType.Temporal) {\n      if (typeof value === 'string') {\n        return getTimeFormatter(xAxisTimeFormat)(Number.parseInt(value, 10));\n      }\n      return getTimeFormatter(xAxisTimeFormat)(value);\n    }\n    return String(value);\n  };\n  let axisLabel;\n  if (xTicksLayout === '45°') {\n    axisLabel = { rotate: -45 };\n  } else\n  if (xTicksLayout === '90°') {\n    axisLabel = { rotate: -90 };\n  } else\n  if (xTicksLayout === 'flat') {\n    axisLabel = { rotate: 0 };\n  } else\n  if (xTicksLayout === 'staggered') {\n    axisLabel = { rotate: -45 };\n  } else\n  {\n    axisLabel = { show: true };\n  }\n  axisLabel.formatter = xAxisFormatter;\n  axisLabel.hideOverlap = false;\n  const seriesProps = {\n    type: 'bar',\n    stack: 'stack',\n    emphasis: {\n      disabled: true\n    }\n  };\n  const barSeries = [\n  {\n    ...seriesProps,\n    name: ASSIST_MARK,\n    data: assistData\n  },\n  {\n    ...seriesProps,\n    name: LEGEND.INCREASE,\n    label: {\n      show: showValue,\n      position: 'top',\n      formatter: seriesformatter\n    },\n    itemStyle: {\n      color: rgbToHex(increaseColor.r, increaseColor.g, increaseColor.b)\n    },\n    data: increaseData\n  },\n  {\n    ...seriesProps,\n    name: LEGEND.DECREASE,\n    label: {\n      show: showValue,\n      position: 'bottom',\n      formatter: seriesformatter\n    },\n    itemStyle: {\n      color: rgbToHex(decreaseColor.r, decreaseColor.g, decreaseColor.b)\n    },\n    data: decreaseData\n  },\n  {\n    ...seriesProps,\n    name: LEGEND.TOTAL,\n    label: {\n      show: showValue,\n      position: 'top',\n      formatter: seriesformatter\n    },\n    itemStyle: {\n      color: rgbToHex(totalColor.r, totalColor.g, totalColor.b)\n    },\n    data: totalData\n  }];\n\n  const echartOptions = {\n    grid: {\n      ...defaultGrid,\n      top: theme.gridUnit * 7,\n      bottom: theme.gridUnit * 7,\n      left: theme.gridUnit * 5,\n      right: theme.gridUnit * 7\n    },\n    legend: {\n      show: showLegend,\n      selected: legendState,\n      data: [LEGEND.INCREASE, LEGEND.DECREASE, LEGEND.TOTAL]\n    },\n    xAxis: {\n      data: xAxisData,\n      type: 'category',\n      name: xAxisLabel,\n      nameTextStyle: {\n        padding: [theme.gridUnit * 4, 0, 0, 0]\n      },\n      nameLocation: 'middle',\n      axisLabel\n    },\n    yAxis: {\n      ...defaultYAxis,\n      type: 'value',\n      nameTextStyle: {\n        padding: [0, 0, theme.gridUnit * 5, 0]\n      },\n      nameLocation: 'middle',\n      name: yAxisLabel,\n      axisLabel: { formatter: defaultFormatter }\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      appendToBody: true,\n      trigger: 'axis',\n      show: !inContextMenu,\n      formatter: (params) => formatTooltip({\n        params,\n        breakdownName,\n        defaultFormatter,\n        xAxisFormatter\n      })\n    },\n    series: barSeries\n  };\n  return {\n    refs,\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    onContextMenu,\n    onLegendStateChanged\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(formatTooltip, \"formatTooltip\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Waterfall/transformProps.ts\");reactHotLoader.register(transformer, \"transformer\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Waterfall/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Waterfall/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["CurrencyFormatter","ensureIsArray","GenericDataType","getMetricLabel","getNumberFormatter","getTimeFormatter","isAdhocColumn","rgbToHex","tooltipHtml","getDefaultTooltip","defaultGrid","defaultYAxis","ASSIST_MARK","LEGEND","TOKEN","TOTAL_MARK","getColtypesMapping","NULL_STRING","formatTooltip","params","breakdownName","defaultFormatter","xAxisFormatter","series","find","param","seriesName","data","value","isTotal","TOTAL","title","name","dataIndex","undefined","rows","push","originalValue","totalSum","transformer","xAxis","metric","breakdown","groupedData","reduce","acc","cur","categoryLabel","categoryData","get","set","Map","transformedData","forEach","key","tempValue","sum","_cur$metric","total","_cur$metric2","transformProps","chartProps","width","height","formData","legendState","queriesData","hooks","theme","inContextMenu","refs","coltypeMapping","setDataMask","onContextMenu","onLegendStateChanged","currencyFormat","granularitySqla","groupby","increaseColor","r","g","b","decreaseColor","totalColor","xTicksLayout","xAxisTimeFormat","showLegend","yAxisLabel","xAxisLabel","yAxisFormat","showValue","symbol","d3Format","currency","seriesformatter","groupbyArray","breakdownColumn","length","label","xAxisColumn","xAxisName","metricLabel","assistData","increaseData","decreaseData","totalData","previousTotal","datum","index","self","slice","prev","i","_cur$metricLabel","_cur$metricLabel2","oppositeSigns","Math","sign","abs","color","opacity","INCREASE","DECREASE","itemStyle","xAxisColumns","xAxisData","map","row","column","String","Temporal","Number","parseInt","axisLabel","rotate","show","formatter","hideOverlap","seriesProps","type","stack","emphasis","disabled","barSeries","position","echartOptions","grid","top","gridUnit","bottom","left","right","legend","selected","nameTextStyle","padding","nameLocation","yAxis","tooltip","appendToBody","trigger","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Waterfall/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  CurrencyFormatter,\n  DataRecord,\n  ensureIsArray,\n  GenericDataType,\n  getMetricLabel,\n  getNumberFormatter,\n  getTimeFormatter,\n  isAdhocColumn,\n  NumberFormatter,\n  rgbToHex,\n  tooltipHtml,\n} from '@superset-ui/core';\nimport { EChartsOption, BarSeriesOption } from 'echarts';\nimport {\n  EchartsWaterfallChartProps,\n  ISeriesData,\n  WaterfallChartTransformedProps,\n  ICallbackDataParams,\n} from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { ASSIST_MARK, LEGEND, TOKEN, TOTAL_MARK } from './constants';\nimport { getColtypesMapping } from '../utils/series';\nimport { Refs } from '../types';\nimport { NULL_STRING } from '../constants';\n\nfunction formatTooltip({\n  params,\n  breakdownName,\n  defaultFormatter,\n  xAxisFormatter,\n}: {\n  params: ICallbackDataParams[];\n  breakdownName?: string;\n  defaultFormatter: NumberFormatter | CurrencyFormatter;\n  xAxisFormatter: (value: number | string, index: number) => string;\n}) {\n  const series = params.find(\n    param => param.seriesName !== ASSIST_MARK && param.data.value !== TOKEN,\n  );\n\n  // We may have no matching series depending on the legend state\n  if (!series) {\n    return '';\n  }\n\n  const isTotal = series?.seriesName === LEGEND.TOTAL;\n  if (!series) {\n    return NULL_STRING;\n  }\n\n  const title =\n    !isTotal || breakdownName\n      ? xAxisFormatter(series.name, series.dataIndex)\n      : undefined;\n  const rows: string[][] = [];\n  if (!isTotal) {\n    rows.push([\n      series.seriesName!,\n      defaultFormatter(series.data.originalValue),\n    ]);\n  }\n  rows.push([TOTAL_MARK, defaultFormatter(series.data.totalSum)]);\n  return tooltipHtml(rows, title);\n}\n\nfunction transformer({\n  data,\n  xAxis,\n  metric,\n  breakdown,\n}: {\n  data: DataRecord[];\n  xAxis: string;\n  metric: string;\n  breakdown?: string;\n}) {\n  // Group by series (temporary map)\n  const groupedData = data.reduce((acc, cur) => {\n    const categoryLabel = cur[xAxis] as string;\n    const categoryData = acc.get(categoryLabel) || [];\n    categoryData.push(cur);\n    acc.set(categoryLabel, categoryData);\n    return acc;\n  }, new Map<string, DataRecord[]>());\n\n  const transformedData: DataRecord[] = [];\n\n  if (breakdown) {\n    groupedData.forEach((value, key) => {\n      const tempValue = value;\n      // Calc total per period\n      const sum = tempValue.reduce(\n        (acc, cur) => acc + ((cur[metric] as number) ?? 0),\n        0,\n      );\n      // Push total per period to the end of period values array\n      tempValue.push({\n        [xAxis]: key,\n        [breakdown]: TOTAL_MARK,\n        [metric]: sum,\n      });\n      transformedData.push(...tempValue);\n    });\n  } else {\n    let total = 0;\n    groupedData.forEach((value, key) => {\n      const sum = value.reduce(\n        (acc, cur) => acc + ((cur[metric] as number) ?? 0),\n        0,\n      );\n      transformedData.push({\n        [xAxis]: key,\n        [metric]: sum,\n      });\n      total += sum;\n    });\n    transformedData.push({\n      [xAxis]: TOTAL_MARK,\n      [metric]: total,\n    });\n  }\n\n  return transformedData;\n}\n\nexport default function transformProps(\n  chartProps: EchartsWaterfallChartProps,\n): WaterfallChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    legendState,\n    queriesData,\n    hooks,\n    theme,\n    inContextMenu,\n  } = chartProps;\n  const refs: Refs = {};\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { setDataMask = () => {}, onContextMenu, onLegendStateChanged } = hooks;\n  const {\n    currencyFormat,\n    granularitySqla = '',\n    groupby,\n    increaseColor = { r: 90, g: 193, b: 137 },\n    decreaseColor = { r: 224, g: 67, b: 85 },\n    totalColor = { r: 102, g: 102, b: 102 },\n    metric = '',\n    xAxis,\n    xTicksLayout,\n    xAxisTimeFormat,\n    showLegend,\n    yAxisLabel,\n    xAxisLabel,\n    yAxisFormat,\n    showValue,\n  } = formData;\n  const defaultFormatter = currencyFormat?.symbol\n    ? new CurrencyFormatter({ d3Format: yAxisFormat, currency: currencyFormat })\n    : getNumberFormatter(yAxisFormat);\n\n  const seriesformatter = (params: ICallbackDataParams) => {\n    const { data } = params;\n    const { originalValue } = data;\n    return defaultFormatter(originalValue as number);\n  };\n  const groupbyArray = ensureIsArray(groupby);\n  const breakdownColumn = groupbyArray.length ? groupbyArray[0] : undefined;\n  const breakdownName = isAdhocColumn(breakdownColumn)\n    ? breakdownColumn.label!\n    : breakdownColumn;\n  const xAxisColumn = xAxis || granularitySqla;\n  const xAxisName = isAdhocColumn(xAxisColumn)\n    ? xAxisColumn.label!\n    : xAxisColumn;\n  const metricLabel = getMetricLabel(metric);\n\n  const transformedData = transformer({\n    data,\n    breakdown: breakdownName,\n    xAxis: xAxisName,\n    metric: metricLabel,\n  });\n\n  const assistData: ISeriesData[] = [];\n  const increaseData: ISeriesData[] = [];\n  const decreaseData: ISeriesData[] = [];\n  const totalData: ISeriesData[] = [];\n\n  let previousTotal = 0;\n\n  transformedData.forEach((datum, index, self) => {\n    const totalSum = self.slice(0, index + 1).reduce((prev, cur, i) => {\n      if (breakdownName) {\n        if (cur[breakdownName] !== TOTAL_MARK || i === 0) {\n          return prev + ((cur[metricLabel] as number) ?? 0);\n        }\n      } else if (cur[xAxisName] !== TOTAL_MARK) {\n        return prev + ((cur[metricLabel] as number) ?? 0);\n      }\n      return prev;\n    }, 0);\n\n    const isTotal =\n      (breakdownName && datum[breakdownName] === TOTAL_MARK) ||\n      datum[xAxisName] === TOTAL_MARK;\n\n    const originalValue = datum[metricLabel] as number;\n    let value = originalValue;\n    const oppositeSigns = Math.sign(previousTotal) !== Math.sign(totalSum);\n    if (oppositeSigns) {\n      value = Math.sign(value) * (Math.abs(value) - Math.abs(previousTotal));\n    }\n\n    if (isTotal) {\n      increaseData.push({ value: TOKEN });\n      decreaseData.push({ value: TOKEN });\n      totalData.push({\n        value: totalSum,\n        originalValue: totalSum,\n        totalSum,\n      });\n    } else if (value < 0) {\n      increaseData.push({ value: TOKEN });\n      decreaseData.push({\n        value: totalSum < 0 ? value : -value,\n        originalValue,\n        totalSum,\n      });\n      totalData.push({ value: TOKEN });\n    } else {\n      increaseData.push({\n        value: totalSum > 0 ? value : -value,\n        originalValue,\n        totalSum,\n      });\n      decreaseData.push({ value: TOKEN });\n      totalData.push({ value: TOKEN });\n    }\n\n    const color = oppositeSigns\n      ? value > 0\n        ? rgbToHex(increaseColor.r, increaseColor.g, increaseColor.b)\n        : rgbToHex(decreaseColor.r, decreaseColor.g, decreaseColor.b)\n      : 'transparent';\n\n    let opacity = 1;\n    if (legendState?.[LEGEND.INCREASE] === false && value > 0) {\n      opacity = 0;\n    } else if (legendState?.[LEGEND.DECREASE] === false && value < 0) {\n      opacity = 0;\n    }\n\n    if (isTotal) {\n      assistData.push({ value: TOKEN });\n    } else if (index === 0) {\n      assistData.push({\n        value: 0,\n      });\n    } else if (oppositeSigns || Math.abs(totalSum) > Math.abs(previousTotal)) {\n      assistData.push({\n        value: previousTotal,\n        itemStyle: { color, opacity },\n      });\n    } else {\n      assistData.push({\n        value: totalSum,\n        itemStyle: { color, opacity },\n      });\n    }\n\n    previousTotal = totalSum;\n  });\n\n  const xAxisColumns: string[] = [];\n  const xAxisData = transformedData.map(row => {\n    let column = xAxisName;\n    let value = row[xAxisName];\n    if (breakdownName && row[breakdownName] !== TOTAL_MARK) {\n      column = breakdownName;\n      value = row[breakdownName];\n    }\n    if (!value) {\n      value = NULL_STRING;\n    }\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      value = String(value);\n    }\n    xAxisColumns.push(column);\n    return value;\n  });\n\n  const xAxisFormatter = (value: number | string, index: number) => {\n    if (value === TOTAL_MARK) {\n      return TOTAL_MARK;\n    }\n    if (coltypeMapping[xAxisColumns[index]] === GenericDataType.Temporal) {\n      if (typeof value === 'string') {\n        return getTimeFormatter(xAxisTimeFormat)(Number.parseInt(value, 10));\n      }\n      return getTimeFormatter(xAxisTimeFormat)(value);\n    }\n    return String(value);\n  };\n\n  let axisLabel: {\n    rotate?: number;\n    hideOverlap?: boolean;\n    show?: boolean;\n    formatter?: typeof xAxisFormatter;\n  };\n  if (xTicksLayout === '45°') {\n    axisLabel = { rotate: -45 };\n  } else if (xTicksLayout === '90°') {\n    axisLabel = { rotate: -90 };\n  } else if (xTicksLayout === 'flat') {\n    axisLabel = { rotate: 0 };\n  } else if (xTicksLayout === 'staggered') {\n    axisLabel = { rotate: -45 };\n  } else {\n    axisLabel = { show: true };\n  }\n  axisLabel.formatter = xAxisFormatter;\n  axisLabel.hideOverlap = false;\n\n  const seriesProps: Pick<BarSeriesOption, 'type' | 'stack' | 'emphasis'> = {\n    type: 'bar',\n    stack: 'stack',\n    emphasis: {\n      disabled: true,\n    },\n  };\n\n  const barSeries: BarSeriesOption[] = [\n    {\n      ...seriesProps,\n      name: ASSIST_MARK,\n      data: assistData,\n    },\n    {\n      ...seriesProps,\n      name: LEGEND.INCREASE,\n      label: {\n        show: showValue,\n        position: 'top',\n        formatter: seriesformatter,\n      },\n      itemStyle: {\n        color: rgbToHex(increaseColor.r, increaseColor.g, increaseColor.b),\n      },\n      data: increaseData,\n    },\n    {\n      ...seriesProps,\n      name: LEGEND.DECREASE,\n      label: {\n        show: showValue,\n        position: 'bottom',\n        formatter: seriesformatter,\n      },\n      itemStyle: {\n        color: rgbToHex(decreaseColor.r, decreaseColor.g, decreaseColor.b),\n      },\n      data: decreaseData,\n    },\n    {\n      ...seriesProps,\n      name: LEGEND.TOTAL,\n      label: {\n        show: showValue,\n        position: 'top',\n        formatter: seriesformatter,\n      },\n      itemStyle: {\n        color: rgbToHex(totalColor.r, totalColor.g, totalColor.b),\n      },\n      data: totalData,\n    },\n  ];\n\n  const echartOptions: EChartsOption = {\n    grid: {\n      ...defaultGrid,\n      top: theme.gridUnit * 7,\n      bottom: theme.gridUnit * 7,\n      left: theme.gridUnit * 5,\n      right: theme.gridUnit * 7,\n    },\n    legend: {\n      show: showLegend,\n      selected: legendState,\n      data: [LEGEND.INCREASE, LEGEND.DECREASE, LEGEND.TOTAL],\n    },\n    xAxis: {\n      data: xAxisData,\n      type: 'category',\n      name: xAxisLabel,\n      nameTextStyle: {\n        padding: [theme.gridUnit * 4, 0, 0, 0],\n      },\n      nameLocation: 'middle',\n      axisLabel,\n    },\n    yAxis: {\n      ...defaultYAxis,\n      type: 'value',\n      nameTextStyle: {\n        padding: [0, 0, theme.gridUnit * 5, 0],\n      },\n      nameLocation: 'middle',\n      name: yAxisLabel,\n      axisLabel: { formatter: defaultFormatter },\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      appendToBody: true,\n      trigger: 'axis',\n      show: !inContextMenu,\n      formatter: (params: any) =>\n        formatTooltip({\n          params,\n          breakdownName,\n          defaultFormatter,\n          xAxisFormatter,\n        }),\n    },\n    series: barSeries,\n  };\n\n  return {\n    refs,\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    onContextMenu,\n    onLegendStateChanged,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}