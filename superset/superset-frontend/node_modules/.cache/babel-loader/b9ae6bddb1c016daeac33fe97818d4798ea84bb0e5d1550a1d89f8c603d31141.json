{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nconst defaultGetValue = (points) => points.length;\n\nimport { clamp, getQuantileDomain, getOrdinalDomain } from './scale-utils';\nconst MAX_32_BIT_FLOAT = 3.402823466e38;\n\nconst defaultGetPoints = (bin) => bin.points;\n\nconst defaultGetIndex = (bin) => bin.index;\n\nconst ascending = (a, b) => a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n\nconst defaultProps = {\n  getValue: defaultGetValue,\n  getPoints: defaultGetPoints,\n  getIndex: defaultGetIndex,\n  filterData: null\n};\nexport default class BinSorter {\n  constructor(bins = [], props = defaultProps) {\n    _defineProperty(this, \"maxCount\", void 0);\n\n    _defineProperty(this, \"maxValue\", void 0);\n\n    _defineProperty(this, \"minValue\", void 0);\n\n    _defineProperty(this, \"totalCount\", void 0);\n\n    _defineProperty(this, \"aggregatedBins\", void 0);\n\n    _defineProperty(this, \"sortedBins\", void 0);\n\n    _defineProperty(this, \"binMap\", void 0);\n\n    this.aggregatedBins = this.getAggregatedBins(bins, props);\n\n    this._updateMinMaxValues();\n\n    this.binMap = this.getBinMap();\n  }\n\n  getAggregatedBins(bins, props) {\n    const {\n      getValue = defaultGetValue,\n      getPoints = defaultGetPoints,\n      getIndex = defaultGetIndex,\n      filterData\n    } = props;\n    const hasFilter = typeof filterData === 'function';\n    const binCount = bins.length;\n    const aggregatedBins = [];\n    let index = 0;\n\n    for (let binIndex = 0; binIndex < binCount; binIndex++) {\n      const bin = bins[binIndex];\n      const points = getPoints(bin);\n      const i = getIndex(bin);\n      const filteredPoints = hasFilter ? points.filter(filterData) : points;\n      bin.filteredPoints = hasFilter ? filteredPoints : null;\n      const value = filteredPoints.length ? getValue(filteredPoints) : null;\n\n      if (value !== null && value !== undefined) {\n        aggregatedBins[index] = {\n          i: Number.isFinite(i) ? i : binIndex,\n          value,\n          counts: filteredPoints.length\n        };\n        index++;\n      }\n    }\n\n    return aggregatedBins;\n  }\n\n  _percentileToIndex(percentileRange) {\n    const len = this.sortedBins.length;\n\n    if (len < 2) {\n      return [0, 0];\n    }\n\n    const [lower, upper] = percentileRange.map((n) => clamp(n, 0, 100));\n    const lowerIdx = Math.ceil(lower / 100 * (len - 1));\n    const upperIdx = Math.floor(upper / 100 * (len - 1));\n    return [lowerIdx, upperIdx];\n  }\n\n  getBinMap() {\n    const binMap = {};\n\n    for (const bin of this.aggregatedBins) {\n      binMap[bin.i] = bin;\n    }\n\n    return binMap;\n  }\n\n  _updateMinMaxValues() {\n    let maxCount = 0;\n    let maxValue = 0;\n    let minValue = MAX_32_BIT_FLOAT;\n    let totalCount = 0;\n\n    for (const x of this.aggregatedBins) {\n      maxCount = maxCount > x.counts ? maxCount : x.counts;\n      maxValue = maxValue > x.value ? maxValue : x.value;\n      minValue = minValue < x.value ? minValue : x.value;\n      totalCount += x.counts;\n    }\n\n    this.maxCount = maxCount;\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n    this.totalCount = totalCount;\n  }\n\n  getValueRange(percentileRange) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n\n    if (!this.sortedBins.length) {\n      return [];\n    }\n\n    let lowerIdx = 0;\n    let upperIdx = this.sortedBins.length - 1;\n\n    if (Array.isArray(percentileRange)) {\n      const idxRange = this._percentileToIndex(percentileRange);\n\n      lowerIdx = idxRange[0];\n      upperIdx = idxRange[1];\n    }\n\n    return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];\n  }\n\n  getValueDomainByScale(scale, [lower = 0, upper = 100] = []) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n\n    if (!this.sortedBins.length) {\n      return [];\n    }\n\n    const indexEdge = this._percentileToIndex([lower, upper]);\n\n    return this._getScaleDomain(scale, indexEdge);\n  }\n\n  _getScaleDomain(scaleType, [lowerIdx, upperIdx]) {\n    const bins = this.sortedBins;\n\n    switch (scaleType) {\n      case 'quantize':\n      case 'linear':\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n\n      case 'quantile':\n        return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), (d) => d.value);\n\n      case 'ordinal':\n        return getOrdinalDomain(bins, (d) => d.value);\n\n      default:\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n    }\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(defaultGetValue, \"defaultGetValue\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/bin-sorter.js\");reactHotLoader.register(MAX_32_BIT_FLOAT, \"MAX_32_BIT_FLOAT\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/bin-sorter.js\");reactHotLoader.register(defaultGetPoints, \"defaultGetPoints\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/bin-sorter.js\");reactHotLoader.register(defaultGetIndex, \"defaultGetIndex\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/bin-sorter.js\");reactHotLoader.register(ascending, \"ascending\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/bin-sorter.js\");reactHotLoader.register(defaultProps, \"defaultProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/bin-sorter.js\");reactHotLoader.register(BinSorter, \"BinSorter\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/bin-sorter.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["defaultGetValue","points","length","clamp","getQuantileDomain","getOrdinalDomain","MAX_32_BIT_FLOAT","defaultGetPoints","bin","defaultGetIndex","index","ascending","a","b","NaN","defaultProps","getValue","getPoints","getIndex","filterData","BinSorter","constructor","bins","props","_defineProperty","aggregatedBins","getAggregatedBins","_updateMinMaxValues","binMap","getBinMap","hasFilter","binCount","binIndex","i","filteredPoints","filter","value","undefined","Number","isFinite","counts","_percentileToIndex","percentileRange","len","sortedBins","lower","upper","map","n","lowerIdx","Math","ceil","upperIdx","floor","maxCount","maxValue","minValue","totalCount","x","getValueRange","sort","Array","isArray","idxRange","getValueDomainByScale","scale","indexEdge","_getScaleDomain","scaleType","slice","d","__reactstandin__regenerateByEval","key","code","eval","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["../../../src/utils/bin-sorter.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// getValue takes an array of points returns a value to sort the bins on.\n// by default it returns the number of points\n// this is where to pass in a function to color the bins by\n// avg/mean/max of specific value of the point\nconst defaultGetValue = points => points.length;\n\nimport {clamp, getQuantileDomain, getOrdinalDomain} from './scale-utils';\n\nconst MAX_32_BIT_FLOAT = 3.402823466e38;\n\n// access array of points in each bin\nconst defaultGetPoints = bin => bin.points;\n// access index of each bin\nconst defaultGetIndex = bin => bin.index;\n\n// d3-scending\nconst ascending = (a, b) => (a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN);\n\nconst defaultProps = {\n  getValue: defaultGetValue,\n  getPoints: defaultGetPoints,\n  getIndex: defaultGetIndex,\n  filterData: null\n};\n\nexport type AggregatedBin = {\n  i: number;\n  value: any;\n  counts: number;\n};\n\nexport default class BinSorter {\n  maxCount!: number;\n  maxValue!: number;\n  minValue!: number;\n  totalCount!: number;\n\n  aggregatedBins: AggregatedBin[];\n  sortedBins!: AggregatedBin[];\n  binMap: Record<number, AggregatedBin>;\n\n  constructor(bins = [], props: Partial<typeof defaultProps> = defaultProps) {\n    this.aggregatedBins = this.getAggregatedBins(bins, props);\n    this._updateMinMaxValues();\n    this.binMap = this.getBinMap();\n  }\n\n  /**\n   * Get an array of object with aggregated values and index of bins\n   * Array object will be sorted by value optionally.\n   * @param {Array} bins\n   * @param {Function} getValue\n   * @return {Array} array of values and index lookup\n   */\n  getAggregatedBins(bins, props): AggregatedBin[] {\n    const {\n      getValue = defaultGetValue,\n      getPoints = defaultGetPoints,\n      getIndex = defaultGetIndex,\n      filterData\n    } = props;\n\n    const hasFilter = typeof filterData === 'function';\n    const binCount = bins.length;\n    const aggregatedBins: AggregatedBin[] = [];\n    let index = 0;\n\n    for (let binIndex = 0; binIndex < binCount; binIndex++) {\n      const bin = bins[binIndex];\n      const points = getPoints(bin);\n      const i = getIndex(bin);\n\n      const filteredPoints = hasFilter ? points.filter(filterData) : points;\n\n      bin.filteredPoints = hasFilter ? filteredPoints : null;\n\n      const value = filteredPoints.length ? getValue(filteredPoints) : null;\n\n      if (value !== null && value !== undefined) {\n        // filter bins if value is null or undefined\n        aggregatedBins[index] = {\n          i: Number.isFinite(i) ? i : binIndex,\n          value,\n          counts: filteredPoints.length\n        };\n        index++;\n      }\n    }\n    return aggregatedBins;\n  }\n\n  _percentileToIndex(percentileRange): [number, number] {\n    const len = this.sortedBins.length;\n    if (len < 2) {\n      return [0, 0];\n    }\n\n    const [lower, upper] = percentileRange.map(n => clamp(n, 0, 100));\n\n    const lowerIdx = Math.ceil((lower / 100) * (len - 1));\n    const upperIdx = Math.floor((upper / 100) * (len - 1));\n\n    return [lowerIdx, upperIdx];\n  }\n\n  /**\n   * Get a mapping from cell/hexagon index to sorted bin\n   * This is used to retrieve bin value for color calculation\n   * @return {Object} bin index to aggregatedBins\n   */\n  getBinMap(): Record<number, AggregatedBin> {\n    const binMap = {};\n    for (const bin of this.aggregatedBins) {\n      binMap[bin.i] = bin;\n    }\n    return binMap;\n  }\n\n  // Private\n\n  /**\n   * Get ths max count of all bins\n   */\n  _updateMinMaxValues(): void {\n    let maxCount = 0;\n    let maxValue = 0;\n    let minValue = MAX_32_BIT_FLOAT;\n    let totalCount = 0;\n    for (const x of this.aggregatedBins) {\n      maxCount = maxCount > x.counts ? maxCount : x.counts;\n      maxValue = maxValue > x.value ? maxValue : x.value;\n      minValue = minValue < x.value ? minValue : x.value;\n      totalCount += x.counts;\n    }\n    this.maxCount = maxCount;\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n    this.totalCount = totalCount;\n  }\n\n  /**\n   * Get range of values of all bins\n   * @param {Number[]} range\n   * @param {Number} range[0] - lower bound\n   * @param {Number} range[1] - upper bound\n   * @return {Array} array of new value range\n   */\n  getValueRange(percentileRange: [number, number]): [number, number] {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n    if (!this.sortedBins.length) {\n      // @ts-expect-error\n      return [];\n    }\n    let lowerIdx = 0;\n    let upperIdx = this.sortedBins.length - 1;\n\n    if (Array.isArray(percentileRange)) {\n      const idxRange = this._percentileToIndex(percentileRange);\n      lowerIdx = idxRange[0];\n      upperIdx = idxRange[1];\n    }\n\n    return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];\n  }\n\n  getValueDomainByScale(scale: string, [lower = 0, upper = 100] = []) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n    if (!this.sortedBins.length) {\n      return [];\n    }\n    const indexEdge = this._percentileToIndex([lower, upper]);\n\n    return this._getScaleDomain(scale, indexEdge);\n  }\n\n  _getScaleDomain(scaleType: string, [lowerIdx, upperIdx]: [number, number]): [number, number] {\n    const bins = this.sortedBins;\n\n    switch (scaleType) {\n      case 'quantize':\n      case 'linear':\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n\n      case 'quantile':\n        return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), d => d.value);\n\n      case 'ordinal':\n        return getOrdinalDomain(bins, d => d.value) as [number, number];\n\n      default:\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}