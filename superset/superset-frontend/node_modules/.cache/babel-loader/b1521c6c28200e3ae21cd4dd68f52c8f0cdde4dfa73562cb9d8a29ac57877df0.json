{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isDefined, SupersetClient } from '../..';\nimport getChartBuildQueryRegistry from '../registries/ChartBuildQueryRegistrySingleton';\nimport getChartMetadataRegistry from '../registries/ChartMetadataRegistrySingleton';\nexport default class ChartClient {\n\n  constructor(config = {}) {this.client = void 0;\n    const { client = SupersetClient } = config;\n    this.client = client;\n  }\n  loadFormData(input, options) {\n    /* If sliceId is provided, use it to fetch stored formData from API */\n    if ('sliceId' in input) {\n      const promise = this.client.\n      get({\n        endpoint: `/api/v1/form_data/?slice_id=${input.sliceId}`,\n        ...options\n      }).\n      then((response) => response.json);\n      /*\n       * If formData is also specified, override API result\n       * with user-specified formData\n       */\n      return promise.then((dbFormData) => ({\n        ...dbFormData,\n        ...input.formData\n      }));\n    }\n    /* If sliceId is not provided, returned formData wrapped in a Promise */\n    return input.formData ?\n    Promise.resolve(input.formData) :\n    Promise.reject(new Error('At least one of sliceId or formData must be specified'));\n  }\n  async loadQueryData(formData, options) {\n    const { viz_type: visType } = formData;\n    const metaDataRegistry = getChartMetadataRegistry();\n    const buildQueryRegistry = getChartBuildQueryRegistry();\n    if (metaDataRegistry.has(visType)) {var _await$buildQueryRegi;\n      const { useLegacyApi } = metaDataRegistry.get(visType);\n      const buildQuery = (_await$buildQueryRegi = await buildQueryRegistry.get(visType)) != null ? _await$buildQueryRegi : () => formData;\n      const requestConfig = useLegacyApi ?\n      {\n        endpoint: '/superset/explore_json/',\n        postPayload: {\n          form_data: buildQuery(formData)\n        },\n        ...options\n      } :\n      {\n        endpoint: '/api/v1/chart/data',\n        jsonPayload: {\n          query_context: buildQuery(formData)\n        },\n        ...options\n      };\n      return this.client.\n      post(requestConfig).\n      then((response) => Array.isArray(response.json) ? response.json : [response.json]);\n    }\n    return Promise.reject(new Error(`Unknown chart type: ${visType}`));\n  }\n  loadDatasource(datasourceKey, options) {\n    return this.client.\n    get({\n      endpoint: `/superset/fetch_datasource_metadata?datasourceKey=${datasourceKey}`,\n      ...options\n    }).\n    then((response) => response.json);\n  }\n  // eslint-disable-next-line class-methods-use-this\n  loadAnnotation(annotationLayer) {\n    /* When annotation does not require query */\n    if (!isDefined(annotationLayer.sourceType)) {\n      return Promise.resolve({});\n    }\n    // TODO: Implement\n    return Promise.reject(new Error('This feature is not implemented yet.'));\n  }\n  loadAnnotations(annotationLayers) {\n    if (Array.isArray(annotationLayers) && annotationLayers.length > 0) {\n      return Promise.all(annotationLayers.map((layer) => this.loadAnnotation(layer))).then((results) => annotationLayers.reduce((prev, layer, i) => {\n        const output = prev;\n        output[layer.name] = results[i];\n        return output;\n      }, {}));\n    }\n    return Promise.resolve({});\n  }\n  loadChartData(input) {\n    return this.loadFormData(input).then((formData) => Promise.all([\n    this.loadAnnotations(formData.annotation_layers),\n    this.loadDatasource(formData.datasource),\n    this.loadQueryData(formData)]\n    ).then(([annotationData, datasource, queriesData]) => ({\n      annotationData,\n      datasource,\n      formData,\n      queriesData\n    })));\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ChartClient, \"ChartClient\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/chart/clients/ChartClient.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["isDefined","SupersetClient","getChartBuildQueryRegistry","getChartMetadataRegistry","ChartClient","constructor","config","client","loadFormData","input","options","promise","get","endpoint","sliceId","then","response","json","dbFormData","formData","Promise","resolve","reject","Error","loadQueryData","viz_type","visType","metaDataRegistry","buildQueryRegistry","has","_await$buildQueryRegi","useLegacyApi","buildQuery","requestConfig","postPayload","form_data","jsonPayload","query_context","post","Array","isArray","loadDatasource","datasourceKey","loadAnnotation","annotationLayer","sourceType","loadAnnotations","annotationLayers","length","all","map","layer","results","reduce","prev","i","output","name","loadChartData","annotation_layers","datasource","annotationData","queriesData","__reactstandin__regenerateByEval","key","code","eval","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/chart/clients/ChartClient.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport {\n  isDefined,\n  SupersetClient,\n  SupersetClientInterface,\n  RequestConfig,\n  SupersetClientClass,\n  QueryFormData,\n  Datasource,\n} from '../..';\nimport getChartBuildQueryRegistry from '../registries/ChartBuildQueryRegistrySingleton';\nimport getChartMetadataRegistry from '../registries/ChartMetadataRegistrySingleton';\nimport { QueryData } from '../types/QueryResponse';\nimport { AnnotationLayerMetadata } from '../types/Annotation';\nimport { PlainObject } from '../types/Base';\n\n// This expands to Partial<All> & (union of all possible single-property types)\ntype AtLeastOne<All, Each = { [K in keyof All]: Pick<All, K> }> = Partial<All> &\n  Each[keyof Each];\n\nexport type SliceIdAndOrFormData = AtLeastOne<{\n  sliceId: number;\n  formData: Partial<QueryFormData>;\n}>;\n\ninterface AnnotationData {\n  [key: string]: PlainObject;\n}\n\nexport interface ChartData {\n  annotationData: AnnotationData;\n  datasource: PlainObject;\n  formData: QueryFormData;\n  queriesData: QueryData[];\n}\n\nexport default class ChartClient {\n  readonly client: SupersetClientInterface | SupersetClientClass;\n\n  constructor(\n    config: {\n      client?: SupersetClientInterface | SupersetClientClass;\n    } = {},\n  ) {\n    const { client = SupersetClient } = config;\n    this.client = client;\n  }\n\n  loadFormData(\n    input: SliceIdAndOrFormData,\n    options?: Partial<RequestConfig>,\n  ): Promise<QueryFormData> {\n    /* If sliceId is provided, use it to fetch stored formData from API */\n    if ('sliceId' in input) {\n      const promise = this.client\n        .get({\n          endpoint: `/api/v1/form_data/?slice_id=${input.sliceId}`,\n          ...options,\n        } as RequestConfig)\n        .then(response => response.json as QueryFormData);\n\n      /*\n       * If formData is also specified, override API result\n       * with user-specified formData\n       */\n      return promise.then((dbFormData: QueryFormData) => ({\n        ...dbFormData,\n        ...input.formData,\n      }));\n    }\n\n    /* If sliceId is not provided, returned formData wrapped in a Promise */\n    return input.formData\n      ? Promise.resolve(input.formData as QueryFormData)\n      : Promise.reject(\n          new Error('At least one of sliceId or formData must be specified'),\n        );\n  }\n\n  async loadQueryData(\n    formData: QueryFormData,\n    options?: Partial<RequestConfig>,\n  ): Promise<QueryData[]> {\n    const { viz_type: visType } = formData;\n    const metaDataRegistry = getChartMetadataRegistry();\n    const buildQueryRegistry = getChartBuildQueryRegistry();\n\n    if (metaDataRegistry.has(visType)) {\n      const { useLegacyApi } = metaDataRegistry.get(visType)!;\n      const buildQuery =\n        (await buildQueryRegistry.get(visType)) ?? (() => formData);\n      const requestConfig: RequestConfig = useLegacyApi\n        ? {\n            endpoint: '/superset/explore_json/',\n            postPayload: {\n              form_data: buildQuery(formData),\n            },\n            ...options,\n          }\n        : {\n            endpoint: '/api/v1/chart/data',\n            jsonPayload: {\n              query_context: buildQuery(formData),\n            },\n            ...options,\n          };\n\n      return this.client\n        .post(requestConfig)\n        .then(response =>\n          Array.isArray(response.json) ? response.json : [response.json],\n        );\n    }\n\n    return Promise.reject(new Error(`Unknown chart type: ${visType}`));\n  }\n\n  loadDatasource(\n    datasourceKey: string,\n    options?: Partial<RequestConfig>,\n  ): Promise<Datasource> {\n    return this.client\n      .get({\n        endpoint: `/superset/fetch_datasource_metadata?datasourceKey=${datasourceKey}`,\n        ...options,\n      } as RequestConfig)\n      .then(response => response.json as Datasource);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  loadAnnotation(\n    annotationLayer: AnnotationLayerMetadata,\n  ): Promise<AnnotationData> {\n    /* When annotation does not require query */\n    if (!isDefined(annotationLayer.sourceType)) {\n      return Promise.resolve({} as AnnotationData);\n    }\n\n    // TODO: Implement\n    return Promise.reject(new Error('This feature is not implemented yet.'));\n  }\n\n  loadAnnotations(\n    annotationLayers?: AnnotationLayerMetadata[],\n  ): Promise<AnnotationData> {\n    if (Array.isArray(annotationLayers) && annotationLayers.length > 0) {\n      return Promise.all(\n        annotationLayers.map(layer => this.loadAnnotation(layer)),\n      ).then(results =>\n        annotationLayers.reduce((prev, layer, i) => {\n          const output: AnnotationData = prev;\n          output[layer.name] = results[i];\n\n          return output;\n        }, {}),\n      );\n    }\n\n    return Promise.resolve({});\n  }\n\n  loadChartData(input: SliceIdAndOrFormData): Promise<ChartData> {\n    return this.loadFormData(input).then(\n      (\n        formData: QueryFormData & {\n          // eslint-disable-next-line camelcase\n          annotation_layers?: AnnotationLayerMetadata[];\n        },\n      ) =>\n        Promise.all([\n          this.loadAnnotations(formData.annotation_layers),\n          this.loadDatasource(formData.datasource),\n          this.loadQueryData(formData),\n        ]).then(([annotationData, datasource, queriesData]) => ({\n          annotationData,\n          datasource,\n          formData,\n          queriesData,\n        })),\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}