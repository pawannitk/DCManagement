{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { addAlpha } from '@superset-ui/core';\nimport { Comparator, MultipleValueComparators } from '../types';\nexport const round = (num, precision = 0) => Number(`${Math.round(Number(`${num}e+${precision}`))}e-${precision}`);\nconst MIN_OPACITY_BOUNDED = 0.05;\nconst MIN_OPACITY_UNBOUNDED = 0;\nconst MAX_OPACITY = 1;\nexport const getOpacity = (value, cutoffPoint, extremeValue, minOpacity = MIN_OPACITY_BOUNDED, maxOpacity = MAX_OPACITY) => {\n  if (extremeValue === cutoffPoint) {\n    return maxOpacity;\n  }\n  return Math.min(maxOpacity, round(Math.abs((maxOpacity - minOpacity) / (extremeValue - cutoffPoint) * (\n  value - cutoffPoint)) + minOpacity, 2));\n};\nexport const getColorFunction = ({ operator, targetValue, targetValueLeft, targetValueRight, colorScheme }, columnValues, alpha) => {\n  let minOpacity = MIN_OPACITY_BOUNDED;\n  const maxOpacity = MAX_OPACITY;\n  let comparatorFunction;\n  if (operator === undefined || colorScheme === undefined) {\n    return () => undefined;\n  }\n  if (MultipleValueComparators.includes(operator) && (\n  targetValueLeft === undefined || targetValueRight === undefined)) {\n    return () => undefined;\n  }\n  if (operator !== Comparator.None &&\n  !MultipleValueComparators.includes(operator) &&\n  targetValue === undefined) {\n    return () => undefined;\n  }\n  switch (operator) {\n    case Comparator.None:\n      minOpacity = MIN_OPACITY_UNBOUNDED;\n      comparatorFunction = (value, allValues) => {\n        const cutoffValue = Math.min(...allValues);\n        const extremeValue = Math.max(...allValues);\n        return value >= cutoffValue && value <= extremeValue ?\n        { cutoffValue, extremeValue } :\n        false;\n      };\n      break;\n    case Comparator.GreaterThan:\n      comparatorFunction = (value, allValues) => value > targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.max(...allValues) } :\n      false;\n      break;\n    case Comparator.LessThan:\n      comparatorFunction = (value, allValues) => value < targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.min(...allValues) } :\n      false;\n      break;\n    case Comparator.GreaterOrEqual:\n      comparatorFunction = (value, allValues) => value >= targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.max(...allValues) } :\n      false;\n      break;\n    case Comparator.LessOrEqual:\n      comparatorFunction = (value, allValues) => value <= targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.min(...allValues) } :\n      false;\n      break;\n    case Comparator.Equal:\n      comparatorFunction = (value) => value === targetValue ?\n      { cutoffValue: targetValue, extremeValue: targetValue } :\n      false;\n      break;\n    case Comparator.NotEqual:\n      comparatorFunction = (value, allValues) => {\n        if (value === targetValue) {\n          return false;\n        }\n        const max = Math.max(...allValues);\n        const min = Math.min(...allValues);\n        return {\n          cutoffValue: targetValue,\n          extremeValue: Math.abs(targetValue - min) > Math.abs(max - targetValue) ?\n          min :\n          max\n        };\n      };\n      break;\n    case Comparator.Between:\n      comparatorFunction = (value) => value > targetValueLeft && value < targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    case Comparator.BetweenOrEqual:\n      comparatorFunction = (value) => value >= targetValueLeft && value <= targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    case Comparator.BetweenOrLeftEqual:\n      comparatorFunction = (value) => value >= targetValueLeft && value < targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    case Comparator.BetweenOrRightEqual:\n      comparatorFunction = (value) => value > targetValueLeft && value <= targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    default:\n      comparatorFunction = () => false;\n      break;\n  }\n  return (value) => {\n    const compareResult = comparatorFunction(value, columnValues);\n    if (compareResult === false)\n    return undefined;\n    const { cutoffValue, extremeValue } = compareResult;\n    if (alpha === undefined || alpha) {\n      return addAlpha(colorScheme, getOpacity(value, cutoffValue, extremeValue, minOpacity, maxOpacity));\n    }\n    return colorScheme;\n  };\n};\nexport const getColorFormatters = memoizeOne((columnConfig, data, alpha) => {var _columnConfig$reduce;return (_columnConfig$reduce = columnConfig == null ? void 0 : columnConfig.reduce((acc, config) => {\n    if ((config == null ? void 0 : config.column) !== undefined && (\n    (config == null ? void 0 : config.operator) === Comparator.None ||\n    (config == null ? void 0 : config.operator) !== undefined && (\n    MultipleValueComparators.includes(config == null ? void 0 : config.operator) ?\n    (config == null ? void 0 : config.targetValueLeft) !== undefined &&\n    (config == null ? void 0 : config.targetValueRight) !== undefined :\n    (config == null ? void 0 : config.targetValue) !== undefined))) {\n      acc.push({\n        column: config == null ? void 0 : config.column,\n        getColorFromValue: getColorFunction(config, data.map((row) => row[config.column]), alpha)\n      });\n    }\n    return acc;\n  }, [])) != null ? _columnConfig$reduce : [];});;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(round, \"round\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(MIN_OPACITY_BOUNDED, \"MIN_OPACITY_BOUNDED\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(MIN_OPACITY_UNBOUNDED, \"MIN_OPACITY_UNBOUNDED\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(MAX_OPACITY, \"MAX_OPACITY\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(getOpacity, \"getOpacity\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(getColorFunction, \"getColorFunction\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(getColorFormatters, \"getColorFormatters\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["memoizeOne","addAlpha","Comparator","MultipleValueComparators","round","num","precision","Number","Math","MIN_OPACITY_BOUNDED","MIN_OPACITY_UNBOUNDED","MAX_OPACITY","getOpacity","value","cutoffPoint","extremeValue","minOpacity","maxOpacity","min","abs","getColorFunction","operator","targetValue","targetValueLeft","targetValueRight","colorScheme","columnValues","alpha","comparatorFunction","undefined","includes","None","allValues","cutoffValue","max","GreaterThan","LessThan","GreaterOrEqual","LessOrEqual","Equal","NotEqual","Between","BetweenOrEqual","BetweenOrLeftEqual","BetweenOrRightEqual","compareResult","getColorFormatters","columnConfig","data","_columnConfig$reduce","reduce","acc","config","column","push","getColorFromValue","map","row","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { addAlpha, DataRecord } from '@superset-ui/core';\nimport {\n  ColorFormatters,\n  Comparator,\n  ConditionalFormattingConfig,\n  MultipleValueComparators,\n} from '../types';\n\nexport const round = (num: number, precision = 0) =>\n  Number(`${Math.round(Number(`${num}e+${precision}`))}e-${precision}`);\n\nconst MIN_OPACITY_BOUNDED = 0.05;\nconst MIN_OPACITY_UNBOUNDED = 0;\nconst MAX_OPACITY = 1;\nexport const getOpacity = (\n  value: number,\n  cutoffPoint: number,\n  extremeValue: number,\n  minOpacity = MIN_OPACITY_BOUNDED,\n  maxOpacity = MAX_OPACITY,\n) => {\n  if (extremeValue === cutoffPoint) {\n    return maxOpacity;\n  }\n  return Math.min(\n    maxOpacity,\n    round(\n      Math.abs(\n        ((maxOpacity - minOpacity) / (extremeValue - cutoffPoint)) *\n          (value - cutoffPoint),\n      ) + minOpacity,\n      2,\n    ),\n  );\n};\n\nexport const getColorFunction = (\n  {\n    operator,\n    targetValue,\n    targetValueLeft,\n    targetValueRight,\n    colorScheme,\n  }: ConditionalFormattingConfig,\n  columnValues: number[],\n  alpha?: boolean,\n) => {\n  let minOpacity = MIN_OPACITY_BOUNDED;\n  const maxOpacity = MAX_OPACITY;\n\n  let comparatorFunction: (\n    value: number,\n    allValues: number[],\n  ) => false | { cutoffValue: number; extremeValue: number };\n  if (operator === undefined || colorScheme === undefined) {\n    return () => undefined;\n  }\n  if (\n    MultipleValueComparators.includes(operator) &&\n    (targetValueLeft === undefined || targetValueRight === undefined)\n  ) {\n    return () => undefined;\n  }\n  if (\n    operator !== Comparator.None &&\n    !MultipleValueComparators.includes(operator) &&\n    targetValue === undefined\n  ) {\n    return () => undefined;\n  }\n  switch (operator) {\n    case Comparator.None:\n      minOpacity = MIN_OPACITY_UNBOUNDED;\n      comparatorFunction = (value: number, allValues: number[]) => {\n        const cutoffValue = Math.min(...allValues);\n        const extremeValue = Math.max(...allValues);\n        return value >= cutoffValue && value <= extremeValue\n          ? { cutoffValue, extremeValue }\n          : false;\n      };\n      break;\n    case Comparator.GreaterThan:\n      comparatorFunction = (value: number, allValues: number[]) =>\n        value > targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: Math.max(...allValues) }\n          : false;\n      break;\n    case Comparator.LessThan:\n      comparatorFunction = (value: number, allValues: number[]) =>\n        value < targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: Math.min(...allValues) }\n          : false;\n      break;\n    case Comparator.GreaterOrEqual:\n      comparatorFunction = (value: number, allValues: number[]) =>\n        value >= targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: Math.max(...allValues) }\n          : false;\n      break;\n    case Comparator.LessOrEqual:\n      comparatorFunction = (value: number, allValues: number[]) =>\n        value <= targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: Math.min(...allValues) }\n          : false;\n      break;\n    case Comparator.Equal:\n      comparatorFunction = (value: number) =>\n        value === targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: targetValue! }\n          : false;\n      break;\n    case Comparator.NotEqual:\n      comparatorFunction = (value: number, allValues: number[]) => {\n        if (value === targetValue!) {\n          return false;\n        }\n        const max = Math.max(...allValues);\n        const min = Math.min(...allValues);\n        return {\n          cutoffValue: targetValue!,\n          extremeValue:\n            Math.abs(targetValue! - min) > Math.abs(max - targetValue!)\n              ? min\n              : max,\n        };\n      };\n      break;\n    case Comparator.Between:\n      comparatorFunction = (value: number) =>\n        value > targetValueLeft! && value < targetValueRight!\n          ? { cutoffValue: targetValueLeft!, extremeValue: targetValueRight! }\n          : false;\n      break;\n    case Comparator.BetweenOrEqual:\n      comparatorFunction = (value: number) =>\n        value >= targetValueLeft! && value <= targetValueRight!\n          ? { cutoffValue: targetValueLeft!, extremeValue: targetValueRight! }\n          : false;\n      break;\n    case Comparator.BetweenOrLeftEqual:\n      comparatorFunction = (value: number) =>\n        value >= targetValueLeft! && value < targetValueRight!\n          ? { cutoffValue: targetValueLeft!, extremeValue: targetValueRight! }\n          : false;\n      break;\n    case Comparator.BetweenOrRightEqual:\n      comparatorFunction = (value: number) =>\n        value > targetValueLeft! && value <= targetValueRight!\n          ? { cutoffValue: targetValueLeft!, extremeValue: targetValueRight! }\n          : false;\n      break;\n    default:\n      comparatorFunction = () => false;\n      break;\n  }\n\n  return (value: number) => {\n    const compareResult = comparatorFunction(value, columnValues);\n    if (compareResult === false) return undefined;\n    const { cutoffValue, extremeValue } = compareResult;\n    if (alpha === undefined || alpha) {\n      return addAlpha(\n        colorScheme,\n        getOpacity(value, cutoffValue, extremeValue, minOpacity, maxOpacity),\n      );\n    }\n    return colorScheme;\n  };\n};\n\nexport const getColorFormatters = memoizeOne(\n  (\n    columnConfig: ConditionalFormattingConfig[] | undefined,\n    data: DataRecord[],\n    alpha?: boolean,\n  ) =>\n    columnConfig?.reduce(\n      (acc: ColorFormatters, config: ConditionalFormattingConfig) => {\n        if (\n          config?.column !== undefined &&\n          (config?.operator === Comparator.None ||\n            (config?.operator !== undefined &&\n              (MultipleValueComparators.includes(config?.operator)\n                ? config?.targetValueLeft !== undefined &&\n                  config?.targetValueRight !== undefined\n                : config?.targetValue !== undefined)))\n        ) {\n          acc.push({\n            column: config?.column,\n            getColorFromValue: getColorFunction(\n              config,\n              data.map(row => row[config.column!] as number),\n              alpha,\n            ),\n          });\n        }\n        return acc;\n      },\n      [],\n    ) ?? [],\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}