{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _uniq from \"lodash/uniq\";import _isEqual from \"lodash/isEqual\";import _debounce from \"lodash/debounce\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { forwardRef, useEffect, useMemo, useState, useRef, useCallback, useImperativeHandle } from 'react';\nimport { ensureIsArray, t, usePrevious, getClientErrorObject } from '@superset-ui/core';\n\nimport Icons from 'src/components/Icons';\nimport { FAST_DEBOUNCE, SLOW_DEBOUNCE } from 'src/constants';\nimport { getValue, hasOption, isLabeledValue, renderSelectOptions, hasCustomLabels, sortSelectedFirstHelper, sortComparatorWithSearchHelper, sortComparatorForNoSearchHelper, getSuffixIcon, dropDownRenderHelper, handleFilterOptionHelper, mapOptions, getOption, isObject, isEqual as utilsIsEqual } from './utils';\nimport { StyledCheckOutlined, StyledContainer, StyledError, StyledErrorMessage, StyledHeader, StyledSelect, StyledStopOutlined } from './styles';\nimport { DEFAULT_PAGE_SIZE, EMPTY_OPTIONS, MAX_TAG_COUNT, TOKEN_SEPARATORS, DEFAULT_SORT_COMPARATOR } from './constants';\nimport { customTagRender } from './CustomTag';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst Error = ({ error }) => ___EmotionJSX(StyledError, null,\n___EmotionJSX(Icons.ErrorSolid, null), \" \", ___EmotionJSX(StyledErrorMessage, null, error)\n);\nconst getQueryCacheKey = (value, page, pageSize) => `${value};${page};${pageSize}`;\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst AsyncSelect = /*#__PURE__*/forwardRef(__signature__(({ allowClear, allowNewOptions = false, ariaLabel, autoClearSearchValue = false, fetchOnlyOnSearch, filterOption = true, header = null, headerPosition = 'top', helperText, invertSelection = false, lazyLoading = true, loading, mode = 'single', name, notFoundContent, onBlur, onError, onChange, onClear, onDropdownVisibleChange, onDeselect, onSearch, onSelect, optionFilterProps = ['label', 'value'], options, pageSize = DEFAULT_PAGE_SIZE, placeholder = t('Select ...'), showSearch = true, sortComparator = DEFAULT_SORT_COMPARATOR, tokenSeparators = TOKEN_SEPARATORS, value, getPopupContainer, oneLine, maxTagCount: propsMaxTagCount, ...props }, ref) => {\n  const isSingleMode = mode === 'single';\n  const [selectValue, setSelectValue] = useState(value);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [error, setError] = useState('');\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [page, setPage] = useState(0);\n  const [totalCount, setTotalCount] = useState(0);\n  const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n  const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n  const selectValueRef = useRef(selectValue);\n  const fetchedQueries = useRef(new Map());\n  const mappedMode = isSingleMode ? undefined : 'multiple';\n  const allowFetch = !fetchOnlyOnSearch || inputValue;\n  const [maxTagCount, setMaxTagCount] = useState(propsMaxTagCount != null ? propsMaxTagCount : MAX_TAG_COUNT);\n  const [onChangeCount, setOnChangeCount] = useState(0);\n  const previousChangeCount = usePrevious(onChangeCount, 0);\n  const fireOnChange = useCallback(() => setOnChangeCount(onChangeCount + 1), [onChangeCount]);\n  useEffect(() => {\n    if (oneLine) {\n      setMaxTagCount(isDropdownVisible ? 0 : 1);\n    }\n  }, [isDropdownVisible, oneLine]);\n  useEffect(() => {\n    selectValueRef.current = selectValue;\n  }, [selectValue]);\n  const sortSelectedFirst = useCallback((a, b) => sortSelectedFirstHelper(a, b, selectValueRef.current), []);\n  const sortComparatorWithSearch = useCallback((a, b) => sortComparatorWithSearchHelper(a, b, inputValue, sortSelectedFirst, sortComparator), [inputValue, sortComparator, sortSelectedFirst]);\n  const sortComparatorForNoSearch = useCallback((a, b) => sortComparatorForNoSearchHelper(a, b, sortSelectedFirst, sortComparator), [sortComparator, sortSelectedFirst]);\n  const [selectOptions, setSelectOptions] = useState(EMPTY_OPTIONS);\n  // add selected values to options list if they are not in it\n  const fullSelectOptions = useMemo(() => {\n    const missingValues = ensureIsArray(selectValue).\n    filter((opt) => !hasOption(getValue(opt), selectOptions)).\n    map((opt) => isLabeledValue(opt) ? opt : { value: opt, label: String(opt) });\n    return missingValues.length > 0 ?\n    missingValues.concat(selectOptions) :\n    selectOptions;\n  }, [selectOptions, selectValue]);\n  const handleOnSelect = (selectedItem, option) => {\n    if (isSingleMode) {\n      // on select is fired in single value mode if the same value is selected\n      const valueChanged = !utilsIsEqual(selectedItem, selectValue, 'value');\n      setSelectValue(selectedItem);\n      if (valueChanged) {\n        fireOnChange();\n      }\n    } else\n    {\n      setSelectValue((previousState) => {\n        const array = ensureIsArray(previousState);\n        const value = getValue(selectedItem);\n        // Tokenized values can contain duplicated values\n        if (!hasOption(value, array)) {\n          const result = [...array, selectedItem];\n          return isLabeledValue(selectedItem) ?\n          result :\n          result;\n        }\n        return previousState;\n      });\n      fireOnChange();\n    }\n    onSelect == null ? void 0 : onSelect(selectedItem, option);\n  };\n  const handleOnDeselect = (value, option) => {\n    if (Array.isArray(selectValue)) {\n      if (isLabeledValue(value)) {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element.value !== value.value));\n      } else\n      {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element !== value));\n      }\n      // removes new option\n      if (option.isNewOption) {\n        setSelectOptions(fullSelectOptions.filter((option) => getValue(option.value) !== getValue(value)));\n      }\n    }\n    fireOnChange();\n    onDeselect == null ? void 0 : onDeselect(value, option);\n  };\n  const internalOnError = useCallback((response) => getClientErrorObject(response).then((e) => {\n    const { error } = e;\n    setError(error);\n    if (onError) {\n      onError(error);\n    }\n  }), [onError]);\n  const mergeData = useCallback((data) => {\n    let mergedData = [];\n    if (data && Array.isArray(data) && data.length) {\n      // unique option values should always be case sensitive so don't lowercase\n      const dataValues = new Set(data.map((opt) => opt.value));\n      // merges with existing and creates unique options\n      setSelectOptions((prevOptions) => {\n        mergedData = prevOptions.\n        filter((previousOption) => !dataValues.has(previousOption.value)).\n        concat(data).\n        sort(sortComparatorForNoSearch);\n        return mergedData;\n      });\n    }\n    return mergedData;\n  }, [sortComparatorForNoSearch]);\n  const fetchPage = useMemo(() => (search, page) => {\n    setPage(page);\n    if (allValuesLoaded) {\n      setIsLoading(false);\n      return;\n    }\n    const key = getQueryCacheKey(search, page, pageSize);\n    const cachedCount = fetchedQueries.current.get(key);\n    if (cachedCount !== undefined) {\n      setTotalCount(cachedCount);\n      setIsLoading(false);\n      return;\n    }\n    setIsLoading(true);\n    const fetchOptions = options;\n    fetchOptions(search, page, pageSize).\n    then(({ data, totalCount }) => {\n      const mergedData = mergeData(data);\n      fetchedQueries.current.set(key, totalCount);\n      setTotalCount(totalCount);\n      if (!fetchOnlyOnSearch &&\n      search === '' &&\n      mergedData.length >= totalCount) {\n        setAllValuesLoaded(true);\n      }\n    }).\n    catch(internalOnError).\n    finally(() => {\n      setIsLoading(false);\n    });\n  }, [\n  allValuesLoaded,\n  fetchOnlyOnSearch,\n  mergeData,\n  internalOnError,\n  options,\n  pageSize]\n  );\n  const debouncedFetchPage = useMemo(() => _debounce(fetchPage, SLOW_DEBOUNCE), [fetchPage]);\n  const handleOnSearch = _debounce((search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, fullSelectOptions, true) && {\n        label: searchValue,\n        value: searchValue,\n        isNewOption: true\n      };\n      const cleanSelectOptions = fullSelectOptions.filter((opt) => !opt.isNewOption || hasOption(opt.value, selectValue));\n      const newOptions = newOption ?\n      [newOption, ...cleanSelectOptions] :\n      cleanSelectOptions;\n      setSelectOptions(newOptions);\n    }\n    if (!allValuesLoaded &&\n    loadingEnabled &&\n    !fetchedQueries.current.has(getQueryCacheKey(searchValue, 0, pageSize))) {\n      // if fetch only on search but search value is empty, then should not be\n      // in loading state\n      setIsLoading(!(fetchOnlyOnSearch && !searchValue));\n    }\n    setInputValue(search);\n    onSearch == null ? void 0 : onSearch(searchValue);\n  }, FAST_DEBOUNCE);\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n  const handlePagination = (e) => {\n    const vScroll = e.currentTarget;\n    const thresholdReached = vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n    const hasMoreData = page * pageSize + pageSize < totalCount;\n    if (!isLoading && hasMoreData && thresholdReached) {\n      const newPage = page + 1;\n      fetchPage(inputValue, newPage);\n    }\n  };\n  const handleFilterOption = (search, option) => handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    // loading is enabled when dropdown is open,\n    // disabled when dropdown is closed\n    if (loadingEnabled !== isDropdownVisible) {\n      setLoadingEnabled(isDropdownVisible);\n    }\n    // when closing dropdown, always reset loading state\n    if (!isDropdownVisible && isLoading) {\n      // delay is for the animation of closing the dropdown\n      // so the dropdown doesn't flash between \"Loading...\" and \"No data\"\n      // before closing.\n      setTimeout(() => {\n        setIsLoading(false);\n      }, 250);\n    }\n    // if no search input value, force sort options because it won't be sorted by\n    // `filterSort`.\n    if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n      const sortedOptions = selectOptions.\n      slice().\n      sort(sortComparatorForNoSearch);\n      if (!_isEqual(sortedOptions, selectOptions)) {\n        setSelectOptions(sortedOptions);\n      }\n    }\n    if (onDropdownVisibleChange) {\n      onDropdownVisibleChange(isDropdownVisible);\n    }\n  };\n  const dropdownRender = (originNode) => dropDownRenderHelper(originNode, isDropdownVisible, isLoading, fullSelectOptions.length, helperText, error ? ___EmotionJSX(Error, { error: error }) : undefined);\n  const handleClear = () => {\n    setSelectValue(undefined);\n    if (onClear) {\n      onClear();\n    }\n    fireOnChange();\n  };\n  const handleOnBlur = (event) => {\n    setInputValue('');\n    onBlur == null ? void 0 : onBlur(event);\n  };\n  useEffect(() => {\n    if (onChangeCount !== previousChangeCount) {\n      const array = ensureIsArray(selectValue);\n      const set = new Set(array.map(getValue));\n      const options = mapOptions(fullSelectOptions.filter((opt) => set.has(opt.value)));\n      if (isSingleMode) {\n        // @ts-ignore\n        onChange == null ? void 0 : onChange(selectValue, options[0]);\n      } else\n      {\n        // @ts-ignore\n        onChange == null ? void 0 : onChange(array, options);\n      }\n    }\n  }, [\n  fullSelectOptions,\n  isSingleMode,\n  onChange,\n  onChangeCount,\n  previousChangeCount,\n  selectValue]\n  );\n  useEffect(() => {\n    // when `options` list is updated from component prop, reset states\n    fetchedQueries.current.clear();\n    setAllValuesLoaded(false);\n    setSelectOptions(EMPTY_OPTIONS);\n  }, [options]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  // Stop the invocation of the debounced function after unmounting\n  useEffect(() => () => {\n    debouncedFetchPage.cancel();\n  }, [debouncedFetchPage]);\n  useEffect(() => {\n    if (loadingEnabled && allowFetch) {\n      // trigger fetch every time inputValue changes\n      if (inputValue) {\n        debouncedFetchPage(inputValue, 0);\n      } else\n      {\n        fetchPage('', 0);\n      }\n    }\n  }, [loadingEnabled, fetchPage, allowFetch, inputValue, debouncedFetchPage]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  const clearCache = () => fetchedQueries.current.clear();\n  useImperativeHandle(ref, () => ({\n    ...ref.current,\n    clearCache\n  }), [ref]);\n  const getPastedTextValue = useCallback(async (text) => {\n    let option = getOption(text, fullSelectOptions, true);\n    if (!option && !allValuesLoaded) {\n      const fetchOptions = options;\n      option = await fetchOptions(text, 0, pageSize).then(({ data }) => data.find((item) => item.label === text));\n    }\n    if (!option && !allowNewOptions) {\n      return undefined;\n    }\n    const value = {\n      label: text,\n      value: text\n    };\n    if (option) {\n      value.label = isObject(option) ? option.label : option;\n      value.value = isObject(option) ? option.value : option;\n    }\n    return value;\n  }, [allValuesLoaded, allowNewOptions, fullSelectOptions, options, pageSize]);\n  const onPaste = async (e) => {\n    const pastedText = e.clipboardData.getData('text');\n    if (isSingleMode) {\n      const value = await getPastedTextValue(pastedText);\n      if (value) {\n        setSelectValue(value);\n      }\n    } else\n    {\n      const token = tokenSeparators.find((token) => pastedText.includes(token));\n      const array = token ? _uniq(pastedText.split(token)) : [pastedText];\n      const values = (await Promise.all(array.map((item) => getPastedTextValue(item)))).filter((item) => item !== undefined);\n      setSelectValue((previous) => [\n      ...(previous || []),\n      ...values.filter((value) => !hasOption(value.value, previous))]\n      );\n    }\n    fireOnChange();\n  };\n  const shouldRenderChildrenOptions = useMemo(() => hasCustomLabels(fullSelectOptions), [fullSelectOptions]);\n  return ___EmotionJSX(StyledContainer, { headerPosition: headerPosition },\n  header && ___EmotionJSX(StyledHeader, { headerPosition: headerPosition }, header),\n  ___EmotionJSX(StyledSelect, _extends({ allowClear: !isLoading && allowClear, \"aria-label\": ariaLabel || name, autoClearSearchValue: autoClearSearchValue, dropdownRender: dropdownRender, filterOption: handleFilterOption, filterSort: sortComparatorWithSearch, getPopupContainer: getPopupContainer || ((triggerNode) => triggerNode.parentNode), headerPosition: headerPosition, labelInValue: true, maxTagCount: maxTagCount, mode: mappedMode, notFoundContent: isLoading ? t('Loading...') : notFoundContent, onBlur: handleOnBlur, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange\n    // @ts-ignore\n    , onPaste: onPaste, onPopupScroll: handlePagination, onSearch: showSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, options: shouldRenderChildrenOptions ? undefined : fullSelectOptions, placeholder: placeholder, showSearch: showSearch, showArrow: true, tokenSeparators: tokenSeparators, value: selectValue, suffixIcon: getSuffixIcon(isLoading, showSearch, isDropdownVisible), menuItemSelectedIcon: invertSelection ? ___EmotionJSX(StyledStopOutlined, { iconSize: \"m\", \"aria-label\": \"stop\" }) : ___EmotionJSX(StyledCheckOutlined, { iconSize: \"m\", \"aria-label\": \"check\" }), oneLine: oneLine, tagRender: customTagRender }, props, { ref: ref }),\n  hasCustomLabels(fullSelectOptions) &&\n  renderSelectOptions(fullSelectOptions)\n  )\n  );\n}, \"useState{[selectValue, setSelectValue](value)}\\nuseState{[inputValue, setInputValue]('')}\\nuseState{[isLoading, setIsLoading](loading)}\\nuseState{[error, setError]('')}\\nuseState{[isDropdownVisible, setIsDropdownVisible](false)}\\nuseState{[page, setPage](0)}\\nuseState{[totalCount, setTotalCount](0)}\\nuseState{[loadingEnabled, setLoadingEnabled](!lazyLoading)}\\nuseState{[allValuesLoaded, setAllValuesLoaded](false)}\\nuseRef{selectValueRef}\\nuseRef{fetchedQueries}\\nuseState{[maxTagCount, setMaxTagCount](propsMaxTagCount ?? MAX_TAG_COUNT)}\\nuseState{[onChangeCount, setOnChangeCount](0)}\\nusePrevious{previousChangeCount}\\nuseCallback{fireOnChange}\\nuseEffect{}\\nuseEffect{}\\nuseCallback{sortSelectedFirst}\\nuseCallback{sortComparatorWithSearch}\\nuseCallback{sortComparatorForNoSearch}\\nuseState{[selectOptions, setSelectOptions](EMPTY_OPTIONS)}\\nuseMemo{fullSelectOptions}\\nuseCallback{internalOnError}\\nuseCallback{mergeData}\\nuseMemo{fetchPage}\\nuseMemo{debouncedFetchPage}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseImperativeHandle{}\\nuseCallback{getPastedTextValue}\\nuseMemo{shouldRenderChildrenOptions}\", () => [usePrevious, useImperativeHandle]));const _default =\nAsyncSelect;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Error, \"Error\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/components/Select/AsyncSelect.tsx\");reactHotLoader.register(getQueryCacheKey, \"getQueryCacheKey\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/components/Select/AsyncSelect.tsx\");reactHotLoader.register(AsyncSelect, \"AsyncSelect\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/components/Select/AsyncSelect.tsx\");reactHotLoader.register(_default, \"default\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/components/Select/AsyncSelect.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["React","forwardRef","useEffect","useMemo","useState","useRef","useCallback","useImperativeHandle","ensureIsArray","t","usePrevious","getClientErrorObject","Icons","FAST_DEBOUNCE","SLOW_DEBOUNCE","getValue","hasOption","isLabeledValue","renderSelectOptions","hasCustomLabels","sortSelectedFirstHelper","sortComparatorWithSearchHelper","sortComparatorForNoSearchHelper","getSuffixIcon","dropDownRenderHelper","handleFilterOptionHelper","mapOptions","getOption","isObject","isEqual","utilsIsEqual","StyledCheckOutlined","StyledContainer","StyledError","StyledErrorMessage","StyledHeader","StyledSelect","StyledStopOutlined","DEFAULT_PAGE_SIZE","EMPTY_OPTIONS","MAX_TAG_COUNT","TOKEN_SEPARATORS","DEFAULT_SORT_COMPARATOR","customTagRender","jsx","___EmotionJSX","Error","error","ErrorSolid","getQueryCacheKey","value","page","pageSize","AsyncSelect","__signature__","allowClear","allowNewOptions","ariaLabel","autoClearSearchValue","fetchOnlyOnSearch","filterOption","header","headerPosition","helperText","invertSelection","lazyLoading","loading","mode","name","notFoundContent","onBlur","onError","onChange","onClear","onDropdownVisibleChange","onDeselect","onSearch","onSelect","optionFilterProps","options","placeholder","showSearch","sortComparator","tokenSeparators","getPopupContainer","oneLine","maxTagCount","propsMaxTagCount","props","ref","isSingleMode","selectValue","setSelectValue","inputValue","setInputValue","isLoading","setIsLoading","setError","isDropdownVisible","setIsDropdownVisible","setPage","totalCount","setTotalCount","loadingEnabled","setLoadingEnabled","allValuesLoaded","setAllValuesLoaded","selectValueRef","fetchedQueries","Map","mappedMode","undefined","allowFetch","setMaxTagCount","onChangeCount","setOnChangeCount","previousChangeCount","fireOnChange","current","sortSelectedFirst","a","b","sortComparatorWithSearch","sortComparatorForNoSearch","selectOptions","setSelectOptions","fullSelectOptions","missingValues","filter","opt","map","label","String","length","concat","handleOnSelect","selectedItem","option","valueChanged","previousState","array","result","handleOnDeselect","Array","isArray","element","isNewOption","internalOnError","response","then","e","mergeData","data","mergedData","dataValues","Set","prevOptions","previousOption","has","sort","fetchPage","search","key","cachedCount","get","fetchOptions","set","catch","finally","debouncedFetchPage","_debounce","handleOnSearch","searchValue","trim","newOption","cleanSelectOptions","newOptions","cancel","handlePagination","vScroll","currentTarget","thresholdReached","scrollTop","scrollHeight","offsetHeight","hasMoreData","newPage","handleFilterOption","handleOnDropdownVisibleChange","setTimeout","sortedOptions","slice","_isEqual","dropdownRender","originNode","handleClear","handleOnBlur","event","clear","clearCache","getPastedTextValue","text","find","item","onPaste","pastedText","clipboardData","getData","token","includes","_uniq","split","values","Promise","all","previous","shouldRenderChildrenOptions","_extends","filterSort","triggerNode","parentNode","labelInValue","onPopupScroll","showArrow","suffixIcon","menuItemSelectedIcon","iconSize","tagRender","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/src/components/Select/AsyncSelect.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, {\n  forwardRef,\n  ReactElement,\n  RefObject,\n  UIEvent,\n  useEffect,\n  useMemo,\n  useState,\n  useRef,\n  useCallback,\n  useImperativeHandle,\n  ClipboardEvent,\n} from 'react';\nimport {\n  ensureIsArray,\n  t,\n  usePrevious,\n  getClientErrorObject,\n} from '@superset-ui/core';\nimport { LabeledValue as AntdLabeledValue } from 'antd/lib/select';\nimport { debounce, isEqual, uniq } from 'lodash';\nimport Icons from 'src/components/Icons';\nimport { FAST_DEBOUNCE, SLOW_DEBOUNCE } from 'src/constants';\nimport {\n  getValue,\n  hasOption,\n  isLabeledValue,\n  renderSelectOptions,\n  hasCustomLabels,\n  sortSelectedFirstHelper,\n  sortComparatorWithSearchHelper,\n  sortComparatorForNoSearchHelper,\n  getSuffixIcon,\n  dropDownRenderHelper,\n  handleFilterOptionHelper,\n  mapOptions,\n  getOption,\n  isObject,\n  isEqual as utilsIsEqual,\n} from './utils';\nimport {\n  AsyncSelectProps,\n  AsyncSelectRef,\n  RawValue,\n  SelectOptionsPagePromise,\n  SelectOptionsType,\n  SelectOptionsTypePage,\n  SelectProps,\n} from './types';\nimport {\n  StyledCheckOutlined,\n  StyledContainer,\n  StyledError,\n  StyledErrorMessage,\n  StyledHeader,\n  StyledSelect,\n  StyledStopOutlined,\n} from './styles';\nimport {\n  DEFAULT_PAGE_SIZE,\n  EMPTY_OPTIONS,\n  MAX_TAG_COUNT,\n  TOKEN_SEPARATORS,\n  DEFAULT_SORT_COMPARATOR,\n} from './constants';\nimport { customTagRender } from './CustomTag';\n\nconst Error = ({ error }: { error: string }) => (\n  <StyledError>\n    <Icons.ErrorSolid /> <StyledErrorMessage>{error}</StyledErrorMessage>\n  </StyledError>\n);\n\nconst getQueryCacheKey = (value: string, page: number, pageSize: number) =>\n  `${value};${page};${pageSize}`;\n\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst AsyncSelect = forwardRef(\n  (\n    {\n      allowClear,\n      allowNewOptions = false,\n      ariaLabel,\n      autoClearSearchValue = false,\n      fetchOnlyOnSearch,\n      filterOption = true,\n      header = null,\n      headerPosition = 'top',\n      helperText,\n      invertSelection = false,\n      lazyLoading = true,\n      loading,\n      mode = 'single',\n      name,\n      notFoundContent,\n      onBlur,\n      onError,\n      onChange,\n      onClear,\n      onDropdownVisibleChange,\n      onDeselect,\n      onSearch,\n      onSelect,\n      optionFilterProps = ['label', 'value'],\n      options,\n      pageSize = DEFAULT_PAGE_SIZE,\n      placeholder = t('Select ...'),\n      showSearch = true,\n      sortComparator = DEFAULT_SORT_COMPARATOR,\n      tokenSeparators = TOKEN_SEPARATORS,\n      value,\n      getPopupContainer,\n      oneLine,\n      maxTagCount: propsMaxTagCount,\n      ...props\n    }: AsyncSelectProps,\n    ref: RefObject<AsyncSelectRef>,\n  ) => {\n    const isSingleMode = mode === 'single';\n    const [selectValue, setSelectValue] = useState(value);\n    const [inputValue, setInputValue] = useState('');\n    const [isLoading, setIsLoading] = useState(loading);\n    const [error, setError] = useState('');\n    const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n    const [page, setPage] = useState(0);\n    const [totalCount, setTotalCount] = useState(0);\n    const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n    const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n    const selectValueRef = useRef(selectValue);\n    const fetchedQueries = useRef(new Map<string, number>());\n    const mappedMode = isSingleMode ? undefined : 'multiple';\n    const allowFetch = !fetchOnlyOnSearch || inputValue;\n    const [maxTagCount, setMaxTagCount] = useState(\n      propsMaxTagCount ?? MAX_TAG_COUNT,\n    );\n    const [onChangeCount, setOnChangeCount] = useState(0);\n    const previousChangeCount = usePrevious(onChangeCount, 0);\n\n    const fireOnChange = useCallback(\n      () => setOnChangeCount(onChangeCount + 1),\n      [onChangeCount],\n    );\n\n    useEffect(() => {\n      if (oneLine) {\n        setMaxTagCount(isDropdownVisible ? 0 : 1);\n      }\n    }, [isDropdownVisible, oneLine]);\n\n    useEffect(() => {\n      selectValueRef.current = selectValue;\n    }, [selectValue]);\n\n    const sortSelectedFirst = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortSelectedFirstHelper(a, b, selectValueRef.current),\n      [],\n    );\n\n    const sortComparatorWithSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorWithSearchHelper(\n          a,\n          b,\n          inputValue,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [inputValue, sortComparator, sortSelectedFirst],\n    );\n\n    const sortComparatorForNoSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorForNoSearchHelper(\n          a,\n          b,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [sortComparator, sortSelectedFirst],\n    );\n\n    const [selectOptions, setSelectOptions] =\n      useState<SelectOptionsType>(EMPTY_OPTIONS);\n\n    // add selected values to options list if they are not in it\n    const fullSelectOptions = useMemo(() => {\n      const missingValues: SelectOptionsType = ensureIsArray(selectValue)\n        .filter(opt => !hasOption(getValue(opt), selectOptions))\n        .map(opt =>\n          isLabeledValue(opt) ? opt : { value: opt, label: String(opt) },\n        );\n      return missingValues.length > 0\n        ? missingValues.concat(selectOptions)\n        : selectOptions;\n    }, [selectOptions, selectValue]);\n\n    const handleOnSelect: SelectProps['onSelect'] = (selectedItem, option) => {\n      if (isSingleMode) {\n        // on select is fired in single value mode if the same value is selected\n        const valueChanged = !utilsIsEqual(\n          selectedItem,\n          selectValue as RawValue | AntdLabeledValue,\n          'value',\n        );\n        setSelectValue(selectedItem);\n        if (valueChanged) {\n          fireOnChange();\n        }\n      } else {\n        setSelectValue(previousState => {\n          const array = ensureIsArray(previousState);\n          const value = getValue(selectedItem);\n          // Tokenized values can contain duplicated values\n          if (!hasOption(value, array)) {\n            const result = [...array, selectedItem];\n            return isLabeledValue(selectedItem)\n              ? (result as AntdLabeledValue[])\n              : (result as (string | number)[]);\n          }\n          return previousState;\n        });\n        fireOnChange();\n      }\n      onSelect?.(selectedItem, option);\n    };\n\n    const handleOnDeselect: SelectProps['onDeselect'] = (value, option) => {\n      if (Array.isArray(selectValue)) {\n        if (isLabeledValue(value)) {\n          const array = selectValue as AntdLabeledValue[];\n          setSelectValue(\n            array.filter(element => element.value !== value.value),\n          );\n        } else {\n          const array = selectValue as (string | number)[];\n          setSelectValue(array.filter(element => element !== value));\n        }\n        // removes new option\n        if (option.isNewOption) {\n          setSelectOptions(\n            fullSelectOptions.filter(\n              option => getValue(option.value) !== getValue(value),\n            ),\n          );\n        }\n      }\n      fireOnChange();\n      onDeselect?.(value, option);\n    };\n\n    const internalOnError = useCallback(\n      (response: Response) =>\n        getClientErrorObject(response).then(e => {\n          const { error } = e;\n          setError(error);\n\n          if (onError) {\n            onError(error);\n          }\n        }),\n      [onError],\n    );\n\n    const mergeData = useCallback(\n      (data: SelectOptionsType) => {\n        let mergedData: SelectOptionsType = [];\n        if (data && Array.isArray(data) && data.length) {\n          // unique option values should always be case sensitive so don't lowercase\n          const dataValues = new Set(data.map(opt => opt.value));\n          // merges with existing and creates unique options\n          setSelectOptions(prevOptions => {\n            mergedData = prevOptions\n              .filter(previousOption => !dataValues.has(previousOption.value))\n              .concat(data)\n              .sort(sortComparatorForNoSearch);\n            return mergedData;\n          });\n        }\n        return mergedData;\n      },\n      [sortComparatorForNoSearch],\n    );\n\n    const fetchPage = useMemo(\n      () => (search: string, page: number) => {\n        setPage(page);\n        if (allValuesLoaded) {\n          setIsLoading(false);\n          return;\n        }\n        const key = getQueryCacheKey(search, page, pageSize);\n        const cachedCount = fetchedQueries.current.get(key);\n        if (cachedCount !== undefined) {\n          setTotalCount(cachedCount);\n          setIsLoading(false);\n          return;\n        }\n        setIsLoading(true);\n\n        const fetchOptions = options as SelectOptionsPagePromise;\n        fetchOptions(search, page, pageSize)\n          .then(({ data, totalCount }: SelectOptionsTypePage) => {\n            const mergedData = mergeData(data);\n            fetchedQueries.current.set(key, totalCount);\n            setTotalCount(totalCount);\n            if (\n              !fetchOnlyOnSearch &&\n              search === '' &&\n              mergedData.length >= totalCount\n            ) {\n              setAllValuesLoaded(true);\n            }\n          })\n          .catch(internalOnError)\n          .finally(() => {\n            setIsLoading(false);\n          });\n      },\n      [\n        allValuesLoaded,\n        fetchOnlyOnSearch,\n        mergeData,\n        internalOnError,\n        options,\n        pageSize,\n      ],\n    );\n\n    const debouncedFetchPage = useMemo(\n      () => debounce(fetchPage, SLOW_DEBOUNCE),\n      [fetchPage],\n    );\n\n    const handleOnSearch = debounce((search: string) => {\n      const searchValue = search.trim();\n      if (allowNewOptions) {\n        const newOption = searchValue &&\n          !hasOption(searchValue, fullSelectOptions, true) && {\n            label: searchValue,\n            value: searchValue,\n            isNewOption: true,\n          };\n        const cleanSelectOptions = fullSelectOptions.filter(\n          opt => !opt.isNewOption || hasOption(opt.value, selectValue),\n        );\n        const newOptions = newOption\n          ? [newOption, ...cleanSelectOptions]\n          : cleanSelectOptions;\n        setSelectOptions(newOptions);\n      }\n      if (\n        !allValuesLoaded &&\n        loadingEnabled &&\n        !fetchedQueries.current.has(getQueryCacheKey(searchValue, 0, pageSize))\n      ) {\n        // if fetch only on search but search value is empty, then should not be\n        // in loading state\n        setIsLoading(!(fetchOnlyOnSearch && !searchValue));\n      }\n      setInputValue(search);\n      onSearch?.(searchValue);\n    }, FAST_DEBOUNCE);\n\n    useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n\n    const handlePagination = (e: UIEvent<HTMLElement>) => {\n      const vScroll = e.currentTarget;\n      const thresholdReached =\n        vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n      const hasMoreData = page * pageSize + pageSize < totalCount;\n\n      if (!isLoading && hasMoreData && thresholdReached) {\n        const newPage = page + 1;\n        fetchPage(inputValue, newPage);\n      }\n    };\n\n    const handleFilterOption = (search: string, option: AntdLabeledValue) =>\n      handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n\n    const handleOnDropdownVisibleChange = (isDropdownVisible: boolean) => {\n      setIsDropdownVisible(isDropdownVisible);\n\n      // loading is enabled when dropdown is open,\n      // disabled when dropdown is closed\n      if (loadingEnabled !== isDropdownVisible) {\n        setLoadingEnabled(isDropdownVisible);\n      }\n      // when closing dropdown, always reset loading state\n      if (!isDropdownVisible && isLoading) {\n        // delay is for the animation of closing the dropdown\n        // so the dropdown doesn't flash between \"Loading...\" and \"No data\"\n        // before closing.\n        setTimeout(() => {\n          setIsLoading(false);\n        }, 250);\n      }\n      // if no search input value, force sort options because it won't be sorted by\n      // `filterSort`.\n      if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n        const sortedOptions = selectOptions\n          .slice()\n          .sort(sortComparatorForNoSearch);\n        if (!isEqual(sortedOptions, selectOptions)) {\n          setSelectOptions(sortedOptions);\n        }\n      }\n\n      if (onDropdownVisibleChange) {\n        onDropdownVisibleChange(isDropdownVisible);\n      }\n    };\n\n    const dropdownRender = (\n      originNode: ReactElement & { ref?: RefObject<HTMLElement> },\n    ) =>\n      dropDownRenderHelper(\n        originNode,\n        isDropdownVisible,\n        isLoading,\n        fullSelectOptions.length,\n        helperText,\n        error ? <Error error={error} /> : undefined,\n      );\n\n    const handleClear = () => {\n      setSelectValue(undefined);\n      if (onClear) {\n        onClear();\n      }\n      fireOnChange();\n    };\n\n    const handleOnBlur = (event: React.FocusEvent<HTMLElement>) => {\n      setInputValue('');\n      onBlur?.(event);\n    };\n\n    useEffect(() => {\n      if (onChangeCount !== previousChangeCount) {\n        const array = ensureIsArray(selectValue);\n        const set = new Set(array.map(getValue));\n        const options = mapOptions(\n          fullSelectOptions.filter(opt => set.has(opt.value)),\n        );\n        if (isSingleMode) {\n          // @ts-ignore\n          onChange?.(selectValue, options[0]);\n        } else {\n          // @ts-ignore\n          onChange?.(array, options);\n        }\n      }\n    }, [\n      fullSelectOptions,\n      isSingleMode,\n      onChange,\n      onChangeCount,\n      previousChangeCount,\n      selectValue,\n    ]);\n\n    useEffect(() => {\n      // when `options` list is updated from component prop, reset states\n      fetchedQueries.current.clear();\n      setAllValuesLoaded(false);\n      setSelectOptions(EMPTY_OPTIONS);\n    }, [options]);\n\n    useEffect(() => {\n      setSelectValue(value);\n    }, [value]);\n\n    // Stop the invocation of the debounced function after unmounting\n    useEffect(\n      () => () => {\n        debouncedFetchPage.cancel();\n      },\n      [debouncedFetchPage],\n    );\n\n    useEffect(() => {\n      if (loadingEnabled && allowFetch) {\n        // trigger fetch every time inputValue changes\n        if (inputValue) {\n          debouncedFetchPage(inputValue, 0);\n        } else {\n          fetchPage('', 0);\n        }\n      }\n    }, [loadingEnabled, fetchPage, allowFetch, inputValue, debouncedFetchPage]);\n\n    useEffect(() => {\n      if (loading !== undefined && loading !== isLoading) {\n        setIsLoading(loading);\n      }\n    }, [isLoading, loading]);\n\n    const clearCache = () => fetchedQueries.current.clear();\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        ...(ref.current as HTMLInputElement),\n        clearCache,\n      }),\n      [ref],\n    );\n\n    const getPastedTextValue = useCallback(\n      async (text: string) => {\n        let option = getOption(text, fullSelectOptions, true);\n        if (!option && !allValuesLoaded) {\n          const fetchOptions = options as SelectOptionsPagePromise;\n          option = await fetchOptions(text, 0, pageSize).then(\n            ({ data }: SelectOptionsTypePage) =>\n              data.find(item => item.label === text),\n          );\n        }\n        if (!option && !allowNewOptions) {\n          return undefined;\n        }\n        const value: AntdLabeledValue = {\n          label: text,\n          value: text,\n        };\n        if (option) {\n          value.label = isObject(option) ? option.label : option;\n          value.value = isObject(option) ? option.value! : option;\n        }\n        return value;\n      },\n      [allValuesLoaded, allowNewOptions, fullSelectOptions, options, pageSize],\n    );\n\n    const onPaste = async (e: ClipboardEvent<HTMLInputElement>) => {\n      const pastedText = e.clipboardData.getData('text');\n      if (isSingleMode) {\n        const value = await getPastedTextValue(pastedText);\n        if (value) {\n          setSelectValue(value);\n        }\n      } else {\n        const token = tokenSeparators.find(token => pastedText.includes(token));\n        const array = token ? uniq(pastedText.split(token)) : [pastedText];\n        const values = (\n          await Promise.all(array.map(item => getPastedTextValue(item)))\n        ).filter(item => item !== undefined) as AntdLabeledValue[];\n        setSelectValue(previous => [\n          ...((previous || []) as AntdLabeledValue[]),\n          ...values.filter(value => !hasOption(value.value, previous)),\n        ]);\n      }\n      fireOnChange();\n    };\n\n    const shouldRenderChildrenOptions = useMemo(\n      () => hasCustomLabels(fullSelectOptions),\n      [fullSelectOptions],\n    );\n\n    return (\n      <StyledContainer headerPosition={headerPosition}>\n        {header && (\n          <StyledHeader headerPosition={headerPosition}>{header}</StyledHeader>\n        )}\n        <StyledSelect\n          allowClear={!isLoading && allowClear}\n          aria-label={ariaLabel || name}\n          autoClearSearchValue={autoClearSearchValue}\n          dropdownRender={dropdownRender}\n          filterOption={handleFilterOption}\n          filterSort={sortComparatorWithSearch}\n          getPopupContainer={\n            getPopupContainer || (triggerNode => triggerNode.parentNode)\n          }\n          headerPosition={headerPosition}\n          labelInValue\n          maxTagCount={maxTagCount}\n          mode={mappedMode}\n          notFoundContent={isLoading ? t('Loading...') : notFoundContent}\n          onBlur={handleOnBlur}\n          onDeselect={handleOnDeselect}\n          onDropdownVisibleChange={handleOnDropdownVisibleChange}\n          // @ts-ignore\n          onPaste={onPaste}\n          onPopupScroll={handlePagination}\n          onSearch={showSearch ? handleOnSearch : undefined}\n          onSelect={handleOnSelect}\n          onClear={handleClear}\n          options={shouldRenderChildrenOptions ? undefined : fullSelectOptions}\n          placeholder={placeholder}\n          showSearch={showSearch}\n          showArrow\n          tokenSeparators={tokenSeparators}\n          value={selectValue}\n          suffixIcon={getSuffixIcon(isLoading, showSearch, isDropdownVisible)}\n          menuItemSelectedIcon={\n            invertSelection ? (\n              <StyledStopOutlined iconSize=\"m\" aria-label=\"stop\" />\n            ) : (\n              <StyledCheckOutlined iconSize=\"m\" aria-label=\"check\" />\n            )\n          }\n          oneLine={oneLine}\n          tagRender={customTagRender}\n          {...props}\n          ref={ref}\n        >\n          {hasCustomLabels(fullSelectOptions) &&\n            renderSelectOptions(fullSelectOptions)}\n        </StyledSelect>\n      </StyledContainer>\n    );\n  },\n);\n\nexport default AsyncSelect;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}