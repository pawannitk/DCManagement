{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getColumnLabel, getMetricLabel, getNumberFormatter, getTimeFormatter } from '@superset-ui/core';\nimport { extractGroupbyLabel, getColtypesMapping, sanitizeHtml } from '../utils/series';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding } from '../Timeseries/transformers';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport default function transformProps(chartProps) {\n  const { width, height, formData, hooks, filterState, queriesData, inContextMenu, emitCrossFilters } = chartProps;\n  const { data = [] } = queriesData[0];\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { colorScheme, groupby = [], metrics = [], numberFormat, dateFormat, xTicksLayout, legendOrientation = 'top', xAxisTitle, yAxisTitle, xAxisTitleMargin, yAxisTitleMargin, yAxisTitlePosition, sliceId } = formData;\n  const refs = {};\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const metricLabels = metrics.map(getMetricLabel);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const transformedData = data.\n  map((datum) => {\n    const groupbyLabel = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat)\n    });\n    return metricLabels.map((metric) => {\n      const name = metricLabels.length === 1 ?\n      groupbyLabel :\n      `${groupbyLabel}, ${metric}`;\n      const isFiltered = filterState.selectedValues &&\n      !filterState.selectedValues.includes(name);\n      return {\n        name,\n        value: [\n        datum[`${metric}__min`],\n        datum[`${metric}__q1`],\n        datum[`${metric}__median`],\n        datum[`${metric}__q3`],\n        datum[`${metric}__max`],\n        datum[`${metric}__mean`],\n        datum[`${metric}__count`],\n        datum[`${metric}__outliers`]],\n\n        itemStyle: {\n          color: colorFn(groupbyLabel, sliceId),\n          opacity: isFiltered ? OpacityEnum.SemiTransparent : 0.6,\n          borderColor: colorFn(groupbyLabel, sliceId)\n        }\n      };\n    });\n  }).\n  flatMap((row) => row);\n  const outlierData = data.\n  map((datum) => metricLabels.map((metric) => {\n    const groupbyLabel = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat)\n    });\n    const name = metricLabels.length === 1 ?\n    groupbyLabel :\n    `${groupbyLabel}, ${metric}`;\n    // Outlier data is a nested array of numbers (uncommon, therefore no need to add to DataRecordValue)\n    const outlierDatum = datum[`${metric}__outliers`] || [];\n    const isFiltered = filterState.selectedValues &&\n    !filterState.selectedValues.includes(name);\n    return {\n      name: 'outlier',\n      type: 'scatter',\n      data: outlierDatum.map((val) => [name, val]),\n      tooltip: {\n        ...getDefaultTooltip(refs),\n        formatter: (param) => {\n          const [outlierName, stats] = param.data;\n          const headline = groupbyLabels.length ?\n          `<p><strong>${sanitizeHtml(outlierName)}</strong></p>` :\n          '';\n          return `${headline}${numberFormatter(stats)}`;\n        }\n      },\n      itemStyle: {\n        color: colorFn(groupbyLabel, sliceId),\n        opacity: isFiltered ?\n        OpacityEnum.SemiTransparent :\n        OpacityEnum.NonTransparent\n      }\n    };\n  })).\n  flat(2);\n  const labelMap = data.reduce((acc, datum) => {\n    const label = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat)\n    });\n    return {\n      ...acc,\n      [label]: groupbyLabels.map((col) => datum[col])\n    };\n  }, {});\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = transformedData.findIndex(({ name }) => name === selectedValue);\n    return {\n      ...acc,\n      [index]: selectedValue\n    };\n  }, {});\n  let axisLabel;\n  if (xTicksLayout === '45°')\n  axisLabel = { rotate: -45 };else\n  if (xTicksLayout === '90°')\n  axisLabel = { rotate: -90 };else\n  if (xTicksLayout === 'flat')\n  axisLabel = { rotate: 0 };else\n  if (xTicksLayout === 'staggered')\n  axisLabel = { rotate: -45 };else\n\n  axisLabel = { show: true };\n  const series = [\n  {\n    name: 'boxplot',\n    type: 'boxplot',\n    data: transformedData,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      formatter: (param) => {\n        // @ts-ignore\n        const { value, name } = param;\n        const headline = name ?\n        `<p><strong>${sanitizeHtml(name)}</strong></p>` :\n        '';\n        const stats = [\n        `Max: ${numberFormatter(value[5])}`,\n        `3rd Quartile: ${numberFormatter(value[4])}`,\n        `Mean: ${numberFormatter(value[6])}`,\n        `Median: ${numberFormatter(value[3])}`,\n        `1st Quartile: ${numberFormatter(value[2])}`,\n        `Min: ${numberFormatter(value[1])}`,\n        `# Observations: ${numberFormatter(value[7])}`];\n\n        if (value[8].length > 0) {\n          stats.push(`# Outliers: ${numberFormatter(value[8].length)}`);\n        }\n        return headline + stats.join('<br/>');\n      }\n    }\n  },\n  // @ts-ignore\n  ...outlierData];\n\n  const addYAxisTitleOffset = !!yAxisTitle;\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(true, legendOrientation, addYAxisTitleOffset, false, null, addXAxisTitleOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const echartOptions = {\n    grid: {\n      ...defaultGrid,\n      ...chartPadding\n    },\n    xAxis: {\n      type: 'category',\n      data: transformedData.map((row) => row.name),\n      axisLabel,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle'\n    },\n    yAxis: {\n      ...defaultYAxis,\n      type: 'value',\n      axisLabel: { formatter: numberFormatter },\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end'\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      axisPointer: {\n        type: 'shadow'\n      }\n    },\n    series\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    groupby,\n    selectedValues,\n    onContextMenu,\n    refs,\n    coltypeMapping\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(transformProps, \"transformProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/BoxPlot/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["CategoricalColorNamespace","getColumnLabel","getMetricLabel","getNumberFormatter","getTimeFormatter","extractGroupbyLabel","getColtypesMapping","sanitizeHtml","convertInteger","defaultGrid","defaultYAxis","getPadding","OpacityEnum","getDefaultTooltip","transformProps","chartProps","width","height","formData","hooks","filterState","queriesData","inContextMenu","emitCrossFilters","data","setDataMask","onContextMenu","coltypeMapping","colorScheme","groupby","metrics","numberFormat","dateFormat","xTicksLayout","legendOrientation","xAxisTitle","yAxisTitle","xAxisTitleMargin","yAxisTitleMargin","yAxisTitlePosition","sliceId","refs","colorFn","getScale","numberFormatter","metricLabels","map","groupbyLabels","transformedData","datum","groupbyLabel","timeFormatter","metric","name","length","isFiltered","selectedValues","includes","value","itemStyle","color","opacity","SemiTransparent","borderColor","flatMap","row","outlierData","outlierDatum","type","val","tooltip","formatter","param","outlierName","stats","headline","NonTransparent","flat","labelMap","reduce","acc","label","col","selectedValue","index","findIndex","axisLabel","rotate","show","series","push","join","addYAxisTitleOffset","addXAxisTitleOffset","chartPadding","echartOptions","grid","xAxis","nameGap","nameLocation","yAxis","trigger","axisPointer","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/BoxPlot/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  CategoricalColorNamespace,\n  getColumnLabel,\n  getMetricLabel,\n  getNumberFormatter,\n  getTimeFormatter,\n} from '@superset-ui/core';\nimport { EChartsCoreOption, BoxplotSeriesOption } from 'echarts';\nimport { CallbackDataParams } from 'echarts/types/src/util/types';\nimport {\n  BoxPlotChartTransformedProps,\n  BoxPlotQueryFormData,\n  EchartsBoxPlotChartProps,\n} from './types';\nimport {\n  extractGroupbyLabel,\n  getColtypesMapping,\n  sanitizeHtml,\n} from '../utils/series';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding } from '../Timeseries/transformers';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { Refs } from '../types';\n\nexport default function transformProps(\n  chartProps: EchartsBoxPlotChartProps,\n): BoxPlotChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    hooks,\n    filterState,\n    queriesData,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n  const { data = [] } = queriesData[0];\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const {\n    colorScheme,\n    groupby = [],\n    metrics = [],\n    numberFormat,\n    dateFormat,\n    xTicksLayout,\n    legendOrientation = 'top',\n    xAxisTitle,\n    yAxisTitle,\n    xAxisTitleMargin,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    sliceId,\n  } = formData as BoxPlotQueryFormData;\n  const refs: Refs = {};\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme as string);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const metricLabels = metrics.map(getMetricLabel);\n  const groupbyLabels = groupby.map(getColumnLabel);\n\n  const transformedData = data\n    .map((datum: any) => {\n      const groupbyLabel = extractGroupbyLabel({\n        datum,\n        groupby: groupbyLabels,\n        coltypeMapping,\n        timeFormatter: getTimeFormatter(dateFormat),\n      });\n      return metricLabels.map(metric => {\n        const name =\n          metricLabels.length === 1\n            ? groupbyLabel\n            : `${groupbyLabel}, ${metric}`;\n        const isFiltered =\n          filterState.selectedValues &&\n          !filterState.selectedValues.includes(name);\n        return {\n          name,\n          value: [\n            datum[`${metric}__min`],\n            datum[`${metric}__q1`],\n            datum[`${metric}__median`],\n            datum[`${metric}__q3`],\n            datum[`${metric}__max`],\n            datum[`${metric}__mean`],\n            datum[`${metric}__count`],\n            datum[`${metric}__outliers`],\n          ],\n          itemStyle: {\n            color: colorFn(groupbyLabel, sliceId),\n            opacity: isFiltered ? OpacityEnum.SemiTransparent : 0.6,\n            borderColor: colorFn(groupbyLabel, sliceId),\n          },\n        };\n      });\n    })\n    .flatMap(row => row);\n  const outlierData = data\n    .map(datum =>\n      metricLabels.map(metric => {\n        const groupbyLabel = extractGroupbyLabel({\n          datum,\n          groupby: groupbyLabels,\n          coltypeMapping,\n          timeFormatter: getTimeFormatter(dateFormat),\n        });\n        const name =\n          metricLabels.length === 1\n            ? groupbyLabel\n            : `${groupbyLabel}, ${metric}`;\n        // Outlier data is a nested array of numbers (uncommon, therefore no need to add to DataRecordValue)\n        const outlierDatum = (datum[`${metric}__outliers`] || []) as number[];\n        const isFiltered =\n          filterState.selectedValues &&\n          !filterState.selectedValues.includes(name);\n        return {\n          name: 'outlier',\n          type: 'scatter',\n          data: outlierDatum.map(val => [name, val]),\n          tooltip: {\n            ...getDefaultTooltip(refs),\n            formatter: (param: { data: [string, number] }) => {\n              const [outlierName, stats] = param.data;\n              const headline = groupbyLabels.length\n                ? `<p><strong>${sanitizeHtml(outlierName)}</strong></p>`\n                : '';\n              return `${headline}${numberFormatter(stats)}`;\n            },\n          },\n          itemStyle: {\n            color: colorFn(groupbyLabel, sliceId),\n            opacity: isFiltered\n              ? OpacityEnum.SemiTransparent\n              : OpacityEnum.NonTransparent,\n          },\n        };\n      }),\n    )\n    .flat(2);\n\n  const labelMap = data.reduce((acc: Record<string, string[]>, datum) => {\n    const label = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat),\n    });\n    return {\n      ...acc,\n      [label]: groupbyLabels.map(col => datum[col] as string),\n    };\n  }, {});\n\n  const selectedValues = (filterState.selectedValues || []).reduce(\n    (acc: Record<string, number>, selectedValue: string) => {\n      const index = transformedData.findIndex(\n        ({ name }) => name === selectedValue,\n      );\n      return {\n        ...acc,\n        [index]: selectedValue,\n      };\n    },\n    {},\n  );\n\n  let axisLabel;\n  if (xTicksLayout === '45°') axisLabel = { rotate: -45 };\n  else if (xTicksLayout === '90°') axisLabel = { rotate: -90 };\n  else if (xTicksLayout === 'flat') axisLabel = { rotate: 0 };\n  else if (xTicksLayout === 'staggered') axisLabel = { rotate: -45 };\n  else axisLabel = { show: true };\n\n  const series: BoxplotSeriesOption[] = [\n    {\n      name: 'boxplot',\n      type: 'boxplot',\n      data: transformedData,\n      tooltip: {\n        ...getDefaultTooltip(refs),\n        formatter: (param: CallbackDataParams) => {\n          // @ts-ignore\n          const {\n            value,\n            name,\n          }: {\n            value: [\n              number,\n              number,\n              number,\n              number,\n              number,\n              number,\n              number,\n              number,\n              number[],\n            ];\n            name: string;\n          } = param;\n          const headline = name\n            ? `<p><strong>${sanitizeHtml(name)}</strong></p>`\n            : '';\n          const stats = [\n            `Max: ${numberFormatter(value[5])}`,\n            `3rd Quartile: ${numberFormatter(value[4])}`,\n            `Mean: ${numberFormatter(value[6])}`,\n            `Median: ${numberFormatter(value[3])}`,\n            `1st Quartile: ${numberFormatter(value[2])}`,\n            `Min: ${numberFormatter(value[1])}`,\n            `# Observations: ${numberFormatter(value[7])}`,\n          ];\n          if (value[8].length > 0) {\n            stats.push(`# Outliers: ${numberFormatter(value[8].length)}`);\n          }\n          return headline + stats.join('<br/>');\n        },\n      },\n    },\n    // @ts-ignore\n    ...outlierData,\n  ];\n  const addYAxisTitleOffset = !!yAxisTitle;\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(\n    true,\n    legendOrientation,\n    addYAxisTitleOffset,\n    false,\n    null,\n    addXAxisTitleOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n  );\n  const echartOptions: EChartsCoreOption = {\n    grid: {\n      ...defaultGrid,\n      ...chartPadding,\n    },\n    xAxis: {\n      type: 'category',\n      data: transformedData.map(row => row.name),\n      axisLabel,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n    },\n    yAxis: {\n      ...defaultYAxis,\n      type: 'value',\n      axisLabel: { formatter: numberFormatter },\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      axisPointer: {\n        type: 'shadow',\n      },\n    },\n    series,\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    groupby,\n    selectedValues,\n    onContextMenu,\n    refs,\n    coltypeMapping,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}