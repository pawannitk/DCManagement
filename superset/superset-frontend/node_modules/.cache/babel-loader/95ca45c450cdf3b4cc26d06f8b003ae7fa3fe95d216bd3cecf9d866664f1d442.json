{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default = \"#define SHADER_NAME text-background-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec3 instancePositions64Low;\\nattribute vec4 instanceRects;\\nattribute float instanceSizes;\\nattribute float instanceAngles;\\nattribute vec2 instancePixelOffsets;\\nattribute float instanceLineWidths;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform bool billboard;\\nuniform float opacity;\\nuniform float sizeScale;\\nuniform float sizeMinPixels;\\nuniform float sizeMaxPixels;\\nuniform vec4 padding;\\nuniform int sizeUnits;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying float vLineWidth;\\nvarying vec2 uv;\\nvarying vec2 dimensions;\\n\\nvec2 rotate_by_angle(vec2 vertex, float angle) {\\n  float angle_radian = radians(angle);\\n  float cos_angle = cos(angle_radian);\\n  float sin_angle = sin(angle_radian);\\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\\n  return rotationMatrix * vertex;\\n}\\n\\nvoid main(void) {\\n  geometry.worldPosition = instancePositions;\\n  geometry.uv = positions;\\n  geometry.pickingColor = instancePickingColors;\\n  uv = positions;\\n  vLineWidth = instanceLineWidths;\\n  float sizePixels = clamp(\\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\\n    sizeMinPixels, sizeMaxPixels\\n  );\\n\\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\\n\\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\\n  pixelOffset += instancePixelOffsets;\\n  pixelOffset.y *= -1.0;\\n\\n  if (billboard)  {\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n    vec3 offset = vec3(pixelOffset, 0.0);\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\n  } else {\\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\\n    DECKGL_FILTER_SIZE(offset_common, geometry);\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  }\\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\\n}\\n\";export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["_default","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["../../../../src/text-layer/text-background-layer/text-background-layer-vertex.glsl.ts"],"sourcesContent":["export default `\\\n#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n\n  // convert size in meters to pixels, then scaled and clamp\n\n  // project meters to pixels and clamp to limits\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n`;\n"],"mappings":"wTAAA,4lFAAAA,QAAA,oBAAAC,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAC,SAAA,MAAAH,cAAA,WAAAA,cAAA,CAAAI,QAAA,CAAAL,QAAA,8OAAAM,WAAA,UAAAJ,oBAAA,mBAAAA,oBAAA,CAAAI,WAAA,GAAAF,SAAA,CAAAE,WAAA,IAAAA,WAAA,CAAAC,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}