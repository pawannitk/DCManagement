{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { SyncRegistry, OverwritePolicy } from '@encodable/registry';\nexport default class FormatterRegistry extends SyncRegistry {\n  constructor({\n    overwritePolicy = OverwritePolicy.WARN,\n    ...rest\n  }) {\n    super({\n      overwritePolicy,\n      ...rest\n    });\n  }\n  /**\n   * Subclasses must implement this to create formatter from format string.\n   * Worst-case can return `fallbackFormatter`.\n   */\n\n\n  /**\n   * Get a Formatter by name\n   * @param format Formatter name, usually is a format string\n   */\n  get(format) {\n    const targetFormat = (\"\" + (format === null || typeof format === 'undefined' || format.trim().length === 0 ? this.getDefaultKey() : format)).trim();\n\n    if (this.has(targetFormat)) {\n      return super.get(targetFormat);\n    } // Create new formatter if does not exist\n\n\n    const formatter = this.createFormatter(targetFormat);\n    this.registerValue(targetFormat, formatter);\n    return formatter;\n  }\n  /**\n   * Format value with the named Formatter\n   * @param format Formatter name, usually is a format string\n   * @param value value to be formatted\n   */\n\n\n  format(format, value) {\n    return this.get(format)(value);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(FormatterRegistry, \"FormatterRegistry\", \"/home/pawank/Documents/dcim/superset/superset-frontend/node_modules/@encodable/format/esm/FormatterRegistry.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["SyncRegistry","OverwritePolicy","FormatterRegistry","constructor","overwritePolicy","WARN","rest","get","format","targetFormat","trim","length","getDefaultKey","has","formatter","createFormatter","registerValue","value","__reactstandin__regenerateByEval","key","code","eval","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/node_modules/@encodable/format/esm/FormatterRegistry.js"],"sourcesContent":["import { SyncRegistry, OverwritePolicy } from '@encodable/registry';\nexport default class FormatterRegistry extends SyncRegistry {\n  constructor({\n    overwritePolicy = OverwritePolicy.WARN,\n    ...rest\n  }) {\n    super({\n      overwritePolicy,\n      ...rest\n    });\n  }\n  /**\n   * Subclasses must implement this to create formatter from format string.\n   * Worst-case can return `fallbackFormatter`.\n   */\n\n\n  /**\n   * Get a Formatter by name\n   * @param format Formatter name, usually is a format string\n   */\n  get(format) {\n    const targetFormat = (\"\" + (format === null || typeof format === 'undefined' || format.trim().length === 0 ? this.getDefaultKey() : format)).trim();\n\n    if (this.has(targetFormat)) {\n      return super.get(targetFormat);\n    } // Create new formatter if does not exist\n\n\n    const formatter = this.createFormatter(targetFormat);\n    this.registerValue(targetFormat, formatter);\n    return formatter;\n  }\n  /**\n   * Format value with the named Formatter\n   * @param format Formatter name, usually is a format string\n   * @param value value to be formatted\n   */\n\n\n  format(format, value) {\n    return this.get(format)(value);\n  }\n\n}"],"mappings":"uSAAA,SAASA,YAAY,EAAEC,eAAe,QAAQ,qBAAqB;AACnE,eAAe,MAAMC,iBAAiB,SAASF,YAAY,CAAC;EAC1DG,WAAWA,CAAC;IACVC,eAAe,GAAGH,eAAe,CAACI,IAAI;IACtC,GAAGC;EACL,CAAC,EAAE;IACD,KAAK,CAAC;MACJF,eAAe;MACf,GAAGE;IACL,CAAC,CAAC;EACJ;EACA;AACF;AACA;AACA;;;EAGE;AACF;AACA;AACA;EACEC,GAAGA,CAACC,MAAM,EAAE;IACV,MAAMC,YAAY,GAAG,CAAC,EAAE,IAAID,MAAM,KAAK,IAAI,IAAI,OAAOA,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACE,IAAI,CAAC,CAAC,CAACC,MAAM,KAAK,CAAC,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC,GAAGJ,MAAM,CAAC,EAAEE,IAAI,CAAC,CAAC;;IAEnJ,IAAI,IAAI,CAACG,GAAG,CAACJ,YAAY,CAAC,EAAE;MAC1B,OAAO,KAAK,CAACF,GAAG,CAACE,YAAY,CAAC;IAChC,CAAC,CAAC;;;IAGF,MAAMK,SAAS,GAAG,IAAI,CAACC,eAAe,CAACN,YAAY,CAAC;IACpD,IAAI,CAACO,aAAa,CAACP,YAAY,EAAEK,SAAS,CAAC;IAC3C,OAAOA,SAAS;EAClB;EACA;AACF;AACA;AACA;AACA;;;EAGEN,MAAMA,CAACA,MAAM,EAAES,KAAK,EAAE;IACpB,OAAO,IAAI,CAACV,GAAG,CAACC,MAAM,CAAC,CAACS,KAAK,CAAC;EAChC,CAAC;EAAAC,iCAAAC,GAAA,EAAAC,IAAA;IAAA,KAAAD,GAAA,IAAAE,IAAA,CAAAD,IAAA,GAEH,CAAC,mBAAAE,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAC,SAAA,MAAAH,cAAA,WAAAA,cAAA,CAAAI,QAAA,CA3CoBxB,iBAAiB,iKAAAyB,WAAA,UAAAJ,oBAAA,mBAAAA,oBAAA,CAAAI,WAAA,GAAAF,SAAA,CAAAE,WAAA,IAAAA,WAAA,CAAAC,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}