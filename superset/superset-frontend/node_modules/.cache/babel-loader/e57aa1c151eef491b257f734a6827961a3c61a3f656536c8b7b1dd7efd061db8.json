{"ast":null,"code":"import _minBy from \"lodash/minBy\";import _maxBy from \"lodash/maxBy\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { GenericDataType, NumberFormats, getColumnLabel, getMetricLabel, getSequentialSchemeRegistry, getTimeFormatter, getValueFormatter, tooltipHtml } from '@superset-ui/core';\nimport memoizeOne from 'memoize-one';\n\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { parseAxisBound } from '../utils/controls';\nimport { NULL_STRING } from '../constants';\nimport { getPercentFormatter } from '../utils/formatters';\nconst DEFAULT_ECHARTS_BOUNDS = [0, 200];\n// Calculated totals per x and y categories plus total\nconst calculateTotals = memoizeOne((data, xAxis, groupby, metric) => data.reduce((acc, row) => {\n  const value = row[metric];\n  if (typeof value !== 'number') {\n    return acc;\n  }\n  const x = row[xAxis];\n  const y = row[groupby];\n  const xTotal = acc.x[x] || 0;\n  const yTotal = acc.y[y] || 0;\n  return {\n    x: { ...acc.x, [x]: xTotal + value },\n    y: { ...acc.y, [y]: yTotal + value },\n    total: acc.total + value\n  };\n}, { x: {}, y: {}, total: 0 }));\nexport default function transformProps(chartProps) {var _getSequentialSchemeR;\n  const refs = {};\n  const { width, height, formData, queriesData, datasource } = chartProps;\n  const { bottomMargin, xAxis, groupby, linearColorScheme, leftMargin, legendType = 'continuous', metric = '', normalizeAcross, normalized, showLegend, showPercentage, showValues, xscaleInterval, yscaleInterval, valueBounds, yAxisFormat, xAxisTimeFormat, currencyFormat } = formData;\n  const metricLabel = getMetricLabel(metric);\n  const xAxisLabel = getColumnLabel(xAxis);\n  // groupby is overridden to be a single value\n  const yAxisLabel = getColumnLabel(groupby);\n  const { data, colnames, coltypes } = queriesData[0];\n  const { columnFormats = {}, currencyFormats = {} } = datasource;\n  const colorColumn = normalized ? 'rank' : metricLabel;\n  const colors = (_getSequentialSchemeR = getSequentialSchemeRegistry().get(linearColorScheme)) == null ? void 0 : _getSequentialSchemeR.colors;\n  const getAxisFormatter = (colType) => (value) => {\n    if (colType === GenericDataType.Temporal) {\n      if (typeof value === 'string') {\n        return getTimeFormatter(xAxisTimeFormat)(Number.parseInt(value, 10));\n      }\n      return getTimeFormatter(xAxisTimeFormat)(value);\n    }\n    return String(value);\n  };\n  const xAxisFormatter = getAxisFormatter(coltypes[0]);\n  const yAxisFormatter = getAxisFormatter(coltypes[1]);\n  const percentFormatter = getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const valueFormatter = getValueFormatter(metric, currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  let [min, max] = (valueBounds || []).map(parseAxisBound);\n  if (min === undefined) {var _minBy2;\n    min =\n    ((_minBy2 = _minBy(data, (row) => row[colorColumn])) == null ? void 0 : _minBy2[colorColumn]) ||\n    DEFAULT_ECHARTS_BOUNDS[0];\n  }\n  if (max === undefined) {var _maxBy2;\n    max =\n    ((_maxBy2 = _maxBy(data, (row) => row[colorColumn])) == null ? void 0 : _maxBy2[colorColumn]) ||\n    DEFAULT_ECHARTS_BOUNDS[1];\n  }\n  const series = [\n  {\n    name: metricLabel,\n    type: 'heatmap',\n    data: data.map((row) => colnames.map((col) => {\n      const value = row[col];\n      if (!value) {\n        return NULL_STRING;\n      }\n      if (typeof value === 'boolean') {\n        return String(value);\n      }\n      return value;\n    })),\n    label: {\n      show: showValues,\n      formatter: (params) => valueFormatter(params.value[2])\n    }\n  }];\n\n  const echartOptions = {\n    grid: {\n      containLabel: true,\n      bottom: bottomMargin,\n      left: leftMargin\n    },\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      formatter: (params) => {\n        const totals = calculateTotals(data, xAxisLabel, yAxisLabel, metricLabel);\n        const x = params.value[0];\n        const y = params.value[1];\n        const value = params.value[2];\n        const formattedX = xAxisFormatter(x);\n        const formattedY = yAxisFormatter(y);\n        const formattedValue = valueFormatter(value);\n        let percentage = 0;\n        let suffix = 'heatmap';\n        if (typeof value === 'number') {\n          if (normalizeAcross === 'x') {\n            percentage = value / totals.x[x];\n            suffix = formattedX;\n          } else\n          if (normalizeAcross === 'y') {\n            percentage = value / totals.y[y];\n            suffix = formattedY;\n          } else\n          {\n            percentage = value / totals.total;\n            suffix = 'heatmap';\n          }\n        }\n        const title = `${formattedX} (${formattedY})`;\n        const row = [colnames[2], formattedValue];\n        if (showPercentage) {\n          row.push(`${percentFormatter(percentage)} (${suffix})`);\n        }\n        return tooltipHtml([row], title);\n      }\n    },\n    visualMap: {\n      type: legendType,\n      min,\n      max,\n      calculable: true,\n      orient: 'horizontal',\n      right: 0,\n      top: 0,\n      itemHeight: legendType === 'continuous' ? 300 : 14,\n      itemWidth: 15,\n      formatter: (min) => valueFormatter(min),\n      inRange: {\n        color: colors\n      },\n      show: showLegend,\n      // By default, ECharts uses the last dimension which is rank\n      dimension: normalized ? 3 : 2\n    },\n    xAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        interval: xscaleInterval === -1 ? 'auto' : xscaleInterval - 1\n      }\n    },\n    yAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: yAxisFormatter,\n        interval: yscaleInterval === -1 ? 'auto' : yscaleInterval - 1\n      }\n    }\n  };\n  return {\n    refs,\n    echartOptions,\n    width,\n    height,\n    formData\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(DEFAULT_ECHARTS_BOUNDS, \"DEFAULT_ECHARTS_BOUNDS\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Heatmap/transformProps.ts\");reactHotLoader.register(calculateTotals, \"calculateTotals\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Heatmap/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Heatmap/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["GenericDataType","NumberFormats","getColumnLabel","getMetricLabel","getSequentialSchemeRegistry","getTimeFormatter","getValueFormatter","tooltipHtml","memoizeOne","getDefaultTooltip","parseAxisBound","NULL_STRING","getPercentFormatter","DEFAULT_ECHARTS_BOUNDS","calculateTotals","data","xAxis","groupby","metric","reduce","acc","row","value","x","y","xTotal","yTotal","total","transformProps","chartProps","_getSequentialSchemeR","refs","width","height","formData","queriesData","datasource","bottomMargin","linearColorScheme","leftMargin","legendType","normalizeAcross","normalized","showLegend","showPercentage","showValues","xscaleInterval","yscaleInterval","valueBounds","yAxisFormat","xAxisTimeFormat","currencyFormat","metricLabel","xAxisLabel","yAxisLabel","colnames","coltypes","columnFormats","currencyFormats","colorColumn","colors","get","getAxisFormatter","colType","Temporal","Number","parseInt","String","xAxisFormatter","yAxisFormatter","percentFormatter","PERCENT_2_POINT","valueFormatter","min","max","map","undefined","_minBy2","_minBy","_maxBy2","_maxBy","series","name","type","col","label","show","formatter","params","echartOptions","grid","containLabel","bottom","left","tooltip","totals","formattedX","formattedY","formattedValue","percentage","suffix","title","push","visualMap","calculable","orient","right","top","itemHeight","itemWidth","inRange","color","dimension","axisLabel","interval","yAxis","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/Heatmap/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  GenericDataType,\n  NumberFormats,\n  QueryFormColumn,\n  getColumnLabel,\n  getMetricLabel,\n  getSequentialSchemeRegistry,\n  getTimeFormatter,\n  getValueFormatter,\n  tooltipHtml,\n} from '@superset-ui/core';\nimport memoizeOne from 'memoize-one';\nimport { maxBy, minBy } from 'lodash';\nimport { EChartsOption, HeatmapSeriesOption } from 'echarts';\nimport { CallbackDataParams } from 'echarts/types/src/util/types';\nimport { HeatmapChartProps, HeatmapTransformedProps } from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { Refs } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport { NULL_STRING } from '../constants';\nimport { getPercentFormatter } from '../utils/formatters';\n\nconst DEFAULT_ECHARTS_BOUNDS = [0, 200];\n\n// Calculated totals per x and y categories plus total\nconst calculateTotals = memoizeOne(\n  (\n    data: Record<string, any>[],\n    xAxis: string,\n    groupby: string,\n    metric: string,\n  ) =>\n    data.reduce(\n      (acc, row) => {\n        const value = row[metric];\n        if (typeof value !== 'number') {\n          return acc;\n        }\n        const x = row[xAxis] as string;\n        const y = row[groupby] as string;\n        const xTotal = acc.x[x] || 0;\n        const yTotal = acc.y[y] || 0;\n        return {\n          x: { ...acc.x, [x]: xTotal + value },\n          y: { ...acc.y, [y]: yTotal + value },\n          total: acc.total + value,\n        };\n      },\n      { x: {}, y: {}, total: 0 },\n    ),\n);\n\nexport default function transformProps(\n  chartProps: HeatmapChartProps,\n): HeatmapTransformedProps {\n  const refs: Refs = {};\n  const { width, height, formData, queriesData, datasource } = chartProps;\n  const {\n    bottomMargin,\n    xAxis,\n    groupby,\n    linearColorScheme,\n    leftMargin,\n    legendType = 'continuous',\n    metric = '',\n    normalizeAcross,\n    normalized,\n    showLegend,\n    showPercentage,\n    showValues,\n    xscaleInterval,\n    yscaleInterval,\n    valueBounds,\n    yAxisFormat,\n    xAxisTimeFormat,\n    currencyFormat,\n  } = formData;\n  const metricLabel = getMetricLabel(metric);\n  const xAxisLabel = getColumnLabel(xAxis);\n  // groupby is overridden to be a single value\n  const yAxisLabel = getColumnLabel(groupby as unknown as QueryFormColumn);\n  const { data, colnames, coltypes } = queriesData[0];\n  const { columnFormats = {}, currencyFormats = {} } = datasource;\n  const colorColumn = normalized ? 'rank' : metricLabel;\n  const colors = getSequentialSchemeRegistry().get(linearColorScheme)?.colors;\n  const getAxisFormatter =\n    (colType: GenericDataType) => (value: number | string) => {\n      if (colType === GenericDataType.Temporal) {\n        if (typeof value === 'string') {\n          return getTimeFormatter(xAxisTimeFormat)(Number.parseInt(value, 10));\n        }\n        return getTimeFormatter(xAxisTimeFormat)(value);\n      }\n      return String(value);\n    };\n\n  const xAxisFormatter = getAxisFormatter(coltypes[0]);\n  const yAxisFormatter = getAxisFormatter(coltypes[1]);\n  const percentFormatter = getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const valueFormatter = getValueFormatter(\n    metric,\n    currencyFormats,\n    columnFormats,\n    yAxisFormat,\n    currencyFormat,\n  );\n\n  let [min, max] = (valueBounds || []).map(parseAxisBound);\n  if (min === undefined) {\n    min =\n      (minBy(data, row => row[colorColumn])?.[colorColumn] as number) ||\n      DEFAULT_ECHARTS_BOUNDS[0];\n  }\n  if (max === undefined) {\n    max =\n      (maxBy(data, row => row[colorColumn])?.[colorColumn] as number) ||\n      DEFAULT_ECHARTS_BOUNDS[1];\n  }\n\n  const series: HeatmapSeriesOption[] = [\n    {\n      name: metricLabel,\n      type: 'heatmap',\n      data: data.map(row =>\n        colnames.map(col => {\n          const value = row[col];\n          if (!value) {\n            return NULL_STRING;\n          }\n          if (typeof value === 'boolean') {\n            return String(value);\n          }\n          return value;\n        }),\n      ),\n      label: {\n        show: showValues,\n        formatter: (params: CallbackDataParams) =>\n          valueFormatter(params.value[2]),\n      },\n    },\n  ];\n\n  const echartOptions: EChartsOption = {\n    grid: {\n      containLabel: true,\n      bottom: bottomMargin,\n      left: leftMargin,\n    },\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      formatter: (params: CallbackDataParams) => {\n        const totals = calculateTotals(\n          data,\n          xAxisLabel,\n          yAxisLabel,\n          metricLabel,\n        );\n        const x = params.value[0];\n        const y = params.value[1];\n        const value = params.value[2];\n        const formattedX = xAxisFormatter(x);\n        const formattedY = yAxisFormatter(y);\n        const formattedValue = valueFormatter(value);\n        let percentage = 0;\n        let suffix = 'heatmap';\n        if (typeof value === 'number') {\n          if (normalizeAcross === 'x') {\n            percentage = value / totals.x[x];\n            suffix = formattedX;\n          } else if (normalizeAcross === 'y') {\n            percentage = value / totals.y[y];\n            suffix = formattedY;\n          } else {\n            percentage = value / totals.total;\n            suffix = 'heatmap';\n          }\n        }\n        const title = `${formattedX} (${formattedY})`;\n        const row = [colnames[2], formattedValue];\n        if (showPercentage) {\n          row.push(`${percentFormatter(percentage)} (${suffix})`);\n        }\n        return tooltipHtml([row], title);\n      },\n    },\n    visualMap: {\n      type: legendType,\n      min,\n      max,\n      calculable: true,\n      orient: 'horizontal',\n      right: 0,\n      top: 0,\n      itemHeight: legendType === 'continuous' ? 300 : 14,\n      itemWidth: 15,\n      formatter: min => valueFormatter(min as number),\n      inRange: {\n        color: colors,\n      },\n      show: showLegend,\n      // By default, ECharts uses the last dimension which is rank\n      dimension: normalized ? 3 : 2,\n    },\n    xAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        interval: xscaleInterval === -1 ? 'auto' : xscaleInterval - 1,\n      },\n    },\n    yAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: yAxisFormatter,\n        interval: yscaleInterval === -1 ? 'auto' : yscaleInterval - 1,\n      },\n    },\n  };\n  return {\n    refs,\n    echartOptions,\n    width,\n    height,\n    formData,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}