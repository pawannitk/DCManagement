{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { log } from '@deck.gl/core';\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  let x = xOffset;\n  const rowHeight = fontHeight + buffer * 2;\n\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      const width = getFontWidth(char);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * rowHeight + buffer,\n        width,\n        height: rowHeight,\n        layoutWidth: width,\n        layoutHeight: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  let width = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    var _mapping$character;\n\n    const character = text[i];\n    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.layoutWidth) || 0;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n\n  const result = [];\n\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n\n  return result;\n}\n\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n\n    if (frame) {\n      if (!rowHeight) {\n        rowHeight = frame.layoutHeight;\n      }\n\n      leftOffsets[i] = x + frame.layoutWidth / 2;\n      x += frame.layoutWidth;\n    } else {\n      log.warn(\"Missing character: \".concat(character, \" (\").concat(character.codePointAt(0), \")\"))();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters);\n  const y = new Array(numCharacters);\n  const rowWidth = new Array(numCharacters);\n  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n  const size = [0, 0];\n  const rowSize = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n\n        for (let j = rowStart; j < rowEnd; j++) {\n          var _iconMapping$char;\n\n          const char = characters[j];\n          const layoutOffsetY = ((_iconMapping$char = iconMapping[char]) === null || _iconMapping$char === void 0 ? void 0 : _iconMapping$char.layoutOffsetY) || 0;\n          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  size[1] = rowOffsetTop;\n  return {\n    x,\n    y,\n    rowWidth,\n    size\n  };\n}\nexport function getTextFromBuffer({\n  value,\n  length,\n  stride,\n  offset,\n  startIndices,\n  characterSet\n}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set();\n  const texts = new Array(length);\n  let codes = value;\n\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor;\n    codes = new ArrayType(characterCount);\n\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n\n    if (autoCharacterSet) {\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n\n  return {\n    texts,\n    characterCount\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(MISSING_CHAR_WIDTH, \"MISSING_CHAR_WIDTH\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(SINGLE_LINE, \"SINGLE_LINE\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(nextPowOfTwo, \"nextPowOfTwo\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(buildMapping, \"buildMapping\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(getTextWidth, \"getTextWidth\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(breakAll, \"breakAll\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(breakWord, \"breakWord\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(autoWrapping, \"autoWrapping\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(transformRow, \"transformRow\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(transformParagraph, \"transformParagraph\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");reactHotLoader.register(getTextFromBuffer, \"getTextFromBuffer\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["log","MISSING_CHAR_WIDTH","SINGLE_LINE","nextPowOfTwo","number","Math","pow","ceil","log2","buildMapping","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","rowHeight","char","width","y","height","layoutWidth","layoutHeight","canvasHeight","getTextWidth","text","startIndex","endIndex","i","_mapping$character","character","breakAll","maxWidth","iconMapping","target","rowStartCharIndex","rowOffsetLeft","textWidth","push","breakWord","groupStartCharIndex","groupEndCharIndex","groupWidth","length","autoWrapping","wordBreak","undefined","result","transformRow","line","leftOffsets","rowSize","frame","warn","concat","codePointAt","transformParagraph","paragraph","lineHeight","characters","Array","from","numCharacters","rowWidth","autoWrappingEnabled","isFinite","size","rowOffsetTop","lineStartIndex","lineEndIndex","rows","rowIndex","rowStart","rowEnd","j","_iconMapping$char","layoutOffsetY","max","getTextFromBuffer","value","stride","offset","startIndices","bytesPerElement","BYTES_PER_ELEMENT","elementStride","elementOffset","characterCount","autoCharacterSet","Set","texts","codes","ArrayType","constructor","index","codesAtIndex","subarray","String","fromCodePoint","apply","forEach","add","charCode","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["../../../src/text-layer/utils.ts"],"sourcesContent":["/* eslint-disable max-statements, max-params, complexity, max-depth */\n// TODO merge with icon-layer/icon-manager\nimport {log} from '@deck.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\n\nexport type Character = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  layoutWidth: number;\n  layoutHeight: number;\n  layoutOffsetY?: number;\n};\n\nexport type CharacterMapping = Record<string, Character>;\n\nexport function nextPowOfTwo(number: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n/**\n * Generate character mapping table or update from an existing mapping table\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}: {\n  /** list of characters */\n  characterSet: Set<string>;\n  /** function to get width of each character */\n  getFontWidth: (char: string) => number;\n  /** height of font */\n  fontHeight: number;\n  /** bleeding buffer surround each character */\n  buffer: number;\n  /** max width of font atlas */\n  maxCanvasWidth: number;\n  /** cached mapping table */\n  mapping?: CharacterMapping;\n  /** x position of last character in the existing mapping table */\n  xOffset?: number;\n  /** y position of last character in the existing mapping table */\n  yOffset?: number;\n}): {\n  /** new mapping table */\n  mapping: CharacterMapping;\n  /** x position of last character in the new mapping table */\n  xOffset: number;\n  /** y position of last character in the new mapping table */\n  yOffset: number;\n  /** height of the font atlas canvas, power of 2 */\n  canvasHeight: number;\n} {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n  const rowHeight = fontHeight + buffer * 2;\n\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * rowHeight + buffer,\n        width,\n        height: rowHeight,\n        layoutWidth: width,\n        layoutHeight: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(\n  text: string[],\n  startIndex: number,\n  endIndex: number,\n  mapping: CharacterMapping\n): number {\n  let width = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = text[i];\n    width += mapping[character]?.layoutWidth || 0;\n  }\n\n  return width;\n}\n\nfunction breakAll(\n  text: string[],\n  startIndex: number,\n  endIndex: number,\n  maxWidth: number,\n  iconMapping: CharacterMapping,\n  target: number[]\n): number {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 2. figure out where to break lines\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(\n  text: string[],\n  startIndex: number,\n  endIndex: number,\n  maxWidth: number,\n  iconMapping: CharacterMapping,\n  target: number[]\n): number {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 1. break text into word groups\n    //  - if current char is white space\n    //  - else if next char is white space\n    //  - else if reach last char\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      // 2. break text into next row at maxWidth\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        // if a single text group is bigger than maxWidth, then `break-all`\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(\n            text,\n            groupStartCharIndex,\n            groupEndCharIndex,\n            maxWidth,\n            iconMapping,\n            target\n          );\n          // move reference to last row\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\n/**\n * Wrap the given text so that each line does not exceed the given max width.\n * Returns a list of indices where line breaks should be inserted.\n */\nexport function autoWrapping(\n  text: string[],\n  wordBreak: 'break-all' | 'break-word',\n  maxWidth: number,\n  iconMapping: CharacterMapping,\n  startIndex: number = 0,\n  endIndex: number\n): number[] {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n  const result = [];\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n  return result;\n}\n\nfunction transformRow(\n  line: string[],\n  startIndex: number,\n  endIndex: number,\n  iconMapping: CharacterMapping,\n  leftOffsets: number[],\n  rowSize: [number, number]\n) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.layoutHeight;\n      }\n      leftOffsets[i] = x + frame.layoutWidth / 2;\n      x += frame.layoutWidth;\n    } else {\n      log.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\n/**\n * Transform a text paragraph to an array of characters, each character contains\n */\nexport function transformParagraph(\n  paragraph: string,\n  /** CSS line-height */\n  lineHeight: number,\n  /** CSS word-break option */\n  wordBreak: 'break-word' | 'break-all',\n  /** CSS max-width */\n  maxWidth: number,\n  /** character mapping table for retrieving a character from font atlas */\n  iconMapping: CharacterMapping\n): {\n  /** x position of each character */\n  x: number[];\n  /** y position of each character */\n  y: number[];\n  /** the current row width of each character */\n  rowWidth: number[];\n  /** the width and height of the paragraph */\n  size: [number, number];\n} {\n  // Break into an array of characters\n  // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters) as number[];\n  const y = new Array(numCharacters) as number[];\n  const rowWidth = new Array(numCharacters) as number[];\n  const autoWrappingEnabled =\n    (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n\n  // maxWidth and height of the paragraph\n  const size: [number, number] = [0, 0];\n  const rowSize: [number, number] = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled\n        ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex)\n        : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n        for (let j = rowStart; j < rowEnd; j++) {\n          const char = characters[j];\n          const layoutOffsetY = iconMapping[char]?.layoutOffsetY || 0;\n          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      // Make sure result.length matches paragraph.length\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  // last row\n  size[1] = rowOffsetTop;\n  return {x, y, rowWidth, size};\n}\n\nexport function getTextFromBuffer({\n  value,\n  length,\n  stride,\n  offset,\n  startIndices,\n  characterSet\n}: {\n  value: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array;\n  length: number;\n  stride?: number;\n  offset?: number;\n  startIndices: NumericArray;\n  characterSet?: Set<string>;\n}): {\n  texts: string[];\n  characterCount: number;\n} {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount =\n    startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set<number>();\n\n  const texts = new Array(length);\n\n  let codes = value;\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor as\n      | Uint8ArrayConstructor\n      | Uint8ClampedArrayConstructor\n      | Uint16ArrayConstructor\n      | Uint32ArrayConstructor;\n    codes = new ArrayType(characterCount);\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    // @ts-ignore TS wants the argument to be number[] but typed array works too\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n    if (autoCharacterSet) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n\n  return {texts, characterCount};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}