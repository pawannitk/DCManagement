{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport { DatasourceType, QueryFormData, SupersetClient, t } from '@superset-ui/core';\nimport { addSuccessToast } from 'src/components/MessageToasts/actions';\n\nimport { Operators } from '../constants';\nimport { buildV1ChartDataPayload } from '../exploreUtils';\nconst ADHOC_FILTER_REGEX = /^adhoc_filters/;\nexport const FETCH_DASHBOARDS_SUCCEEDED = 'FETCH_DASHBOARDS_SUCCEEDED';\nexport function fetchDashboardsSucceeded(choices) {\n  return { type: FETCH_DASHBOARDS_SUCCEEDED, choices };\n}\nexport const FETCH_DASHBOARDS_FAILED = 'FETCH_DASHBOARDS_FAILED';\nexport function fetchDashboardsFailed(userId) {\n  return { type: FETCH_DASHBOARDS_FAILED, userId };\n}\nexport const SET_SAVE_CHART_MODAL_VISIBILITY = 'SET_SAVE_CHART_MODAL_VISIBILITY';\nexport function setSaveChartModalVisibility(isVisible) {\n  return { type: SET_SAVE_CHART_MODAL_VISIBILITY, isVisible };\n}\nexport const SAVE_SLICE_FAILED = 'SAVE_SLICE_FAILED';\nexport function saveSliceFailed() {\n  return { type: SAVE_SLICE_FAILED };\n}\nexport const SAVE_SLICE_SUCCESS = 'SAVE_SLICE_SUCCESS';\nexport function saveSliceSuccess(data) {\n  return { type: SAVE_SLICE_SUCCESS, data };\n}\nfunction extractAdhocFiltersFromFormData(formDataToHandle) {\n  const result = {};\n  Object.entries(formDataToHandle).forEach(([key, value]) => {\n    if (ADHOC_FILTER_REGEX.test(key) && Array.isArray(value)) {\n      result[key] = value.filter((f) => !f.isExtra);\n    }\n  });\n  return result;\n}\nconst hasTemporalRangeFilter = (formData) => ((formData == null ? void 0 : formData.adhoc_filters) || []).some((filter) => filter.operator === Operators.TemporalRange);\nexport const getSlicePayload = (sliceName, formDataWithNativeFilters = {}, dashboards, owners, formDataFromSlice = {}) => {\n  const adhocFilters = extractAdhocFiltersFromFormData(formDataWithNativeFilters);\n  if (!_isEmpty(formDataFromSlice) &&\n  formDataWithNativeFilters.adhoc_filters &&\n  formDataWithNativeFilters.adhoc_filters.length > 0) {\n    Object.keys(adhocFilters).forEach((adhocFilterKey) => {\n      if (_isEmpty(adhocFilters[adhocFilterKey])) {\n        const sourceFilters = formDataFromSlice[adhocFilterKey];\n        if (Array.isArray(sourceFilters)) {\n          const targetArray = adhocFilters[adhocFilterKey] || [];\n          sourceFilters.forEach((filter) => {\n            if (filter.operator === Operators.TemporalRange) {\n              targetArray.push({\n                ...filter,\n                comparator: filter.comparator || 'No filter'\n              });\n            }\n          });\n          adhocFilters[adhocFilterKey] = targetArray;\n        }\n      }\n    });\n  }\n  if (!hasTemporalRangeFilter(adhocFilters)) {var _formDataWithNativeFi;\n    (_formDataWithNativeFi = formDataWithNativeFilters.adhoc_filters) == null ? void 0 : _formDataWithNativeFi.forEach((filter) => {\n      if (filter.operator === Operators.TemporalRange && filter.isExtra) {\n        if (!adhocFilters.adhoc_filters) {\n          adhocFilters.adhoc_filters = [];\n        }\n        adhocFilters.adhoc_filters.push({\n          ...filter,\n          comparator: 'No filter'\n        });\n      }\n    });\n  }\n  const formData = {\n    ...formDataWithNativeFilters,\n    ...adhocFilters,\n    dashboards\n  };\n  let datasourceId = 0;\n  let datasourceType = DatasourceType.Table;\n  if (formData.datasource) {\n    const [id, typeString] = formData.datasource.split('__');\n    datasourceId = parseInt(id, 10);\n    const formattedTypeString = typeString.charAt(0).toUpperCase() + typeString.slice(1);\n    if (formattedTypeString in DatasourceType) {\n      datasourceType =\n      DatasourceType[formattedTypeString];\n    }\n  }\n  const payload = {\n    params: JSON.stringify(formData),\n    slice_name: sliceName,\n    viz_type: formData.viz_type,\n    datasource_id: datasourceId,\n    datasource_type: datasourceType,\n    dashboards,\n    owners,\n    query_context: JSON.stringify(buildV1ChartDataPayload({\n      formData,\n      force: false,\n      resultFormat: 'json',\n      resultType: 'full',\n      setDataMask: null,\n      ownState: null\n    }))\n  };\n  return payload;\n};\nconst addToasts = (isNewSlice, sliceName, addedToDashboard) => {\n  const toasts = [];\n  if (isNewSlice) {\n    toasts.push(addSuccessToast(t('Chart [%s] has been saved', sliceName)));\n  } else\n  {\n    toasts.push(addSuccessToast(t('Chart [%s] has been overwritten', sliceName)));\n  }\n  if (addedToDashboard) {\n    if (addedToDashboard.new) {\n      toasts.push(addSuccessToast(t('Dashboard [%s] just got created and chart [%s] was added to it', addedToDashboard.title, sliceName)));\n    } else\n    {\n      toasts.push(addSuccessToast(t('Chart [%s] was added to dashboard [%s]', sliceName, addedToDashboard.title)));\n    }\n  }\n  return toasts;\n};\nexport const updateSlice = (slice, sliceName, dashboards, addedToDashboard) => async (dispatch, getState) => {var _getState$explore;\n  const { slice_id: sliceId, owners, form_data: formDataFromSlice } = slice;\n  const formData = (_getState$explore = getState().explore) == null ? void 0 : _getState$explore.form_data;\n  try {\n    const response = await SupersetClient.put({\n      endpoint: `/api/v1/chart/${sliceId}`,\n      jsonPayload: getSlicePayload(sliceName, formData, dashboards, owners, formDataFromSlice)\n    });\n    dispatch(saveSliceSuccess(response.json));\n    addToasts(false, sliceName, addedToDashboard).map(dispatch);\n    return response.json;\n  }\n  catch (error) {\n    dispatch(saveSliceFailed());\n    throw error;\n  }\n};\nexport const createSlice = (sliceName, dashboards, addedToDashboard) => async (dispatch, getState) => {var _getState$explore2;\n  const formData = (_getState$explore2 = getState().explore) == null ? void 0 : _getState$explore2.form_data;\n  try {\n    const response = await SupersetClient.post({\n      endpoint: `/api/v1/chart/`,\n      jsonPayload: getSlicePayload(sliceName, formData, dashboards, [], {})\n    });\n    dispatch(saveSliceSuccess(response.json));\n    addToasts(true, sliceName, addedToDashboard).map(dispatch);\n    return response.json;\n  }\n  catch (error) {\n    dispatch(saveSliceFailed());\n    throw error;\n  }\n};\nexport const createDashboard = (dashboardName) => async (dispatch) => {\n  try {\n    const response = await SupersetClient.post({\n      endpoint: `/api/v1/dashboard/`,\n      jsonPayload: { dashboard_title: dashboardName }\n    });\n    return response.json;\n  }\n  catch (error) {\n    dispatch(saveSliceFailed());\n    throw error;\n  }\n};\nexport const getSliceDashboards = (slice) => async (dispatch) => {\n  try {\n    const response = await SupersetClient.get({\n      endpoint: `/api/v1/chart/${slice.slice_id}?q=${rison.encode({\n        columns: ['dashboards.id']\n      })}`\n    });\n    return response.json.result.dashboards.map(({ id }) => id);\n  }\n  catch (error) {\n    dispatch(saveSliceFailed());\n    throw error;\n  }\n};\nexport { QueryFormData };;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ADHOC_FILTER_REGEX, \"ADHOC_FILTER_REGEX\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(FETCH_DASHBOARDS_SUCCEEDED, \"FETCH_DASHBOARDS_SUCCEEDED\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(fetchDashboardsSucceeded, \"fetchDashboardsSucceeded\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(FETCH_DASHBOARDS_FAILED, \"FETCH_DASHBOARDS_FAILED\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(fetchDashboardsFailed, \"fetchDashboardsFailed\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(SET_SAVE_CHART_MODAL_VISIBILITY, \"SET_SAVE_CHART_MODAL_VISIBILITY\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(setSaveChartModalVisibility, \"setSaveChartModalVisibility\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(SAVE_SLICE_FAILED, \"SAVE_SLICE_FAILED\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(saveSliceFailed, \"saveSliceFailed\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(SAVE_SLICE_SUCCESS, \"SAVE_SLICE_SUCCESS\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(saveSliceSuccess, \"saveSliceSuccess\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(extractAdhocFiltersFromFormData, \"extractAdhocFiltersFromFormData\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(hasTemporalRangeFilter, \"hasTemporalRangeFilter\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(getSlicePayload, \"getSlicePayload\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(addToasts, \"addToasts\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(updateSlice, \"updateSlice\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(createSlice, \"createSlice\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(createDashboard, \"createDashboard\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");reactHotLoader.register(getSliceDashboards, \"getSliceDashboards\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["rison","DatasourceType","QueryFormData","SupersetClient","t","addSuccessToast","Operators","buildV1ChartDataPayload","ADHOC_FILTER_REGEX","FETCH_DASHBOARDS_SUCCEEDED","fetchDashboardsSucceeded","choices","type","FETCH_DASHBOARDS_FAILED","fetchDashboardsFailed","userId","SET_SAVE_CHART_MODAL_VISIBILITY","setSaveChartModalVisibility","isVisible","SAVE_SLICE_FAILED","saveSliceFailed","SAVE_SLICE_SUCCESS","saveSliceSuccess","data","extractAdhocFiltersFromFormData","formDataToHandle","result","Object","entries","forEach","key","value","test","Array","isArray","filter","f","isExtra","hasTemporalRangeFilter","formData","adhoc_filters","some","operator","TemporalRange","getSlicePayload","sliceName","formDataWithNativeFilters","dashboards","owners","formDataFromSlice","adhocFilters","_isEmpty","length","keys","adhocFilterKey","sourceFilters","targetArray","push","comparator","_formDataWithNativeFi","datasourceId","datasourceType","Table","datasource","id","typeString","split","parseInt","formattedTypeString","charAt","toUpperCase","slice","payload","params","JSON","stringify","slice_name","viz_type","datasource_id","datasource_type","query_context","force","resultFormat","resultType","setDataMask","ownState","addToasts","isNewSlice","addedToDashboard","toasts","new","title","updateSlice","dispatch","getState","_getState$explore","slice_id","sliceId","form_data","explore","response","put","endpoint","jsonPayload","json","map","error","createSlice","_getState$explore2","post","createDashboard","dashboardName","dashboard_title","getSliceDashboards","get","encode","columns","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/actions/saveModalActions.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport { Dispatch } from 'redux';\nimport {\n  DatasourceType,\n  QueryFormData,\n  SimpleAdhocFilter,\n  SupersetClient,\n  t,\n} from '@superset-ui/core';\nimport { addSuccessToast } from 'src/components/MessageToasts/actions';\nimport { isEmpty } from 'lodash';\nimport { Slice } from 'src/dashboard/types';\nimport { Operators } from '../constants';\nimport { buildV1ChartDataPayload } from '../exploreUtils';\n\nexport interface PayloadSlice extends Slice {\n  params: string;\n  dashboards: number[];\n  query_context: string;\n}\nconst ADHOC_FILTER_REGEX = /^adhoc_filters/;\n\nexport const FETCH_DASHBOARDS_SUCCEEDED = 'FETCH_DASHBOARDS_SUCCEEDED';\nexport function fetchDashboardsSucceeded(choices: string[]) {\n  return { type: FETCH_DASHBOARDS_SUCCEEDED, choices };\n}\n\nexport const FETCH_DASHBOARDS_FAILED = 'FETCH_DASHBOARDS_FAILED';\nexport function fetchDashboardsFailed(userId: string) {\n  return { type: FETCH_DASHBOARDS_FAILED, userId };\n}\n\nexport const SET_SAVE_CHART_MODAL_VISIBILITY =\n  'SET_SAVE_CHART_MODAL_VISIBILITY';\nexport function setSaveChartModalVisibility(isVisible: boolean) {\n  return { type: SET_SAVE_CHART_MODAL_VISIBILITY, isVisible };\n}\n\nexport const SAVE_SLICE_FAILED = 'SAVE_SLICE_FAILED';\nexport function saveSliceFailed() {\n  return { type: SAVE_SLICE_FAILED };\n}\n\nexport const SAVE_SLICE_SUCCESS = 'SAVE_SLICE_SUCCESS';\nexport function saveSliceSuccess(data: Partial<QueryFormData>) {\n  return { type: SAVE_SLICE_SUCCESS, data };\n}\n\nfunction extractAdhocFiltersFromFormData(\n  formDataToHandle: QueryFormData,\n): Partial<QueryFormData> {\n  const result: Partial<QueryFormData> = {};\n  Object.entries(formDataToHandle).forEach(([key, value]) => {\n    if (ADHOC_FILTER_REGEX.test(key) && Array.isArray(value)) {\n      result[key] = (value as SimpleAdhocFilter[]).filter(\n        (f: SimpleAdhocFilter) => !f.isExtra,\n      );\n    }\n  });\n  return result;\n}\n\nconst hasTemporalRangeFilter = (formData: Partial<QueryFormData>): boolean =>\n  (formData?.adhoc_filters || []).some(\n    (filter: SimpleAdhocFilter) => filter.operator === Operators.TemporalRange,\n  );\n\nexport const getSlicePayload = (\n  sliceName: string,\n  formDataWithNativeFilters: QueryFormData = {} as QueryFormData,\n  dashboards: number[],\n  owners: [],\n  formDataFromSlice: QueryFormData = {} as QueryFormData,\n): Partial<PayloadSlice> => {\n  const adhocFilters: Partial<QueryFormData> = extractAdhocFiltersFromFormData(\n    formDataWithNativeFilters,\n  );\n\n  if (\n    !isEmpty(formDataFromSlice) &&\n    formDataWithNativeFilters.adhoc_filters &&\n    formDataWithNativeFilters.adhoc_filters.length > 0\n  ) {\n    Object.keys(adhocFilters).forEach(adhocFilterKey => {\n      if (isEmpty(adhocFilters[adhocFilterKey])) {\n        const sourceFilters = formDataFromSlice[adhocFilterKey];\n        if (Array.isArray(sourceFilters)) {\n          const targetArray = adhocFilters[adhocFilterKey] || [];\n          sourceFilters.forEach(filter => {\n            if (filter.operator === Operators.TemporalRange) {\n              targetArray.push({\n                ...filter,\n                comparator: filter.comparator || 'No filter',\n              });\n            }\n          });\n          adhocFilters[adhocFilterKey] = targetArray;\n        }\n      }\n    });\n  }\n\n  if (!hasTemporalRangeFilter(adhocFilters)) {\n    formDataWithNativeFilters.adhoc_filters?.forEach(\n      (filter: SimpleAdhocFilter) => {\n        if (filter.operator === Operators.TemporalRange && filter.isExtra) {\n          if (!adhocFilters.adhoc_filters) {\n            adhocFilters.adhoc_filters = [];\n          }\n          adhocFilters.adhoc_filters.push({\n            ...filter,\n            comparator: 'No filter',\n          });\n        }\n      },\n    );\n  }\n  const formData = {\n    ...formDataWithNativeFilters,\n    ...adhocFilters,\n    dashboards,\n  };\n  let datasourceId = 0;\n  let datasourceType: DatasourceType = DatasourceType.Table;\n\n  if (formData.datasource) {\n    const [id, typeString] = formData.datasource.split('__');\n    datasourceId = parseInt(id, 10);\n\n    const formattedTypeString =\n      typeString.charAt(0).toUpperCase() + typeString.slice(1);\n    if (formattedTypeString in DatasourceType) {\n      datasourceType =\n        DatasourceType[formattedTypeString as keyof typeof DatasourceType];\n    }\n  }\n\n  const payload: Partial<PayloadSlice> = {\n    params: JSON.stringify(formData),\n    slice_name: sliceName,\n    viz_type: formData.viz_type,\n    datasource_id: datasourceId,\n    datasource_type: datasourceType,\n    dashboards,\n    owners,\n    query_context: JSON.stringify(\n      buildV1ChartDataPayload({\n        formData,\n        force: false,\n        resultFormat: 'json',\n        resultType: 'full',\n        setDataMask: null,\n        ownState: null,\n      }),\n    ),\n  };\n\n  return payload;\n};\n\nconst addToasts = (\n  isNewSlice: boolean,\n  sliceName: string,\n  addedToDashboard?: {\n    title: string;\n    new?: boolean;\n  },\n) => {\n  const toasts = [];\n  if (isNewSlice) {\n    toasts.push(addSuccessToast(t('Chart [%s] has been saved', sliceName)));\n  } else {\n    toasts.push(\n      addSuccessToast(t('Chart [%s] has been overwritten', sliceName)),\n    );\n  }\n\n  if (addedToDashboard) {\n    if (addedToDashboard.new) {\n      toasts.push(\n        addSuccessToast(\n          t(\n            'Dashboard [%s] just got created and chart [%s] was added to it',\n            addedToDashboard.title,\n            sliceName,\n          ),\n        ),\n      );\n    } else {\n      toasts.push(\n        addSuccessToast(\n          t(\n            'Chart [%s] was added to dashboard [%s]',\n            sliceName,\n            addedToDashboard.title,\n          ),\n        ),\n      );\n    }\n  }\n\n  return toasts;\n};\n\nexport const updateSlice =\n  (\n    slice: Slice,\n    sliceName: string,\n    dashboards: number[],\n    addedToDashboard?: {\n      title: string;\n      new?: boolean;\n    },\n  ) =>\n  async (dispatch: Dispatch, getState: () => Partial<QueryFormData>) => {\n    const { slice_id: sliceId, owners, form_data: formDataFromSlice } = slice;\n    const formData = getState().explore?.form_data;\n    try {\n      const response = await SupersetClient.put({\n        endpoint: `/api/v1/chart/${sliceId}`,\n        jsonPayload: getSlicePayload(\n          sliceName,\n          formData,\n          dashboards,\n          owners as [],\n          formDataFromSlice,\n        ),\n      });\n\n      dispatch(saveSliceSuccess(response.json));\n      addToasts(false, sliceName, addedToDashboard).map(dispatch);\n      return response.json;\n    } catch (error) {\n      dispatch(saveSliceFailed());\n      throw error;\n    }\n  };\n\nexport const createSlice =\n  (\n    sliceName: string,\n    dashboards: number[],\n    addedToDashboard?: {\n      title: string;\n      new?: boolean;\n    },\n  ) =>\n  async (dispatch: Dispatch, getState: () => Partial<QueryFormData>) => {\n    const formData = getState().explore?.form_data;\n    try {\n      const response = await SupersetClient.post({\n        endpoint: `/api/v1/chart/`,\n        jsonPayload: getSlicePayload(\n          sliceName,\n          formData,\n          dashboards,\n          [],\n          {} as QueryFormData,\n        ),\n      });\n\n      dispatch(saveSliceSuccess(response.json));\n      addToasts(true, sliceName, addedToDashboard).map(dispatch);\n      return response.json;\n    } catch (error) {\n      dispatch(saveSliceFailed());\n      throw error;\n    }\n  };\n\nexport const createDashboard =\n  (dashboardName: string) => async (dispatch: Dispatch) => {\n    try {\n      const response = await SupersetClient.post({\n        endpoint: `/api/v1/dashboard/`,\n        jsonPayload: { dashboard_title: dashboardName },\n      });\n\n      return response.json;\n    } catch (error) {\n      dispatch(saveSliceFailed());\n      throw error;\n    }\n  };\n\nexport const getSliceDashboards =\n  (slice: Partial<Slice>) => async (dispatch: Dispatch) => {\n    try {\n      const response = await SupersetClient.get({\n        endpoint: `/api/v1/chart/${slice.slice_id}?q=${rison.encode({\n          columns: ['dashboards.id'],\n        })}`,\n      });\n\n      return response.json.result.dashboards.map(\n        ({ id }: { id: number }) => id,\n      );\n    } catch (error) {\n      dispatch(saveSliceFailed());\n      throw error;\n    }\n  };\nexport { QueryFormData };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}