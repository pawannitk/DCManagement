{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport TinySDF from '@mapbox/tiny-sdf';\nimport { log } from '@deck.gl/core';\nimport { buildMapping } from './utils';\nimport LRUCache from './lru-cache';\n\nfunction getDefaultCharacterSet() {\n  const charSet = [];\n\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n\n  return charSet;\n}\n\nexport const DEFAULT_FONT_SETTINGS = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\nconst MAX_CANVAS_WIDTH = 1024;\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\nconst CACHE_LIMIT = 3;\nlet cache = new LRUCache(CACHE_LIMIT);\n\nfunction getNewChars(cacheKey, characterSet) {\n  let newCharSet;\n\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n\n  const cachedFontAtlas = cache.get(cacheKey);\n\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n\n  for (const char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n\n  return newCharSet;\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = \"\".concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\n\nexport function setFontAtlasCacheLimit(limit) {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n  cache = new LRUCache(limit);\n}\nexport default class FontAtlasManager {\n  constructor() {\n    _defineProperty(this, \"props\", { ...DEFAULT_FONT_SETTINGS\n    });\n\n    _defineProperty(this, \"_key\", void 0);\n\n    _defineProperty(this, \"_atlas\", void 0);\n  }\n\n  get texture() {\n    return this._atlas;\n  }\n\n  get mapping() {\n    return this._atlas && this._atlas.mapping;\n  }\n\n  get scale() {\n    const {\n      fontSize,\n      buffer\n    } = this.props;\n    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;\n  }\n\n  setProps(props = {}) {\n    Object.assign(this.props, props);\n    this._key = this._getKey();\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    if (cachedFontAtlas && charSet.size === 0) {\n      if (this._atlas !== cachedFontAtlas) {\n        this._atlas = cachedFontAtlas;\n      }\n\n      return;\n    }\n\n    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);\n\n    this._atlas = fontAtlas;\n    cache.set(this._key, fontAtlas);\n  }\n\n  _generateFontAtlas(characterSet, cachedFontAtlas) {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n\n    const ctx = canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n    const {\n      mapping,\n      canvasHeight,\n      xOffset,\n      yOffset\n    } = buildMapping({\n      getFontWidth: (char) => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    if (sdf) {\n      const tinySDF = new TinySDF({\n        fontSize,\n        buffer,\n        radius,\n        cutoff,\n        fontFamily,\n        fontWeight: \"\".concat(fontWeight)\n      });\n\n      for (const char of characterSet) {\n        const {\n          data,\n          width,\n          height,\n          glyphTop\n        } = tinySDF.draw(char);\n        mapping[char].width = width;\n        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;\n        const imageData = ctx.createImageData(width, height);\n        populateAlphaChannel(data, imageData);\n        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  _getKey() {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n\n    if (sdf) {\n      return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer, \" \").concat(radius, \" \").concat(cutoff);\n    }\n\n    return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getDefaultCharacterSet, \"getDefaultCharacterSet\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(DEFAULT_FONT_SETTINGS, \"DEFAULT_FONT_SETTINGS\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(MAX_CANVAS_WIDTH, \"MAX_CANVAS_WIDTH\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(BASELINE_SCALE, \"BASELINE_SCALE\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(HEIGHT_SCALE, \"HEIGHT_SCALE\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(CACHE_LIMIT, \"CACHE_LIMIT\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(cache, \"cache\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(getNewChars, \"getNewChars\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(populateAlphaChannel, \"populateAlphaChannel\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(setTextStyle, \"setTextStyle\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(setFontAtlasCacheLimit, \"setFontAtlasCacheLimit\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");reactHotLoader.register(FontAtlasManager, \"FontAtlasManager\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["TinySDF","log","buildMapping","LRUCache","getDefaultCharacterSet","charSet","i","push","String","fromCharCode","DEFAULT_FONT_SETTINGS","fontFamily","fontWeight","characterSet","fontSize","buffer","sdf","cutoff","radius","smoothing","MAX_CANVAS_WIDTH","BASELINE_SCALE","HEIGHT_SCALE","CACHE_LIMIT","cache","getNewChars","cacheKey","newCharSet","Set","Array","from","cachedFontAtlas","get","char","mapping","has","delete","populateAlphaChannel","alphaChannel","imageData","length","data","setTextStyle","ctx","font","concat","fillStyle","textBaseline","textAlign","setFontAtlasCacheLimit","limit","assert","Number","isFinite","FontAtlasManager","constructor","_defineProperty","texture","_atlas","scale","props","setProps","Object","assign","_key","_getKey","size","fontAtlas","_generateFontAtlas","set","canvas","document","createElement","width","getContext","willReadFrequently","canvasHeight","xOffset","yOffset","getFontWidth","measureText","fontHeight","maxCanvasWidth","height","getImageData","putImageData","tinySDF","glyphTop","draw","layoutOffsetY","createImageData","x","y","fillText","__reactstandin__regenerateByEval","key","code","eval","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["../../../src/text-layer/font-atlas-manager.ts"],"sourcesContent":["/* global document */\nimport TinySDF from '@mapbox/tiny-sdf';\n\nimport {log} from '@deck.gl/core';\n\nimport {buildMapping, CharacterMapping} from './utils';\nimport LRUCache from './lru-cache';\n\nimport type {Texture} from '@deck.gl/core';\n\nfunction getDefaultCharacterSet() {\n  const charSet: string[] = [];\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\n\nexport type FontSettings = {\n  /** CSS font family\n   * @default 'Monaco, monospace'\n   */\n  fontFamily?: string;\n  /** CSS font weight\n   * @default 'normal'\n   */\n  fontWeight?: string | number;\n  /** Specifies a list of characters to include in the font.\n   * @default (ASCII characters 32-128)\n   */\n  characterSet?: Set<string> | string[] | string;\n  /** Font size in pixels. This option is only applied for generating `fontAtlas`, it does not impact the size of displayed text labels. Larger `fontSize` will give you a sharper look when rendering text labels with very large font sizes. But larger `fontSize` requires more time and space to generate the `fontAtlas`.\n   * @default 64\n   */\n  fontSize?: number;\n  /** Whitespace buffer around each side of the character. In general, bigger `fontSize` requires bigger `buffer`. Increase `buffer` will add more space between each character when layout `characterSet` in `fontAtlas`. This option could be tuned to provide sufficient space for drawing each character and avoiding overlapping of neighboring characters.\n   * @default 4\n   */\n  buffer?: number;\n  /** Flag to enable / disable `sdf`. [`sdf` (Signed Distance Fields)](http://cs.brown.edu/people/pfelzens/papers/dt-final.pdf) will provide a sharper look when rendering with very large or small font sizes. `TextLayer` integrates with [`TinySDF`](https://github.com/mapbox/tiny-sdf) which implements the `sdf` algorithm.\n   * @default false\n   */\n  sdf?: boolean;\n  /** How much of the radius (relative) is used for the inside part the glyph. Bigger `cutoff` makes character thinner. Smaller `cutoff` makes character look thicker. Only applies when `sdf: true`.\n   * @default 0.25\n   */\n  cutoff?: number;\n  /** How many pixels around the glyph shape to use for encoding distance. Bigger radius yields higher quality outcome. Only applies when `sdf: true`.\n   * @default 12\n   */\n  radius?: number;\n  /** How much smoothing to apply to the text edges. Only applies when `sdf: true`.\n   * @default 0.1\n   */\n  smoothing?: number;\n};\n\nexport const DEFAULT_FONT_SETTINGS: Required<FontSettings> = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\n\nconst MAX_CANVAS_WIDTH = 1024;\n\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\n\n// only preserve latest three fontAtlas\nconst CACHE_LIMIT = 3;\n\ntype FontAtlas = {\n  /** x position of last character in mapping */\n  xOffset: number;\n  /** y position of last character in mapping */\n  yOffset: number;\n  /** bounding box of each character in the texture */\n  mapping: CharacterMapping;\n  /** packed texture */\n  data: HTMLCanvasElement;\n  /** texture width */\n  width: number;\n  /** texture height */\n  height: number;\n};\n\nlet cache = new LRUCache<FontAtlas>(CACHE_LIMIT);\n\n/**\n * get all the chars not in cache\n * @returns chars not in cache\n */\nfunction getNewChars(cacheKey: string, characterSet: Set<string> | string[] | string): Set<string> {\n  let newCharSet: Set<string>;\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n\n  const cachedFontAtlas = cache.get(cacheKey);\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n\n  for (const char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n  return newCharSet;\n}\n\nfunction populateAlphaChannel(alphaChannel: Uint8ClampedArray, imageData: ImageData): void {\n  // populate distance value from tinySDF to image alpha channel\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(\n  ctx: CanvasRenderingContext2D,\n  fontFamily: string,\n  fontSize: number,\n  fontWeight: string | number\n): void {\n  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\n\n/**\n * Sets the Font Atlas LRU Cache Limit\n * @param {number} limit LRU Cache limit\n */\nexport function setFontAtlasCacheLimit(limit: number): void {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n\n  cache = new LRUCache(limit);\n}\n\nexport default class FontAtlasManager {\n  /** Font settings */\n  props: Required<FontSettings> = {...DEFAULT_FONT_SETTINGS};\n\n  /** Cache key of the current font atlas */\n  private _key?: string;\n  /** The current font atlas */\n  private _atlas?: FontAtlas;\n\n  get texture(): Texture | undefined {\n    return this._atlas;\n  }\n\n  get mapping(): CharacterMapping | undefined {\n    return this._atlas && this._atlas.mapping;\n  }\n\n  get scale(): number {\n    const {fontSize, buffer} = this.props;\n    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;\n  }\n\n  setProps(props: FontSettings = {}) {\n    Object.assign(this.props, props);\n\n    // update cache key\n    this._key = this._getKey();\n\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    // if a fontAtlas associated with the new settings is cached and\n    // there are no new chars\n    if (cachedFontAtlas && charSet.size === 0) {\n      // update texture with cached fontAtlas\n      if (this._atlas !== cachedFontAtlas) {\n        this._atlas = cachedFontAtlas;\n      }\n      return;\n    }\n\n    // update fontAtlas with new settings\n    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);\n    this._atlas = fontAtlas;\n\n    // update cache\n    cache.set(this._key, fontAtlas);\n  }\n\n  // eslint-disable-next-line max-statements\n  private _generateFontAtlas(characterSet: Set<string>, cachedFontAtlas?: FontAtlas): FontAtlas {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n    const ctx = canvas.getContext('2d', {willReadFrequently: true})!;\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 1. build mapping\n    const {mapping, canvasHeight, xOffset, yOffset} = buildMapping({\n      getFontWidth: char => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n\n    // 2. update canvas\n    // copy old canvas data to new canvas only when height changed\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 3. layout characters\n    if (sdf) {\n      const tinySDF = new TinySDF({\n        fontSize,\n        buffer,\n        radius,\n        cutoff,\n        fontFamily,\n        fontWeight: `${fontWeight}`\n      });\n\n      for (const char of characterSet) {\n        const {data, width, height, glyphTop} = tinySDF.draw(char);\n        mapping[char].width = width;\n        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;\n\n        const imageData = ctx.createImageData(width, height);\n        populateAlphaChannel(data, imageData);\n        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  private _getKey(): string {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    if (sdf) {\n      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;\n    }\n    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;\n  }\n}\n"],"mappings":";AACA,OAAOA,OAAP,MAAoB,kBAApB;AAEA,SAAQC,GAAR,QAAkB,eAAlB;AAEA,SAAQC,YAAR,QAA6C,SAA7C;AACA,OAAOC,QAAP,MAAqB,aAArB;;AAIA,SAASC,sBAATA,CAAA,EAAkC;EAChC,MAAMC,OAAiB,GAAG,EAA1B;;EACA,KAAK,IAAIC,CAAC,GAAG,EAAb,EAAiBA,CAAC,GAAG,GAArB,EAA0BA,CAAC,EAA3B,EAA+B;IAC7BD,OAAO,CAACE,IAAR,CAAaC,MAAM,CAACC,YAAP,CAAoBH,CAApB,CAAb;EACD;;EACD,OAAOD,OAAP;AACD;;AAyCD,OAAO,MAAMK,qBAA6C,GAAG;EAC3DC,UAAU,EAAE,mBAD+C;EAE3DC,UAAU,EAAE,QAF+C;EAG3DC,YAAY,EAAET,sBAAsB,EAHuB;EAI3DU,QAAQ,EAAE,EAJiD;EAK3DC,MAAM,EAAE,CALmD;EAM3DC,GAAG,EAAE,KANsD;EAO3DC,MAAM,EAAE,IAPmD;EAQ3DC,MAAM,EAAE,EARmD;EAS3DC,SAAS,EAAE;AATgD,CAAtD;AAYP,MAAMC,gBAAgB,GAAG,IAAzB;AAEA,MAAMC,cAAc,GAAG,GAAvB;AACA,MAAMC,YAAY,GAAG,GAArB;AAGA,MAAMC,WAAW,GAAG,CAApB;AAiBA,IAAIC,KAAK,GAAG,IAAIrB,QAAJ,CAAwBoB,WAAxB,CAAZ;;AAMA,SAASE,WAATA,CAAqBC,QAArB,EAAuCb,YAAvC,EAAmG;EACjG,IAAIc,UAAJ;;EACA,IAAI,OAAOd,YAAP,KAAwB,QAA5B,EAAsC;IACpCc,UAAU,GAAG,IAAIC,GAAJ,CAAQC,KAAK,CAACC,IAAN,CAAWjB,YAAX,CAAR,CAAb;EACD,CAFD,MAEO;IACLc,UAAU,GAAG,IAAIC,GAAJ,CAAQf,YAAR,CAAb;EACD;;EAED,MAAMkB,eAAe,GAAGP,KAAK,CAACQ,GAAN,CAAUN,QAAV,CAAxB;;EACA,IAAI,CAACK,eAAL,EAAsB;IACpB,OAAOJ,UAAP;EACD;;EAED,KAAK,MAAMM,IAAX,IAAmBF,eAAe,CAACG,OAAnC,EAA4C;IAC1C,IAAIP,UAAU,CAACQ,GAAX,CAAeF,IAAf,CAAJ,EAA0B;MACxBN,UAAU,CAACS,MAAX,CAAkBH,IAAlB;IACD;EACF;;EACD,OAAON,UAAP;AACD;;AAED,SAASU,oBAATA,CAA8BC,YAA9B,EAA+DC,SAA/D,EAA2F;EAEzF,KAAK,IAAIjC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgC,YAAY,CAACE,MAAjC,EAAyClC,CAAC,EAA1C,EAA8C;IAC5CiC,SAAS,CAACE,IAAV,CAAe,IAAInC,CAAJ,GAAQ,CAAvB,IAA4BgC,YAAY,CAAChC,CAAD,CAAxC;EACD;AACF;;AAED,SAASoC,YAATA,CACEC,GADF,EAEEhC,UAFF,EAGEG,QAHF,EAIEF,UAJF,EAKQ;EACN+B,GAAG,CAACC,IAAJ,MAAAC,MAAA,CAAcjC,UAAd,OAAAiC,MAAA,CAA4B/B,QAA5B,SAAA+B,MAAA,CAA0ClC,UAA1C;EACAgC,GAAG,CAACG,SAAJ,GAAgB,MAAhB;EACAH,GAAG,CAACI,YAAJ,GAAmB,YAAnB;EACAJ,GAAG,CAACK,SAAJ,GAAgB,MAAhB;AACD;;AAMD,OAAO,SAASC,sBAATA,CAAgCC,KAAhC,EAAqD;EAC1DjD,GAAG,CAACkD,MAAJ,CAAWC,MAAM,CAACC,QAAP,CAAgBH,KAAhB,KAA0BA,KAAK,IAAI3B,WAA9C,EAA2D,qBAA3D;EAEAC,KAAK,GAAG,IAAIrB,QAAJ,CAAa+C,KAAb,CAAR;AACD;AAED,eAAe,MAAMI,gBAAN,CAAuB;EAAAC,YAAA;IAAAC,eAAA,gBAEJ,EAAC,GAAG9C;IAAJ,CAFI;;IAAA8C,eAAA;;IAAAA,eAAA;EAAA;;EASzB,IAAPC,OAAOA,CAAA,EAAwB;IACjC,OAAO,KAAKC,MAAZ;EACD;;EAEU,IAAPxB,OAAOA,CAAA,EAAiC;IAC1C,OAAO,KAAKwB,MAAL,IAAe,KAAKA,MAAL,CAAYxB,OAAlC;EACD;;EAEQ,IAALyB,KAAKA,CAAA,EAAW;IAClB,MAAM;MAAC7C,QAAD;MAAWC;IAAX,IAAqB,KAAK6C,KAAhC;IACA,OAAO,CAAC9C,QAAQ,GAAGQ,YAAX,GAA0BP,MAAM,GAAG,CAApC,IAAyCD,QAAhD;EACD;;EAED+C,QAAQA,CAACD,KAAmB,GAAG,EAAvB,EAA2B;IACjCE,MAAM,CAACC,MAAP,CAAc,KAAKH,KAAnB,EAA0BA,KAA1B;IAGA,KAAKI,IAAL,GAAY,KAAKC,OAAL,EAAZ;IAEA,MAAM5D,OAAO,GAAGoB,WAAW,CAAC,KAAKuC,IAAN,EAAY,KAAKJ,KAAL,CAAW/C,YAAvB,CAA3B;IACA,MAAMkB,eAAe,GAAGP,KAAK,CAACQ,GAAN,CAAU,KAAKgC,IAAf,CAAxB;;IAIA,IAAIjC,eAAe,IAAI1B,OAAO,CAAC6D,IAAR,KAAiB,CAAxC,EAA2C;MAEzC,IAAI,KAAKR,MAAL,KAAgB3B,eAApB,EAAqC;QACnC,KAAK2B,MAAL,GAAc3B,eAAd;MACD;;MACD;IACD;;IAGD,MAAMoC,SAAS,GAAG,KAAKC,kBAAL,CAAwB/D,OAAxB,EAAiC0B,eAAjC,CAAlB;;IACA,KAAK2B,MAAL,GAAcS,SAAd;IAGA3C,KAAK,CAAC6C,GAAN,CAAU,KAAKL,IAAf,EAAqBG,SAArB;EACD;;EAGOC,kBAAkBA,CAACvD,YAAD,EAA4BkB,eAA5B,EAAoE;IAC5F,MAAM;MAACpB,UAAD;MAAaC,UAAb;MAAyBE,QAAzB;MAAmCC,MAAnC;MAA2CC,GAA3C;MAAgDE,MAAhD;MAAwDD;IAAxD,IAAkE,KAAK2C,KAA7E;IACA,IAAIU,MAAM,GAAGvC,eAAe,IAAIA,eAAe,CAACU,IAAhD;;IACA,IAAI,CAAC6B,MAAL,EAAa;MACXA,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAT;MACAF,MAAM,CAACG,KAAP,GAAerD,gBAAf;IACD;;IACD,MAAMuB,GAAG,GAAG2B,MAAM,CAACI,UAAP,CAAkB,IAAlB,EAAwB;MAACC,kBAAkB,EAAE;IAArB,CAAxB,CAAZ;IAEAjC,YAAY,CAACC,GAAD,EAAMhC,UAAN,EAAkBG,QAAlB,EAA4BF,UAA5B,CAAZ;IAGA,MAAM;MAACsB,OAAD;MAAU0C,YAAV;MAAwBC,OAAxB;MAAiCC;IAAjC,IAA4C5E,YAAY,CAAC;MAC7D6E,YAAY,EAAEA,CAAA9C,IAAI,KAAIU,GAAG,CAACqC,WAAJ,CAAgB/C,IAAhB,EAAsBwC,KADiB;MAE7DQ,UAAU,EAAEnE,QAAQ,GAAGQ,YAFsC;MAG7DP,MAH6D;MAI7DF,YAJ6D;MAK7DqE,cAAc,EAAE9D,gBAL6C;MAM7D,IAAIW,eAAe,IAAI;QACrBG,OAAO,EAAEH,eAAe,CAACG,OADJ;QAErB2C,OAAO,EAAE9C,eAAe,CAAC8C,OAFJ;QAGrBC,OAAO,EAAE/C,eAAe,CAAC+C;MAHJ,CAAvB;IAN6D,CAAD,CAA9D;;IAeA,IAAIR,MAAM,CAACa,MAAP,KAAkBP,YAAtB,EAAoC;MAClC,MAAMrC,SAAS,GAAGI,GAAG,CAACyC,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuBd,MAAM,CAACG,KAA9B,EAAqCH,MAAM,CAACa,MAA5C,CAAlB;MACAb,MAAM,CAACa,MAAP,GAAgBP,YAAhB;MACAjC,GAAG,CAAC0C,YAAJ,CAAiB9C,SAAjB,EAA4B,CAA5B,EAA+B,CAA/B;IACD;;IACDG,YAAY,CAACC,GAAD,EAAMhC,UAAN,EAAkBG,QAAlB,EAA4BF,UAA5B,CAAZ;;IAGA,IAAII,GAAJ,EAAS;MACP,MAAMsE,OAAO,GAAG,IAAItF,OAAJ,CAAY;QAC1Bc,QAD0B;QAE1BC,MAF0B;QAG1BG,MAH0B;QAI1BD,MAJ0B;QAK1BN,UAL0B;QAM1BC,UAAU,KAAAiC,MAAA,CAAKjC,UAAL;MANgB,CAAZ,CAAhB;;MASA,KAAK,MAAMqB,IAAX,IAAmBpB,YAAnB,EAAiC;QAC/B,MAAM;UAAC4B,IAAD;UAAOgC,KAAP;UAAcU,MAAd;UAAsBI;QAAtB,IAAkCD,OAAO,CAACE,IAAR,CAAavD,IAAb,CAAxC;QACAC,OAAO,CAACD,IAAD,CAAP,CAAcwC,KAAd,GAAsBA,KAAtB;QACAvC,OAAO,CAACD,IAAD,CAAP,CAAcwD,aAAd,GAA8B3E,QAAQ,GAAGO,cAAX,GAA4BkE,QAA1D;QAEA,MAAMhD,SAAS,GAAGI,GAAG,CAAC+C,eAAJ,CAAoBjB,KAApB,EAA2BU,MAA3B,CAAlB;QACA9C,oBAAoB,CAACI,IAAD,EAAOF,SAAP,CAApB;QACAI,GAAG,CAAC0C,YAAJ,CAAiB9C,SAAjB,EAA4BL,OAAO,CAACD,IAAD,CAAP,CAAc0D,CAA1C,EAA6CzD,OAAO,CAACD,IAAD,CAAP,CAAc2D,CAA3D;MACD;IACF,CAnBD,MAmBO;MACL,KAAK,MAAM3D,IAAX,IAAmBpB,YAAnB,EAAiC;QAC/B8B,GAAG,CAACkD,QAAJ,CAAa5D,IAAb,EAAmBC,OAAO,CAACD,IAAD,CAAP,CAAc0D,CAAjC,EAAoCzD,OAAO,CAACD,IAAD,CAAP,CAAc2D,CAAd,GAAkB7E,MAAlB,GAA2BD,QAAQ,GAAGO,cAA1E;MACD;IACF;;IAED,OAAO;MACLwD,OADK;MAELC,OAFK;MAGL5C,OAHK;MAILO,IAAI,EAAE6B,MAJD;MAKLG,KAAK,EAAEH,MAAM,CAACG,KALT;MAMLU,MAAM,EAAEb,MAAM,CAACa;IANV,CAAP;EAQD;;EAEOlB,OAAOA,CAAA,EAAW;IACxB,MAAM;MAACtD,UAAD;MAAaC,UAAb;MAAyBE,QAAzB;MAAmCC,MAAnC;MAA2CC,GAA3C;MAAgDE,MAAhD;MAAwDD;IAAxD,IAAkE,KAAK2C,KAA7E;;IACA,IAAI5C,GAAJ,EAAS;MACP,UAAA6B,MAAA,CAAUlC,UAAV,OAAAkC,MAAA,CAAwBjC,UAAxB,OAAAiC,MAAA,CAAsC/B,QAAtC,OAAA+B,MAAA,CAAkD9B,MAAlD,OAAA8B,MAAA,CAA4D3B,MAA5D,OAAA2B,MAAA,CAAsE5B,MAAtE;IACD;;IACD,UAAA4B,MAAA,CAAUlC,UAAV,OAAAkC,MAAA,CAAwBjC,UAAxB,OAAAiC,MAAA,CAAsC/B,QAAtC,OAAA+B,MAAA,CAAkD9B,MAAlD;EACD;EAAA+E,iCAAAC,GAAA,EAAAC,IAAA;IAAA,KAAAD,GAAA,IAAAE,IAAA,CAAAD,IAAA,GA9HmC,oBAAAE,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAC,SAAA,MAAAH,cAAA,WAAAA,cAAA,CAAAI,QAAA,CA1I7BlG,sBAAT,gMAAA8F,cAAA,CAAAI,QAAA,CA+Ca5F,qBAA6C,+LAAAwF,cAAA,CAAAI,QAAA,CAYpDlF,gBAAgB,0LAAA8E,cAAA,CAAAI,QAAA,CAEhBjF,cAAc,wLAAA6E,cAAA,CAAAI,QAAA,CACdhF,YAAY,sLAAA4E,cAAA,CAAAI,QAAA,CAGZ/E,WAAW,qLAAA2E,cAAA,CAAAI,QAAA,CAiBb9E,KAAK,+KAAA0E,cAAA,CAAAI,QAAA,CAMA7E,WAAT,qLAAAyE,cAAA,CAAAI,QAAA,CAqBSjE,oBAAT,8LAAA6D,cAAA,CAAAI,QAAA,CAOS5D,YAAT,sLAAAwD,cAAA,CAAAI,QAAA,CAgBgBrD,sBAAT,gMAAAiD,cAAA,CAAAI,QAAA,CAMchD,gBAAN,kNAAAiD,WAAA,UAAAJ,oBAAA,mBAAAA,oBAAA,CAAAI,WAAA,GAAAF,SAAA,CAAAE,WAAA,IAAAA,WAAA,CAAAC,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}