{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nconst defaultProps = { ...ScreenGridCellLayer.defaultProps,\n  getPosition: {\n    type: 'accessor',\n    value: (d) => d.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      this.setState({\n        supported: false\n      });\n      log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n      return;\n    }\n\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS,\n      getCellSize: (props) => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {\n          id: \"\".concat(this.id, \"-max-texture\")\n        })\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true,\n      weights,\n      subLayerData: {\n        attributes: {}\n      },\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n\n    const {\n      maxTexture,\n      numRow,\n      numCol,\n      weights\n    } = this.state;\n    const {\n      updateTriggers\n    } = this.props;\n    const {\n      aggregationBuffer\n    } = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    return new CellLayerClass(this.props, this.getSubLayerProps({\n      id: 'cell-layer',\n      updateTriggers\n    }), {\n      data: {\n        attributes: {\n          instanceCounts: aggregationBuffer\n        }\n      },\n      maxTexture,\n      numInstances: numRow * numCol\n    });\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n    const {\n      aggregationBuffer,\n      maxBuffer,\n      maxTexture\n    } = this.state;\n    aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    maxBuffer === null || maxBuffer === void 0 ? void 0 : maxBuffer.delete();\n    maxTexture === null || maxTexture === void 0 ? void 0 : maxTexture.delete();\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    const {\n      index\n    } = info;\n\n    if (index >= 0) {\n      const {\n        gpuGridAggregator,\n        gpuAggregation,\n        weights\n      } = this.state;\n      const aggregationResults = gpuAggregation ? gpuGridAggregator.getData('count') : weights.count;\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  updateResults({\n    aggregationData,\n    maxData\n  }) {\n    const {\n      count\n    } = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({\n      data: aggregationData\n    });\n    count.maxData = maxData;\n    count.maxTexture.setImageData({\n      data: maxData\n    });\n  }\n\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {\n      viewportChanged\n    } = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      dimensions\n    } = this.state;\n    const {\n      data,\n      weights\n    } = dimensions;\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n      compareAll: gpuAggregation,\n      dimension: data\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n    const {\n      viewport\n    } = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {\n        width,\n        height\n      } = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        scaling: [width / 2, -height / 2, 1],\n        gridOffset: {\n          xOffset: cellSize,\n          yOffset: cellSize\n        },\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.aggregationData = null;\n    }\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\n_defineProperty(ScreenGridLayer, \"layerName\", 'ScreenGridLayer');\n\n_defineProperty(ScreenGridLayer, \"defaultProps\", defaultProps);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(defaultProps, \"defaultProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/screen-grid-layer/screen-grid-layer.js\");reactHotLoader.register(POSITION_ATTRIBUTE_NAME, \"POSITION_ATTRIBUTE_NAME\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/screen-grid-layer/screen-grid-layer.js\");reactHotLoader.register(DIMENSIONS, \"DIMENSIONS\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/screen-grid-layer/screen-grid-layer.js\");reactHotLoader.register(ScreenGridLayer, \"ScreenGridLayer\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/screen-grid-layer/screen-grid-layer.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["log","GPUGridAggregator","AGGREGATION_OPERATION","getValueFunc","ScreenGridCellLayer","GridAggregationLayer","getFloatTexture","defaultProps","getPosition","type","value","d","position","getWeight","gpuAggregation","aggregation","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ScreenGridLayer","constructor","args","_defineProperty","initializeState","gl","context","isSupported","setState","supported","error","concat","id","initializeAggregationLayer","dimensions","getCellSize","cellSizePixels","count","size","operation","SUM","needMax","maxTexture","projectPoints","subLayerData","attributes","positionAttributeName","posOffset","translation","attributeManager","getAttributeManager","add","accessor","fp64","use64bitPositions","shouldUpdateState","changeFlags","state","somethingChanged","updateState","opts","renderLayers","numRow","numCol","updateTriggers","aggregationBuffer","CellLayerClass","getSubLayerClass","getSubLayerProps","instanceCounts","numInstances","finalizeState","maxBuffer","delete","getPickingInfo","info","index","gpuGridAggregator","aggregationResults","getData","object","getAggregationData","pixelIndex","updateResults","aggregationData","maxData","setData","setImageData","updateAggregationState","cellSize","cellSizeChanged","oldProps","viewportChanged","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","aggregationDataDirty","isAggregationDirty","compareAll","dimension","aggregationWeightsDirty","viewport","width","height","Math","ceil","allocateResources","scaling","gridOffset","xOffset","yOffset","_updateAccessors","_resetResults","getValue","__reactstandin__regenerateByEval","key","code","eval","reactHotLoader","register","leaveModule","reactHotLoaderGlobal","undefined","module"],"sources":["../../../src/screen-grid-layer/screen-grid-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  Color,\n  GetPickingInfoParams,\n  Layer,\n  LayerContext,\n  LayersList,\n  log,\n  PickingInfo,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport type {Texture2D} from '@luma.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\nimport {getFloatTexture} from '../utils/resource-utils.js';\n\nconst defaultProps: DefaultProps<ScreenGridLayerProps> = {\n  ...ScreenGridCellLayer.defaultProps,\n  getPosition: {type: 'accessor', value: d => d.position},\n  getWeight: {type: 'accessor', value: 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\n/** All properties supported by ScreenGridLayer. */\nexport type ScreenGridLayerProps<DataT = any> = _ScreenGridLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by ScreenGridLayer. */\nexport type _ScreenGridLayerProps<DataT> = {\n  /**\n   * Unit width/height of the bins.\n   * @default 100\n   */\n  cellSizePixels?: number;\n\n  /**\n   * Cell margin size in pixels.\n   * @default 2\n   */\n  cellMarginPixels?: number;\n\n  /**\n   * Expressed as an rgba array, minimal color that could be rendered by a tile.\n   * @default [0, 0, 0, 255]\n   * @deprecated Deprecated in version 5.2.0, use `colorRange` and `colorDomain` instead.\n   */\n  minColor?: Color | null;\n\n  /**\n   * Expressed as an rgba array, maximal color that could be rendered by a tile.\n   * @default [0, 255, 0, 255]\n   * @deprecated Deprecated in version 5.2.0, use `colorRange` and `colorDomain` instead.\n   */\n  maxColor?: Color | null;\n\n  /**\n   * Color scale input domain. The color scale maps continues numeric domain into discrete color range.\n   * @default [1, max(weight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   *\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Method called to retrieve the position of each object.\n   *\n   * @default d => d.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n\n  /**\n   * Perform aggregation is performed on GPU.\n   *\n   * NOTE: GPU Aggregation requires WebGL2 support by the browser.\n   * When `gpuAggregation` is set to true and browser doesn't support WebGL2, aggregation falls back to CPU.\n   *\n   * @default true\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation\n   *\n   * V valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\n   *\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n};\n\n/** Aggregates data into histogram bins and renders them as a grid. */\nexport default class ScreenGridLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends GridAggregationLayer<DataT, ExtraProps & Required<_ScreenGridLayerProps<DataT>>> {\n  static layerName = 'ScreenGridLayer';\n  static defaultProps = defaultProps;\n\n  state!: GridAggregationLayer<DataT>['state'] & {\n    supported: boolean;\n    gpuGridAggregator?: any;\n    gpuAggregation?: any;\n    weights?: any;\n    maxTexture?: Texture2D;\n  };\n\n  initializeState() {\n    const {gl} = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      // max aggregated value is sampled from a float texture\n      this.setState({supported: false});\n      log.error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS,\n      // @ts-expect-error\n      getCellSize: props => props.cellSizePixels // TODO\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {id: `${this.id}-max-texture`})\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true, // aggregation in screen space\n      weights,\n      subLayerData: {attributes: {}},\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n  }\n\n  renderLayers(): LayersList | Layer {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {maxTexture, numRow, numCol, weights} = this.state;\n    const {updateTriggers} = this.props;\n    const {aggregationBuffer} = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers\n      }),\n      {\n        data: {attributes: {instanceCounts: aggregationBuffer}},\n        maxTexture,\n        numInstances: numRow * numCol\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext): void {\n    super.finalizeState(context);\n\n    const {aggregationBuffer, maxBuffer, maxTexture} = this.state;\n\n    aggregationBuffer?.delete();\n    maxBuffer?.delete();\n    maxTexture?.delete();\n  }\n\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    const {index} = info;\n    if (index >= 0) {\n      const {gpuGridAggregator, gpuAggregation, weights} = this.state;\n      // Get count aggregation results\n      const aggregationResults = gpuAggregation\n        ? gpuGridAggregator.getData('count')\n        : weights.count;\n\n      // Each instance (one cell) is aggregated into single pixel,\n      // Get current instance's aggregation details.\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  // Aggregation Overrides\n\n  updateResults({aggregationData, maxData}) {\n    const {count} = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({data: aggregationData});\n    count.maxData = maxData;\n    count.maxTexture.setImageData({data: maxData});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {viewportChanged} = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n\n    const {dimensions} = this.state;\n    const {data, weights} = dimensions;\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      viewportChanged ||\n      this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation\n        dimension: data\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {dimension: weights});\n\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n\n    const {viewport} = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {width, height} = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        // transformation from clipspace to screen(pixel) space\n        scaling: [width / 2, -height / 2, 1],\n\n        gridOffset: {xOffset: cellSize, yOffset: cellSize},\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}