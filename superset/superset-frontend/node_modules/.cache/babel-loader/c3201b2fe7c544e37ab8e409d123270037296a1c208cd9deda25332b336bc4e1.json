{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {\n      fp64,\n      IndexType = Uint32Array\n    } = opts;\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    });\n  }\n\n  get(attributeName) {\n    const {\n      attributes\n    } = this;\n\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n    const externalIndices = this.buffers.indices;\n\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n\n      return normalizedPolygon;\n    }\n\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (isCut(polygon)) {\n      let size = 0;\n\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n\n      return size;\n    }\n\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n\n      this._updatePositions(polygon, context);\n\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  _updateIndices(polygon, {\n    geometryIndex,\n    vertexStart: offset,\n    indexStart\n  }) {\n    const {\n      attributes,\n      indexStarts,\n      typedArrayManager\n    } = this;\n    let target = attributes.indices;\n\n    if (!target || !polygon) {\n      return;\n    }\n\n    let i = indexStart;\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  _updatePositions(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      attributes: {\n        positions\n      },\n      positionSize\n    } = this;\n\n    if (!positions || !polygon) {\n      return;\n    }\n\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      positionSize\n    } = this;\n    const vertexValid = this.attributes.vertexValid;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\nfunction isCut(polygon) {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(PolygonTesselator, \"PolygonTesselator\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js\");reactHotLoader.register(isCut, \"isCut\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["Polygon","Tesselator","cutPolygonByGrid","cutPolygonByMercatorBounds","PolygonTesselator","constructor","opts","fp64","IndexType","Uint32Array","attributes","positions","size","type","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","get","attributeName","subarray","vertexCount","updateGeometry","externalIndices","buffers","value","length","data","getGeometry","Error","normalizeGeometry","polygon","normalize","normalizedPolygon","positionSize","resolution","getPositions","getHoleIndices","gridResolution","edgeTypes","wrapLongitude","maxLatitude","getGeometrySize","isCut","subPolygon","getGeometryFromBuffer","buffer","updateGeometryAttributes","context","geometrySize","vertexStart","indexStart","indexStarts","geometryIndex","_updateIndices","_updatePositions","_updateVertexValid","offset","typedArrayManager","target","i","getSurfaceIndices","preproject","full3d","allocate","copy","j","polygonPositions","x","y","z","holeIndices","set","fill","__reactstandin__regenerateByEval","key","code","eval","Array","isArray","Number","isFinite","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["../../../src/solid-polygon-layer/polygon-tesselator.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\nimport type {\n  PolygonGeometry,\n  NormalizedPolygonGeometry,\n  FlatComplexPolygonGeometry\n} from './polygon';\nimport type {TypedArray} from '@math.gl/core';\n\ntype GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\ntype CutPolygon = FlatComplexPolygonGeometry & {\n  edgeTypes: number[];\n};\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator<\n  PolygonGeometry,\n  NormalizedPolygonGeometry | CutPolygon[],\n  {\n    fp64?: boolean;\n    IndexType?: Uint32ArrayConstructor | Uint16ArrayConstructor;\n    resolution?: number;\n    wrapLongitude?: boolean;\n    preproject?: (xy: number[]) => number[];\n    full3d?: boolean;\n  }\n> {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /** Get attribute by name */\n  get(attributeName: string): TypedArray | null {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /** Override base Tesselator method */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      // @ts-ignore (2339) value is not defined on TypedArray (fall through)\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  /** Implement base Tesselator interface */\n  protected normalizeGeometry(polygon: PolygonGeometry): NormalizedPolygonGeometry | CutPolygon[] {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      return normalizedPolygon;\n    }\n    // normalize is explicitly set to false, assume that user passed in already normalized polygons\n    return polygon as NormalizedPolygonGeometry;\n  }\n\n  /** Implement base Tesselator interface */\n  protected getGeometrySize(polygon: NormalizedPolygonGeometry | CutPolygon[]): number {\n    if (isCut(polygon)) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  /** Override base Tesselator method */\n  protected getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return null;\n  }\n\n  /** Implement base Tesselator interface */\n  protected updateGeometryAttributes(\n    polygon: NormalizedPolygonGeometry | CutPolygon[] | null,\n    context: GeometryUpdateContext\n  ) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  private _updateIndices(\n    polygon: NormalizedPolygonGeometry | null,\n    {geometryIndex, vertexStart: offset, indexStart}: GeometryUpdateContext\n  ) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target || !polygon) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(\n      polygon,\n      this.positionSize,\n      this.opts.preproject,\n      this.opts.full3d\n    );\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  private _updatePositions(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions || !polygon) {\n      return;\n    }\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  private _updateVertexValid(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {positionSize} = this;\n    const vertexValid = this.attributes.vertexValid as TypedArray;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && (polygon as CutPolygon).edgeTypes) {\n      vertexValid.set((polygon as CutPolygon).edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n\nfunction isCut(polygon: NormalizedPolygonGeometry | CutPolygon[]): polygon is CutPolygon[] {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}\n"],"mappings":"uSAyBA,OAAO,KAAKA,OAAZ,MAAyB,WAAzB;AACA,SAAQC,UAAR,QAAyB,eAAzB;AACA,SAAQC,gBAAR,EAA0BC,0BAA1B,QAA2D,kBAA3D;AAsBA,eAAe,MAAMC,iBAAN,SAAgCH,UAAhC,CAWb;EACAI,WAAWA,CAACC,IAAD,EAAO;IAChB,MAAM;MAACC,IAAD;MAAOC,SAAS,GAAGC;IAAnB,IAAkCH,IAAxC;IACA,MAAM,EACJ,GAAGA,IADC;MAEJI,UAAU,EAAE;QACVC,SAAS,EAAE;UAACC,IAAI,EAAE,CAAP;UAAUC,IAAI,EAAEN,IAAI,GAAGO,YAAH,GAAkBC;QAAtC,CADD;QAEVC,WAAW,EAAE;UAACH,IAAI,EAAEI,iBAAP;UAA0BL,IAAI,EAAE;QAAhC,CAFH;QAGVM,OAAO,EAAE;UAACL,IAAI,EAAEL,SAAP;UAAkBI,IAAI,EAAE;QAAxB;MAHC;IAFR,CAAN;EAQD;;EAGDO,GAAGA,CAACC,aAAD,EAA2C;IAC5C,MAAM;MAACV;IAAD,IAAe,IAArB;;IACA,IAAIU,aAAa,KAAK,SAAtB,EAAiC;MAC/B,OAAOV,UAAU,CAACQ,OAAX,IAAsBR,UAAU,CAACQ,OAAX,CAAmBG,QAAnB,CAA4B,CAA5B,EAA+B,KAAKC,WAApC,CAA7B;IACD;;IAED,OAAOZ,UAAU,CAACU,aAAD,CAAjB;EACD;;EAGDG,cAAcA,CAACjB,IAAD,EAAO;IACnB,MAAMiB,cAAN,CAAqBjB,IAArB;IAEA,MAAMkB,eAAe,GAAG,KAAKC,OAAL,CAAaP,OAArC;;IACA,IAAIM,eAAJ,EAAqB;MAEnB,KAAKF,WAAL,GAAmB,CAACE,eAAe,CAACE,KAAhB,IAAyBF,eAA1B,EAA2CG,MAA9D;IACD,CAHD,MAGO,IAAI,KAAKC,IAAL,IAAa,CAAC,KAAKC,WAAvB,EAAoC;MACzC,MAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;IACD;EACF;;EAGSC,iBAAiBA,CAACC,OAAD,EAAqE;IAC9F,IAAI,KAAKC,SAAT,EAAoB;MAClB,MAAMC,iBAAiB,GAAGlC,OAAO,CAACiC,SAAR,CAAkBD,OAAlB,EAA2B,KAAKG,YAAhC,CAA1B;;MACA,IAAI,KAAK7B,IAAL,CAAU8B,UAAd,EAA0B;QACxB,OAAOlC,gBAAgB,CACrBF,OAAO,CAACqC,YAAR,CAAqBH,iBAArB,CADqB,EAErBlC,OAAO,CAACsC,cAAR,CAAuBJ,iBAAvB,CAFqB,EAGrB;UACEtB,IAAI,EAAE,KAAKuB,YADb;UAEEI,cAAc,EAAE,KAAKjC,IAAL,CAAU8B,UAF5B;UAGEI,SAAS,EAAE;QAHb,CAHqB,CAAvB;MASD;;MACD,IAAI,KAAKlC,IAAL,CAAUmC,aAAd,EAA6B;QAC3B,OAAOtC,0BAA0B,CAC/BH,OAAO,CAACqC,YAAR,CAAqBH,iBAArB,CAD+B,EAE/BlC,OAAO,CAACsC,cAAR,CAAuBJ,iBAAvB,CAF+B,EAG/B;UACEtB,IAAI,EAAE,KAAKuB,YADb;UAEEO,WAAW,EAAE,EAFf;UAGEF,SAAS,EAAE;QAHb,CAH+B,CAAjC;MASD;;MACD,OAAON,iBAAP;IACD;;IAED,OAAOF,OAAP;EACD;;EAGSW,eAAeA,CAACX,OAAD,EAA4D;IACnF,IAAIY,KAAK,CAACZ,OAAD,CAAT,EAAoB;MAClB,IAAIpB,IAAI,GAAG,CAAX;;MACA,KAAK,MAAMiC,UAAX,IAAyBb,OAAzB,EAAkC;QAChCpB,IAAI,IAAI,KAAK+B,eAAL,CAAqBE,UAArB,CAAR;MACD;;MACD,OAAOjC,IAAP;IACD;;IACD,OAAOZ,OAAO,CAACqC,YAAR,CAAqBL,OAArB,EAA8BL,MAA9B,GAAuC,KAAKQ,YAAnD;EACD;;EAGSW,qBAAqBA,CAACC,MAAD,EAAS;IACtC,IAAI,KAAKd,SAAL,IAAkB,CAAC,KAAKR,OAAL,CAAaP,OAApC,EAA6C;MAC3C,OAAO,MAAM4B,qBAAN,CAA4BC,MAA5B,CAAP;IACD;;IAED,OAAO,IAAP;EACD;;EAGSC,wBAAwBA,CAChChB,OADgC,EAEhCiB,OAFgC,EAGhC;IACA,IAAIjB,OAAO,IAAIY,KAAK,CAACZ,OAAD,CAApB,EAA+B;MAC7B,KAAK,MAAMa,UAAX,IAAyBb,OAAzB,EAAkC;QAChC,MAAMkB,YAAY,GAAG,KAAKP,eAAL,CAAqBE,UAArB,CAArB;QACAI,OAAO,CAACC,YAAR,GAAuBA,YAAvB;QACA,KAAKF,wBAAL,CAA8BH,UAA9B,EAA0CI,OAA1C;QACAA,OAAO,CAACE,WAAR,IAAuBD,YAAvB;QACAD,OAAO,CAACG,UAAR,GAAqB,KAAKC,WAAL,CAAiBJ,OAAO,CAACK,aAAR,GAAwB,CAAzC,CAArB;MACD;IACF,CARD,MAQO;MACL,KAAKC,cAAL,CAAoBvB,OAApB,EAA6BiB,OAA7B;;MACA,KAAKO,gBAAL,CAAsBxB,OAAtB,EAA+BiB,OAA/B;;MACA,KAAKQ,kBAAL,CAAwBzB,OAAxB,EAAiCiB,OAAjC;IACD;EACF;;EAGOM,cAAcA,CACpBvB,OADoB,EAEpB;IAACsB,aAAD;IAAgBH,WAAW,EAAEO,MAA7B;IAAqCN;EAArC,CAFoB,EAGpB;IACA,MAAM;MAAC1C,UAAD;MAAa2C,WAAb;MAA0BM;IAA1B,IAA+C,IAArD;IAEA,IAAIC,MAAM,GAAGlD,UAAU,CAACQ,OAAxB;;IACA,IAAI,CAAC0C,MAAD,IAAW,CAAC5B,OAAhB,EAAyB;MACvB;IACD;;IACD,IAAI6B,CAAC,GAAGT,UAAR;IAGA,MAAMlC,OAAO,GAAGlB,OAAO,CAAC8D,iBAAR,CACd9B,OADc,EAEd,KAAKG,YAFS,EAGd,KAAK7B,IAAL,CAAUyD,UAHI,EAId,KAAKzD,IAAL,CAAU0D,MAJI,CAAhB;IAQAJ,MAAM,GAAGD,iBAAiB,CAACM,QAAlB,CAA2BL,MAA3B,EAAmCR,UAAU,GAAGlC,OAAO,CAACS,MAAxD,EAAgE;MACvEuC,IAAI,EAAE;IADiE,CAAhE,CAAT;;IAKA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjD,OAAO,CAACS,MAA5B,EAAoCwC,CAAC,EAArC,EAAyC;MACvCP,MAAM,CAACC,CAAC,EAAF,CAAN,GAAc3C,OAAO,CAACiD,CAAD,CAAP,GAAaT,MAA3B;IACD;;IAEDL,WAAW,CAACC,aAAa,GAAG,CAAjB,CAAX,GAAiCF,UAAU,GAAGlC,OAAO,CAACS,MAAtD;IACAjB,UAAU,CAACQ,OAAX,GAAqB0C,MAArB;EACD;;EAGOJ,gBAAgBA,CACtBxB,OADsB,EAEtB;IAACmB,WAAD;IAAcD;EAAd,CAFsB,EAGtB;IACA,MAAM;MACJxC,UAAU,EAAE;QAACC;MAAD,CADR;MAEJwB;IAFI,IAGF,IAHJ;;IAIA,IAAI,CAACxB,SAAD,IAAc,CAACqB,OAAnB,EAA4B;MAC1B;IACD;;IACD,MAAMoC,gBAAgB,GAAGpE,OAAO,CAACqC,YAAR,CAAqBL,OAArB,CAAzB;;IAEA,KAAK,IAAI6B,CAAC,GAAGV,WAAR,EAAqBgB,CAAC,GAAG,CAA9B,EAAiCA,CAAC,GAAGjB,YAArC,EAAmDW,CAAC,IAAIM,CAAC,EAAzD,EAA6D;MAC3D,MAAME,CAAC,GAAGD,gBAAgB,CAACD,CAAC,GAAGhC,YAAL,CAA1B;MACA,MAAMmC,CAAC,GAAGF,gBAAgB,CAACD,CAAC,GAAGhC,YAAJ,GAAmB,CAApB,CAA1B;MACA,MAAMoC,CAAC,GAAGpC,YAAY,GAAG,CAAf,GAAmBiC,gBAAgB,CAACD,CAAC,GAAGhC,YAAJ,GAAmB,CAApB,CAAnC,GAA4D,CAAtE;MAEAxB,SAAS,CAACkD,CAAC,GAAG,CAAL,CAAT,GAAmBQ,CAAnB;MACA1D,SAAS,CAACkD,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAT,GAAuBS,CAAvB;MACA3D,SAAS,CAACkD,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAT,GAAuBU,CAAvB;IACD;EACF;;EAEOd,kBAAkBA,CACxBzB,OADwB,EAExB;IAACmB,WAAD;IAAcD;EAAd,CAFwB,EAGxB;IACA,MAAM;MAACf;IAAD,IAAiB,IAAvB;IACA,MAAMnB,WAAW,GAAG,KAAKN,UAAL,CAAgBM,WAApC;IACA,MAAMwD,WAAW,GAAGxC,OAAO,IAAIhC,OAAO,CAACsC,cAAR,CAAuBN,OAAvB,CAA/B;;IAUA,IAAIA,OAAO,IAAKA,OAAD,CAAwBQ,SAAvC,EAAkD;MAChDxB,WAAW,CAACyD,GAAZ,CAAiBzC,OAAD,CAAwBQ,SAAxC,EAAmDW,WAAnD;IACD,CAFD,MAEO;MACLnC,WAAW,CAAC0D,IAAZ,CAAiB,CAAjB,EAAoBvB,WAApB,EAAiCA,WAAW,GAAGD,YAA/C;IACD;;IACD,IAAIsB,WAAJ,EAAiB;MACf,KAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGK,WAAW,CAAC7C,MAAhC,EAAwCwC,CAAC,EAAzC,EAA6C;QAC3CnD,WAAW,CAACmC,WAAW,GAAGqB,WAAW,CAACL,CAAD,CAAX,GAAiBhC,YAA/B,GAA8C,CAA/C,CAAX,GAA+D,CAA/D;MACD;IACF;;IACDnB,WAAW,CAACmC,WAAW,GAAGD,YAAd,GAA6B,CAA9B,CAAX,GAA8C,CAA9C;EACD;EAAAyB,iCAAAC,GAAA,EAAAC,IAAA;IAAA,KAAAD,GAAA,IAAAE,IAAA,CAAAD,IAAA,GApMD;;AAuMF,SAASjC,KAATA,CAAeZ,OAAf,EAA2F;EACzF,OAAO+C,KAAK,CAACC,OAAN,CAAchD,OAAd,KAA0BA,OAAO,CAACL,MAAR,GAAiB,CAA3C,IAAgD,CAACsD,MAAM,CAACC,QAAP,CAAgBlD,OAAO,CAAC,CAAD,CAAvB,CAAxD;AACD,oBAAAmD,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAC,SAAA,MAAAH,cAAA,WAAAA,cAAA,CAAAI,QAAA,CApNoBnF,iBAAN,oMAAA+E,cAAA,CAAAI,QAAA,CAkNN3C,KAAT,gNAAA4C,WAAA,UAAAJ,oBAAA,mBAAAA,oBAAA,CAAAI,WAAA,GAAAF,SAAA,CAAAE,WAAA,IAAAA,WAAA,CAAAC,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}