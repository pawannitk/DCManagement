{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { log, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { ClipExtension } from '@deck.gl/extensions';\nimport { Matrix4 } from '@math.gl/core';\nimport { MVTWorkerLoader } from '@loaders.gl/mvt';\nimport { binaryToGeojson } from '@loaders.gl/gis';\nimport { transform } from './coordinate-transform';\nimport findIndexBinary from './find-index-binary';\nimport TileLayer from '../tile-layer/tile-layer';\nimport { urlType, getURLFromTemplate, isGeoBoundingBox, isURLTemplate } from '../tileset-2d';\nconst WORLD_SIZE = 512;\nconst defaultProps = { ...GeoJsonLayer.defaultProps,\n  data: urlType,\n  onDataLoad: {\n    type: 'function',\n    value: null,\n    optional: true,\n    compare: false\n  },\n  uniqueIdProperty: '',\n  highlightedFeatureId: null,\n  loaders: [MVTWorkerLoader],\n  binary: true\n};\nexport default class MVTLayer extends TileLayer {\n  initializeState() {\n    super.initializeState();\n    const binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;\n    this.setState({\n      binary,\n      data: null,\n      tileJSON: null\n    });\n  }\n\n  get isLoaded() {\n    return this.state && this.state.data && this.state.tileset && super.isLoaded;\n  }\n\n  updateState({\n    props,\n    oldProps,\n    context,\n    changeFlags\n  }) {\n    var _this$state;\n\n    if (changeFlags.dataChanged) {\n      this._updateTileData();\n    }\n\n    if ((_this$state = this.state) !== null && _this$state !== void 0 && _this$state.data) {\n      super.updateState({\n        props,\n        oldProps,\n        context,\n        changeFlags\n      });\n\n      this._setWGS84PropertyForTiles();\n    }\n\n    const {\n      highlightColor\n    } = props;\n\n    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {\n      this.setState({\n        highlightColor\n      });\n    }\n  }\n\n  async _updateTileData() {\n    let data = this.props.data;\n    let tileJSON = null;\n\n    if (typeof data === 'string' && !isURLTemplate(data)) {\n      const {\n        onDataLoad,\n        fetch\n      } = this.props;\n      this.setState({\n        data: null,\n        tileJSON: null\n      });\n\n      try {\n        tileJSON = await fetch(data, {\n          propName: 'data',\n          layer: this,\n          loaders: []\n        });\n      } catch (error) {\n        this.raiseError(error, 'loading TileJSON');\n        data = null;\n      }\n\n      if (onDataLoad) {\n        onDataLoad(tileJSON, {\n          propName: 'data',\n          layer: this\n        });\n      }\n    } else if (data.tilejson) {\n      tileJSON = data;\n    }\n\n    if (tileJSON) {\n      data = tileJSON.tiles;\n    }\n\n    this.setState({\n      data,\n      tileJSON\n    });\n  }\n\n  _getTilesetOptions() {\n    const opts = super._getTilesetOptions();\n\n    const tileJSON = this.state.tileJSON;\n    const {\n      minZoom,\n      maxZoom\n    } = this.props;\n\n    if (tileJSON) {\n      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {\n        opts.minZoom = tileJSON.minzoom;\n      }\n\n      if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {\n        opts.maxZoom = tileJSON.maxzoom;\n      }\n    }\n\n    return opts;\n  }\n\n  renderLayers() {\n    var _this$state2;\n\n    if (!((_this$state2 = this.state) !== null && _this$state2 !== void 0 && _this$state2.data)) return null;\n    return super.renderLayers();\n  }\n\n  getTileData(loadProps) {\n    var _loadOptions;\n\n    const {\n      data,\n      binary\n    } = this.state;\n    const {\n      index,\n      signal\n    } = loadProps;\n    const url = getURLFromTemplate(data, loadProps);\n\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n\n    let loadOptions = this.getLoadOptions();\n    const {\n      fetch\n    } = this.props;\n    loadOptions = { ...loadOptions,\n      mimeType: 'application/x-protobuf',\n      mvt: { ...((_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.mvt),\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: index\n      },\n      gis: binary ? {\n        format: 'binary'\n      } : {}\n    };\n    return fetch(url, {\n      propName: 'data',\n      layer: this,\n      loadOptions,\n      signal\n    });\n  }\n\n  renderSubLayers(props) {\n    const {\n      x,\n      y,\n      z\n    } = props.tile.index;\n    const worldScale = Math.pow(2, z);\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n    const xOffset = WORLD_SIZE * x / worldScale;\n    const yOffset = WORLD_SIZE * (1 - y / worldScale);\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n    props.autoHighlight = false;\n\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n\n    const subLayers = super.renderSubLayers(props);\n\n    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {\n      log.warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();\n    }\n\n    return subLayers;\n  }\n\n  _updateAutoHighlight(info) {\n    const {\n      uniqueIdProperty\n    } = this.props;\n    const {\n      hoveredFeatureId,\n      hoveredFeatureLayerName\n    } = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId;\n    let newHoveredFeatureLayerName;\n\n    if (hoveredFeature) {\n      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);\n    }\n\n    let {\n      highlightColor\n    } = this.props;\n\n    if (typeof highlightColor === 'function') {\n      highlightColor = highlightColor(info);\n    }\n\n    if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId,\n        hoveredFeatureLayerName: newHoveredFeatureLayerName\n      });\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const isWGS84 = Boolean(this.context.viewport.resolution);\n\n    if (this.state.binary && info.index !== -1) {\n      const {\n        data\n      } = params.sourceLayer.props;\n      info.object = binaryToGeojson(data, {\n        globalFeatureId: info.index\n      });\n    }\n\n    if (info.object && !isWGS84) {\n      info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);\n    }\n\n    return info;\n  }\n\n  getSubLayerPropsByTile(tile) {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n\n  getHighlightedObjectIndex(tile) {\n    const {\n      hoveredFeatureId,\n      hoveredFeatureLayerName,\n      binary\n    } = this.state;\n    const {\n      uniqueIdProperty,\n      highlightedFeatureId\n    } = this.props;\n    const data = tile.content;\n    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;\n\n    if (!isFeatureIdPresent) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;\n\n    if (Array.isArray(data)) {\n      return data.findIndex((feature) => {\n        const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n        const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;\n        return isMatchingId && isMatchingLayer;\n      });\n    } else if (data && binary) {\n      return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? '' : hoveredFeatureLayerName);\n    }\n\n    return -1;\n  }\n\n  _pickObjects(maxObjects) {\n    const {\n      deck,\n      viewport\n    } = this.context;\n    const width = viewport.width;\n    const height = viewport.height;\n    const x = viewport.x;\n    const y = viewport.y;\n    const layerIds = [this.id];\n    return deck.pickObjects({\n      x,\n      y,\n      width,\n      height,\n      layerIds,\n      maxObjects\n    });\n  }\n\n  getRenderedFeatures(maxFeatures = null) {\n    const features = this._pickObjects(maxFeatures);\n\n    const featureCache = new Set();\n    const renderedFeatures = [];\n\n    for (const f of features) {\n      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n\n      if (featureId === undefined) {\n        renderedFeatures.push(f.object);\n      } else if (!featureCache.has(featureId)) {\n        featureCache.add(featureId);\n        renderedFeatures.push(f.object);\n      }\n    }\n\n    return renderedFeatures;\n  }\n\n  _setWGS84PropertyForTiles() {\n    const propName = 'dataInWGS84';\n    const tileset = this.state.tileset;\n    tileset.selectedTiles.forEach((tile) => {\n      if (!tile.hasOwnProperty(propName)) {\n        Object.defineProperty(tile, propName, {\n          get: () => {\n            if (!tile.content) {\n              return null;\n            }\n\n            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {\n              return [];\n            }\n\n            const {\n              bbox\n            } = tile;\n\n            if (tile._contentWGS84 === undefined && isGeoBoundingBox(bbox)) {\n              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;\n              tile._contentWGS84 = content.map((feature) => transformTileCoordsToWGS84(feature, bbox, this.context.viewport));\n            }\n\n            return tile._contentWGS84;\n          }\n        });\n      }\n    });\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\n_defineProperty(MVTLayer, \"layerName\", 'MVTLayer');\n\n_defineProperty(MVTLayer, \"defaultProps\", defaultProps);\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (feature.properties && uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return undefined;\n}\n\nfunction getFeatureLayerName(feature) {\n  var _feature$properties;\n\n  return ((_feature$properties = feature.properties) === null || _feature$properties === void 0 ? void 0 : _feature$properties.layerName) || null;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nfunction transformTileCoordsToWGS84(object, bbox, viewport) {\n  const feature = { ...object,\n    geometry: {\n      type: object.geometry.type\n    }\n  };\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: () => {\n      const wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n  return feature;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(WORLD_SIZE, \"WORLD_SIZE\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js\");reactHotLoader.register(defaultProps, \"defaultProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js\");reactHotLoader.register(MVTLayer, \"MVTLayer\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js\");reactHotLoader.register(getFeatureUniqueId, \"getFeatureUniqueId\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js\");reactHotLoader.register(getFeatureLayerName, \"getFeatureLayerName\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js\");reactHotLoader.register(isFeatureIdDefined, \"isFeatureIdDefined\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js\");reactHotLoader.register(transformTileCoordsToWGS84, \"transformTileCoordsToWGS84\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["log","COORDINATE_SYSTEM","GeoJsonLayer","ClipExtension","Matrix4","MVTWorkerLoader","binaryToGeojson","transform","findIndexBinary","TileLayer","urlType","getURLFromTemplate","isGeoBoundingBox","isURLTemplate","WORLD_SIZE","defaultProps","data","onDataLoad","type","value","optional","compare","uniqueIdProperty","highlightedFeatureId","loaders","binary","MVTLayer","initializeState","context","viewport","resolution","undefined","props","setState","tileJSON","isLoaded","state","tileset","updateState","oldProps","changeFlags","_this$state","dataChanged","_updateTileData","_setWGS84PropertyForTiles","highlightColor","Array","isArray","fetch","propName","layer","error","raiseError","tilejson","tiles","_getTilesetOptions","opts","minZoom","maxZoom","Number","isFinite","minzoom","maxzoom","renderLayers","_this$state2","getTileData","loadProps","_loadOptions","index","signal","url","Promise","reject","loadOptions","getLoadOptions","mimeType","mvt","coordinates","tileIndex","gis","format","renderSubLayers","x","y","z","tile","worldScale","Math","pow","xScale","yScale","xOffset","yOffset","modelMatrix","scale","autoHighlight","coordinateOrigin","coordinateSystem","CARTESIAN","extensions","subLayers","warn","_updateAutoHighlight","info","hoveredFeatureId","hoveredFeatureLayerName","hoveredFeature","object","newHoveredFeatureId","newHoveredFeatureLayerName","getFeatureUniqueId","getFeatureLayerName","getPickingInfo","params","isWGS84","Boolean","sourceLayer","globalFeatureId","transformTileCoordsToWGS84","bbox","getSubLayerPropsByTile","highlightedObjectIndex","getHighlightedObjectIndex","content","isHighlighted","isFeatureIdDefined","isFeatureIdPresent","featureIdToHighlight","findIndex","feature","isMatchingId","isMatchingLayer","_pickObjects","maxObjects","deck","width","height","layerIds","id","pickObjects","getRenderedFeatures","maxFeatures","features","featureCache","Set","renderedFeatures","f","featureId","push","has","add","selectedTiles","forEach","hasOwnProperty","Object","defineProperty","get","length","_contentWGS84","map","__reactstandin__regenerateByEval","key","code","eval","properties","_feature$properties","layerName","geometry","wgs84Geom","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["../../../src/mvt-layer/mvt-layer.ts"],"sourcesContent":["import {\n  Layer,\n  LayersList,\n  log,\n  PickingInfo,\n  UpdateParameters,\n  GetPickingInfoParams,\n  Viewport,\n  COORDINATE_SYSTEM,\n  DefaultProps\n} from '@deck.gl/core';\nimport {GeoJsonLayer, GeoJsonLayerProps} from '@deck.gl/layers';\nimport {ClipExtension} from '@deck.gl/extensions';\n\nimport {Matrix4} from '@math.gl/core';\nimport {MVTWorkerLoader} from '@loaders.gl/mvt';\nimport {binaryToGeojson} from '@loaders.gl/gis';\n\nimport type {Loader} from '@loaders.gl/loader-utils';\nimport type {BinaryFeatures} from '@loaders.gl/schema';\nimport type {Feature} from 'geojson';\n\nimport {transform} from './coordinate-transform';\nimport findIndexBinary from './find-index-binary';\n\nimport TileLayer, {TiledPickingInfo, TileLayerProps} from '../tile-layer/tile-layer';\n\nimport type {Tileset2DProps, TileLoadProps, GeoBoundingBox} from '../tileset-2d';\nimport {\n  urlType,\n  Tileset2D,\n  Tile2DHeader,\n  getURLFromTemplate,\n  isGeoBoundingBox,\n  isURLTemplate\n} from '../tileset-2d';\n\nconst WORLD_SIZE = 512;\n\nconst defaultProps: DefaultProps<MVTLayerProps> = {\n  ...GeoJsonLayer.defaultProps,\n  data: urlType,\n  onDataLoad: {type: 'function', value: null, optional: true, compare: false},\n  uniqueIdProperty: '',\n  highlightedFeatureId: null,\n  loaders: [MVTWorkerLoader],\n  binary: true\n};\n\nexport type TileJson = {\n  tilejson: string;\n  tiles: string[];\n  // eslint-disable-next-line camelcase\n  vector_layers: any[];\n  attribution?: string;\n  scheme?: string;\n  maxzoom?: number;\n  minzoom?: number;\n  version?: string;\n};\n\ntype ParsedMvtTile = Feature[] | BinaryFeatures;\n\n/** All props supported by the MVTLayer */\nexport type MVTLayerProps = _MVTLayerProps &\n  Omit<GeoJsonLayerProps, 'data'> &\n  TileLayerProps<ParsedMvtTile>;\n\n/** Props added by the MVTLayer  */\nexport type _MVTLayerProps = {\n  /** Called if `data` is a TileJSON URL when it is successfully fetched. */\n  onDataLoad?: ((tilejson: TileJson | null) => void) | null;\n\n  /** Needed for highlighting a feature split across two or more tiles. */\n  uniqueIdProperty?: string;\n\n  /** A feature with ID corresponding to the supplied value will be highlighted. */\n  highlightedFeatureId?: string | number | null;\n\n  /**\n   * Use tile data in binary format.\n   *\n   * @default true\n   */\n  binary?: boolean;\n\n  /**\n   * Loaders used to transform tiles into `data` property passed to `renderSubLayers`.\n   *\n   * @default [MVTWorkerLoader] from `@loaders.gl/mvt`\n   */\n  loaders?: Loader[];\n};\n\ntype ContentWGS84Cache = {_contentWGS84?: Feature[]};\n\n/** Render data formatted as [Mapbox Vector Tiles](https://docs.mapbox.com/vector-tiles/specification/). */\nexport default class MVTLayer<ExtraProps extends {} = {}> extends TileLayer<\n  ParsedMvtTile,\n  Required<_MVTLayerProps> & ExtraProps\n> {\n  static layerName = 'MVTLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    super.initializeState();\n    // GlobeView doesn't work well with binary data\n    const binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;\n    this.setState({\n      binary,\n      data: null,\n      tileJSON: null\n    });\n  }\n\n  get isLoaded(): boolean {\n    return this.state && this.state.data && this.state.tileset && super.isLoaded;\n  }\n\n  updateState({props, oldProps, context, changeFlags}: UpdateParameters<this>) {\n    if (changeFlags.dataChanged) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._updateTileData();\n    }\n\n    if (this.state?.data) {\n      super.updateState({props, oldProps, context, changeFlags});\n      this._setWGS84PropertyForTiles();\n    }\n    const {highlightColor} = props;\n    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {\n      this.setState({highlightColor});\n    }\n  }\n\n  /* eslint-disable complexity */\n  private async _updateTileData(): Promise<void> {\n    let data: any = this.props.data;\n    let tileJSON: any = null;\n\n    if (typeof data === 'string' && !isURLTemplate(data)) {\n      const {onDataLoad, fetch} = this.props;\n      this.setState({data: null, tileJSON: null});\n      try {\n        tileJSON = await fetch(data, {propName: 'data', layer: this, loaders: []});\n      } catch (error: any) {\n        this.raiseError(error, 'loading TileJSON');\n        data = null;\n      }\n\n      if (onDataLoad) {\n        onDataLoad(tileJSON, {propName: 'data', layer: this});\n      }\n    } else if (data.tilejson) {\n      tileJSON = data;\n    }\n\n    if (tileJSON) {\n      data = tileJSON.tiles;\n    }\n\n    this.setState({data, tileJSON});\n  }\n\n  _getTilesetOptions(): Tileset2DProps {\n    const opts = super._getTilesetOptions();\n    const tileJSON: TileJson | null | undefined = this.state.tileJSON;\n    const {minZoom, maxZoom} = this.props;\n\n    if (tileJSON) {\n      if (Number.isFinite(tileJSON.minzoom) && (tileJSON.minzoom as number) > (minZoom as number)) {\n        opts.minZoom = tileJSON.minzoom as number;\n      }\n\n      if (\n        Number.isFinite(tileJSON.maxzoom) &&\n        (!Number.isFinite(maxZoom) || (tileJSON.maxzoom as number) < (maxZoom as number))\n      ) {\n        opts.maxZoom = tileJSON.maxzoom as number;\n      }\n    }\n    return opts;\n  }\n\n  /* eslint-disable complexity */\n\n  renderLayers(): Layer | null | LayersList {\n    if (!this.state?.data) return null;\n    return super.renderLayers();\n  }\n\n  getTileData(loadProps: TileLoadProps): Promise<ParsedMvtTile> {\n    const {data, binary} = this.state;\n    const {index, signal} = loadProps;\n\n    const url = getURLFromTemplate(data, loadProps);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    let loadOptions = this.getLoadOptions();\n    const {fetch} = this.props;\n    loadOptions = {\n      ...loadOptions,\n      mimeType: 'application/x-protobuf',\n      mvt: {\n        ...loadOptions?.mvt,\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: index\n        // Local worker debug\n        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`\n        // Set worker to null to skip web workers\n        // workerUrl: null\n      },\n      gis: binary ? {format: 'binary'} : {}\n    };\n    return fetch(url, {propName: 'data', layer: this, loadOptions, signal});\n  }\n\n  renderSubLayers(\n    props: TileLayer['props'] & {\n      id: string;\n      data: ParsedMvtTile;\n      _offset: number;\n      tile: Tile2DHeader<ParsedMvtTile>;\n    }\n  ): Layer | null | LayersList {\n    const {x, y, z} = props.tile.index;\n    const worldScale = Math.pow(2, z);\n\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n\n    const xOffset = (WORLD_SIZE * x) / worldScale;\n    const yOffset = WORLD_SIZE * (1 - y / worldScale);\n\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n\n    props.autoHighlight = false;\n\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n\n    const subLayers = super.renderSubLayers(props);\n\n    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {\n      log.warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();\n    }\n\n    return subLayers;\n  }\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    const {uniqueIdProperty} = this.props;\n\n    const {hoveredFeatureId, hoveredFeatureLayerName} = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId;\n    let newHoveredFeatureLayerName;\n\n    if (hoveredFeature) {\n      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);\n    }\n    let {highlightColor} = this.props;\n    if (typeof highlightColor === 'function') {\n      highlightColor = highlightColor(info);\n    }\n\n    if (\n      hoveredFeatureId !== newHoveredFeatureId ||\n      hoveredFeatureLayerName !== newHoveredFeatureLayerName\n    ) {\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId,\n        hoveredFeatureLayerName: newHoveredFeatureLayerName\n      });\n    }\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): TiledPickingInfo {\n    const info = super.getPickingInfo(params);\n\n    const isWGS84 = Boolean(this.context.viewport.resolution);\n\n    if (this.state.binary && info.index !== -1) {\n      const {data} = params.sourceLayer!.props;\n      info.object = binaryToGeojson(data as BinaryFeatures, {\n        globalFeatureId: info.index\n      }) as Feature;\n    }\n    if (info.object && !isWGS84) {\n      info.object = transformTileCoordsToWGS84(\n        info.object,\n        info.tile!.bbox as GeoBoundingBox, // eslint-disable-line\n        this.context.viewport\n      );\n    }\n\n    return info;\n  }\n\n  getSubLayerPropsByTile(tile: Tile2DHeader<ParsedMvtTile>): Record<string, any> {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n\n  private getHighlightedObjectIndex(tile: Tile2DHeader<ParsedMvtTile>): number {\n    const {hoveredFeatureId, hoveredFeatureLayerName, binary} = this.state;\n    const {uniqueIdProperty, highlightedFeatureId} = this.props;\n    const data = tile.content;\n\n    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;\n\n    if (!isFeatureIdPresent) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;\n\n    // Iterable data\n    if (Array.isArray(data)) {\n      return data.findIndex(feature => {\n        const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n        const isMatchingLayer =\n          isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;\n        return isMatchingId && isMatchingLayer;\n      });\n\n      // Non-iterable data\n    } else if (data && binary) {\n      // Get the feature index of the selected item to highlight\n      return findIndexBinary(\n        data,\n        uniqueIdProperty,\n        featureIdToHighlight,\n        isHighlighted ? '' : hoveredFeatureLayerName\n      );\n    }\n\n    return -1;\n  }\n\n  private _pickObjects(maxObjects: number | null): PickingInfo[] {\n    const {deck, viewport} = this.context;\n    const width = viewport.width;\n    const height = viewport.height;\n    const x = viewport.x;\n    const y = viewport.y;\n    const layerIds = [this.id];\n    return deck!.pickObjects({x, y, width, height, layerIds, maxObjects});\n  }\n\n  /** Get the rendered features in the current viewport. */\n  getRenderedFeatures(maxFeatures: number | null = null): Feature[] {\n    const features = this._pickObjects(maxFeatures);\n    const featureCache = new Set();\n    const renderedFeatures: Feature[] = [];\n\n    for (const f of features) {\n      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n\n      if (featureId === undefined) {\n        // we have no id for the feature, we just add to the list\n        renderedFeatures.push(f.object as Feature);\n      } else if (!featureCache.has(featureId)) {\n        // Add removing duplicates\n        featureCache.add(featureId);\n        renderedFeatures.push(f.object as Feature);\n      }\n    }\n\n    return renderedFeatures;\n  }\n\n  private _setWGS84PropertyForTiles(): void {\n    const propName = 'dataInWGS84';\n    const tileset: Tileset2D = this.state.tileset;\n\n    // @ts-expect-error selectedTiles are always initialized when tile is being processed\n    tileset.selectedTiles.forEach((tile: Tile2DHeader & ContentWGS84Cache) => {\n      if (!tile.hasOwnProperty(propName)) {\n        // eslint-disable-next-line accessor-pairs\n        Object.defineProperty(tile, propName, {\n          get: () => {\n            // Still loading or encountered an error\n            if (!tile.content) {\n              return null;\n            }\n\n            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {\n              // TODO: @loaders.gl/mvt returns [] when no content. It should return a valid empty binary.\n              // https://github.com/visgl/loaders.gl/pull/1137\n              return [];\n            }\n\n            const {bbox} = tile;\n            if (tile._contentWGS84 === undefined && isGeoBoundingBox(bbox)) {\n              // Create a cache to transform only once\n\n              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;\n              tile._contentWGS84 = content.map(feature =>\n                transformTileCoordsToWGS84(feature, bbox, this.context.viewport)\n              );\n            }\n            return tile._contentWGS84;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getFeatureUniqueId(feature: Feature, uniqueIdProperty: string | undefined) {\n  if (feature.properties && uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return undefined;\n}\n\nfunction getFeatureLayerName(feature: Feature): string | null {\n  return feature.properties?.layerName || null;\n}\n\nfunction isFeatureIdDefined(value: unknown): boolean {\n  return value !== undefined && value !== null && value !== '';\n}\n\nfunction transformTileCoordsToWGS84(\n  object: Feature,\n  bbox: GeoBoundingBox,\n  viewport: Viewport\n): Feature {\n  const feature = {\n    ...object,\n    geometry: {\n      type: object.geometry.type\n    }\n  };\n\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: () => {\n      const wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n\n  return feature as Feature;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}