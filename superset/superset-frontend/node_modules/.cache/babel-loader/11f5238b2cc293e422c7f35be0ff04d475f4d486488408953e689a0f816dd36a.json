{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION } from '../utils/aggregation-operation-utils';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport { pointToDensityGridDataCPU } from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: (x) => x.position\n  },\n  extruded: false,\n  material: true\n};\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nexport default class GPUGridLayer extends GridAggregationLayer {\n  initializeState({\n    gl\n  }) {\n    const isSupported = GPUGridAggregator.isSupported(gl);\n\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false,\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      color: {\n        size: 3,\n        accessor: 'getColorWeight'\n      },\n      elevation: {\n        size: 3,\n        accessor: 'getElevationWeight'\n      }\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      return;\n    }\n\n    super.updateState(opts);\n    const {\n      aggregationDirty\n    } = this.state;\n\n    if (aggregationDirty) {\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);\n    const lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);\n    return \"\".concat(latIdx, \"-\").concat(lonIdx);\n  }\n\n  getPositionForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({\n    info,\n    mode\n  }) {\n    const {\n      index\n    } = info;\n    let object = null;\n\n    if (index >= 0) {\n      const {\n        gpuGridAggregator\n      } = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n\n      if (mode !== 'hover') {\n        const {\n          props\n        } = this;\n        let {\n          gridHash\n        } = this.state;\n\n        if (!gridHash) {\n          const {\n            gridOffset,\n            translation,\n            boundingBox\n          } = this.state;\n          const {\n            viewport\n          } = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({\n            gridHash\n          });\n        }\n\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    info.picked = Boolean(object);\n    info.object = object;\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const {\n      weights,\n      numRow,\n      numCol,\n      gridOrigin,\n      gridOffset\n    } = this.state;\n    const {\n      color,\n      elevation\n    } = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n    return new SubLayerClass({\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n      colorRange,\n      elevationRange,\n      colorDomain,\n      elevationDomain,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationScale,\n      extruded\n    }, this.getSubLayerProps({\n      id: 'gpu-grid-cell'\n    }), {\n      data: {\n        attributes: {\n          colors: color.aggregationBuffer,\n          elevations: elevation.aggregationBuffer\n        }\n      },\n      colorMaxMinBuffer: color.maxMinBuffer,\n      elevationMaxMinBuffer: elevation.maxMinBuffer,\n      numInstances: numCol * numRow\n    });\n  }\n\n  finalizeState(context) {\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    [color, elevation].forEach((weight) => {\n      const {\n        aggregationBuffer,\n        maxMinBuffer\n      } = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    });\n    super.finalizeState(context);\n  }\n\n  updateAggregationState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const {\n      cellSize,\n      coordinateSystem\n    } = props;\n    const {\n      viewport\n    } = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {\n      dimensions\n    } = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n    let {\n      boundingBox\n    } = this.state;\n\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({\n        boundingBox\n      });\n    }\n\n    if (positionsChanged || cellSizeChanged) {\n      const {\n        gridOffset,\n        translation,\n        width,\n        height,\n        numCol,\n        numRow\n      } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {\n      dimension: dimensions.data,\n      compareAll: true\n    });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  _updateAccessors(opts) {\n    const {\n      colorAggregation,\n      elevationAggregation\n    } = opts.props;\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\n_defineProperty(GPUGridLayer, \"layerName\", 'GPUGridLayer');\n\n_defineProperty(GPUGridLayer, \"defaultProps\", defaultProps);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(defaultProps, \"defaultProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/gpu-grid-layer/gpu-grid-layer.js\");reactHotLoader.register(DIMENSIONS, \"DIMENSIONS\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/gpu-grid-layer/gpu-grid-layer.js\");reactHotLoader.register(POSITION_ATTRIBUTE_NAME, \"POSITION_ATTRIBUTE_NAME\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/gpu-grid-layer/gpu-grid-layer.js\");reactHotLoader.register(GPUGridLayer, \"GPUGridLayer\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/gpu-grid-layer/gpu-grid-layer.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["Buffer","log","GPUGridAggregator","AGGREGATION_OPERATION","defaultColorRange","colorRangeToFlatArray","GPUGridCellLayer","pointToDensityGridDataCPU","GridAggregationLayer","getBoundingBox","getGridParams","defaultProps","colorDomain","colorRange","getColorWeight","type","value","colorAggregation","elevationDomain","elevationRange","getElevationWeight","elevationAggregation","elevationScale","min","cellSize","max","coverage","getPosition","x","position","extruded","material","DIMENSIONS","data","props","POSITION_ATTRIBUTE_NAME","GPUGridLayer","initializeState","gl","isSupported","error","initializeAggregationLayer","dimensions","setState","gpuAggregation","projectPoints","weights","color","needMin","needMax","combineMaxMin","maxMinBuffer","byteLength","accessor","size","divisor","elevation","positionAttributeName","attributeManager","getAttributeManager","add","fp64","use64bitPositions","updateState","opts","state","aggregationDirty","gridHash","getHashKeyForIndex","index","numRow","numCol","boundingBox","gridOffset","gridSize","gridOrigin","xMin","yMin","xOffset","yOffset","yIndex","Math","floor","xIndex","latIdx","lonIdx","concat","getPositionForIndex","yPos","xPos","getPickingInfo","info","mode","object","gpuGridAggregator","colorInfo","getAggregationData","pixelIndex","getData","elevationInfo","colorValue","cellWeight","elevationValue","count","cellCount","totalCount","translation","viewport","context","attributes","getAttributes","cpuAggregation","key","cpuAggregationData","Object","assign","picked","Boolean","renderLayers","cellSizeMeters","SubLayerClass","getSubLayerClass","getSubLayerProps","id","colors","aggregationBuffer","elevations","colorMaxMinBuffer","elevationMaxMinBuffer","numInstances","finalizeState","forEach","weight","delete","updateAggregationState","oldProps","coordinateSystem","cellSizeChanged","positionsChanged","isAttributeChanged","attributesChanged","getNumInstances","width","height","allocateResources","aggregationDataDirty","isAggregationDirty","dimension","compareAll","_updateAccessors","operation","__reactstandin__regenerateByEval","code","eval","reactHotLoader","register","leaveModule","reactHotLoaderGlobal","undefined","module"],"sources":["../../../src/gpu-grid-layer/gpu-grid-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Buffer} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  Material,\n  GetPickingInfoParams,\n  LayerContext,\n  log,\n  PickingInfo,\n  Position,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION} from '../utils/aggregation-operation-utils';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport {pointToDensityGridDataCPU} from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\n\nconst defaultProps: DefaultProps<GPUGridLayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: x => x.position},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n// This layer only perform GPU aggregation, no need to seperate data and weight props\n// aggregation will be dirty when any of the props are changed.\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n  // rest of the changes are detected by `state.attributesChanged`\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\n/** All properties supported by GPUGridLayer. */\nexport type GPUGridLayerProps<DataT = any> = _GPUGridLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by GPUGridLayer. */\nexport type _GPUGridLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * @default 'SUM'\n   */\n  colorAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * @default 'SUM'\n   */\n  elevationAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n};\n\n/** Aggregate data into a grid-based heatmap. Aggregation is performed on GPU (WebGL2 only). */\nexport default class GPUGridLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends GridAggregationLayer<DataT, ExtraPropsT & Required<_GPUGridLayerProps<DataT>>> {\n  static layerName = 'GPUGridLayer';\n  static defaultProps = defaultProps;\n\n  initializeState({gl}: LayerContext): void {\n    const isSupported = GPUGridAggregator.isSupported(gl);\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false, // aggregation in world space\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      color: {size: 3, accessor: 'getColorWeight'},\n      elevation: {size: 3, accessor: 'getElevationWeight'}\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      // Skip update, layer not supported\n      return;\n    }\n    super.updateState(opts);\n    const {aggregationDirty} = this.state;\n    if (aggregationDirty) {\n      // reset cached CPU Aggregation results (used for picking)\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index: number): string {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    // This will match the index to the hash-key to access aggregation data from CPU aggregation results.\n    const latIdx = Math.floor(\n      (yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]\n    );\n    const lonIdx = Math.floor(\n      (xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]\n    );\n    return `${latIdx}-${lonIdx}`;\n  }\n\n  getPositionForIndex(index: number): Position {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({info, mode}: GetPickingInfoParams): PickingInfo {\n    const {index} = info;\n    let object: any = null;\n    if (index >= 0) {\n      const {gpuGridAggregator} = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n      if (mode !== 'hover') {\n        // perform CPU aggregation for full list of points for each cell\n        const {props} = this;\n        let {gridHash} = this.state;\n        if (!gridHash) {\n          const {gridOffset, translation, boundingBox} = this.state;\n          const {viewport} = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props as any, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({gridHash});\n        }\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n\n    const {weights, numRow, numCol, gridOrigin, gridOffset} = this.state;\n    const {color, elevation} = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n\n    return new SubLayerClass(\n      {\n        gridSize: [numCol, numRow],\n        gridOrigin,\n        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n        colorRange,\n        elevationRange,\n        colorDomain,\n        elevationDomain,\n\n        cellSize: cellSizeMeters,\n        coverage,\n        material,\n        elevationScale,\n        extruded\n      },\n      this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }),\n      {\n        data: {\n          attributes: {\n            colors: color.aggregationBuffer,\n            elevations: elevation.aggregationBuffer\n          }\n        },\n        colorMaxMinBuffer: color.maxMinBuffer,\n        elevationMaxMinBuffer: elevation.maxMinBuffer,\n        numInstances: numCol * numRow\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext) {\n    const {color, elevation} = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {aggregationBuffer, maxMinBuffer} = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer?.delete();\n    });\n    super.finalizeState(context);\n  }\n\n  // Aggregation Overrides\n\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {dimensions} = this.state;\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    // any attribute changed\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      attributesChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: dimensions.data,\n        compareAll: true\n      });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {colorAggregation, elevationAggregation} = opts.props;\n    const {color, elevation} = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}