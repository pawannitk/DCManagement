{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";import _flatMap from \"lodash/flatMap\";import _mapValues from \"lodash/fp/mapValues\";import _keyBy from \"lodash/fp/keyBy\";import _flow from \"lodash/fp/flow\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n            ...subTabChildren.filter(({ type }) => type === CHART_TYPE)\n          );\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = []\n}) {\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n  forceAggregate ||\n  !hasChartSiblings &&\n  Object.entries(tabScopes).every(\n    ([key, { scope }]) => scope && scope.length && key === scope[0]\n  ))\n  {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope =\n    getImmuneChartIdsFromTabsNotInScope({\n      tabs: tabChildren,\n      tabsInScope: _flatMap(tabScopes, ({ scope }) => scope)\n    });\n    const immuneChartIdsFromTabsInScope = _flatMap(\n      Object.values(tabScopes),\n      ({ immune }) => immune\n    );\n    const immuneCharts = [\n    ...new Set([\n    ...immuneChartIdsFromTabsNotInScope,\n    ...immuneChartIdsFromTabsInScope]\n    )];\n\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts\n    };\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n    ({ scope }) => scope && scope.length\n  );\n  return {\n    scope: _flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length ?\n    _flatMap(componentsInScope, ({ immune }) => immune) :\n    _flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n      immuneChartSiblings\n    )\n  };\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren.\n  filter(\n    ({ value }) => filterId !== value && !checkedChartIds.includes(value)\n  ).\n  map(({ value }) => value);\n  const tabScopes = _flow(\n    _keyBy((child) => child.value),\n    _mapValues((child) =>\n    traverse({\n      currentNode: child,\n      filterId,\n      checkedChartIds\n    })\n    )\n  )(tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n  !_isEmpty(chartChildren) &&\n  chartChildren.some(({ value }) => checkedChartIds.includes(value)))\n  {\n    if (_isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren\n    });\n    return {\n      scope,\n      immune: chartsImmune.concat(immune)\n    };\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !_isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune\n    });\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune\n  };\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = []\n}) {\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds\n    });\n  }\n\n  return {};\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getImmuneChartIdsFromTabsNotInScope, \"getImmuneChartIdsFromTabsNotInScope\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getTabChildrenScope, \"getTabChildrenScope\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(traverse, \"traverse\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getFilterScopeFromNodesTree, \"getFilterScopeFromNodesTree\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","CHART_TYPE","TAB_TYPE","getChartIdAndColumnFromFilterKey","getImmuneChartIdsFromTabsNotInScope","tabs","tabsInScope","chartsNotInScope","forEach","value","tab","children","tabChildren","includes","subTab","subTabChildren","push","filter","type","map","getTabChildrenScope","tabScopes","parentNodeValue","forceAggregate","hasChartSiblings","immuneChartSiblings","Object","entries","every","key","scope","length","immuneChartIdsFromTabsNotInScope","_flatMap","immuneChartIdsFromTabsInScope","values","immune","immuneCharts","Set","componentsInScope","concat","traverse","currentNode","filterId","checkedChartIds","currentValue","chartChildren","chartsImmune","_flow","_keyBy","child","_mapValues","_isEmpty","some","getFilterScopeFromNodesTree","filterKey","nodes","chartId","reactHotLoader","register","leaveModule"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { flow, keyBy, mapValues } from 'lodash/fp';\nimport { flatMap, isEmpty } from 'lodash';\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n            ...subTabChildren.filter(({ type }) => type === CHART_TYPE),\n          );\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = [],\n}) {\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n    forceAggregate ||\n    (!hasChartSiblings &&\n      Object.entries(tabScopes).every(\n        ([key, { scope }]) => scope && scope.length && key === scope[0],\n      ))\n  ) {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope =\n      getImmuneChartIdsFromTabsNotInScope({\n        tabs: tabChildren,\n        tabsInScope: flatMap(tabScopes, ({ scope }) => scope),\n      });\n    const immuneChartIdsFromTabsInScope = flatMap(\n      Object.values(tabScopes),\n      ({ immune }) => immune,\n    );\n    const immuneCharts = [\n      ...new Set([\n        ...immuneChartIdsFromTabsNotInScope,\n        ...immuneChartIdsFromTabsInScope,\n      ]),\n    ];\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts,\n    };\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n    ({ scope }) => scope && scope.length,\n  );\n  return {\n    scope: flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length\n      ? flatMap(componentsInScope, ({ immune }) => immune)\n      : flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n          immuneChartSiblings,\n        ),\n  };\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren\n    .filter(\n      ({ value }) => filterId !== value && !checkedChartIds.includes(value),\n    )\n    .map(({ value }) => value);\n  const tabScopes = flow(\n    keyBy(child => child.value),\n    mapValues(child =>\n      traverse({\n        currentNode: child,\n        filterId,\n        checkedChartIds,\n      }),\n    ),\n  )(tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n    !isEmpty(chartChildren) &&\n    chartChildren.some(({ value }) => checkedChartIds.includes(value))\n  ) {\n    if (isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren,\n    });\n    return {\n      scope,\n      immune: chartsImmune.concat(immune),\n    };\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune,\n    });\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune,\n  };\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [],\n}) {\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds,\n    });\n  }\n\n  return {};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}