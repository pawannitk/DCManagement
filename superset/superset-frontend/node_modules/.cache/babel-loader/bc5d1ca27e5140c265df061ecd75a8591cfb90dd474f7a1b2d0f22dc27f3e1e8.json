{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { getCode, getVertices, CONTOUR_TYPE } from './marching-squares';\nexport function generateContours({\n  thresholdData,\n  cellWeights,\n  gridSize,\n  gridOrigin,\n  cellSize\n}) {\n  const contourSegments = [];\n  const contourPolygons = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {\n      contour\n    } = data;\n    const {\n      threshold\n    } = contour;\n\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        const {\n          code,\n          meanCode\n        } = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          type: CONTOUR_TYPE.ISO_BANDS,\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts);\n\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts);\n\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    contourSegments,\n    contourPolygons\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(generateContours, \"generateContours\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/aggregation-layers/dist/esm/contour-layer/contour-utils.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["getCode","getVertices","CONTOUR_TYPE","generateContours","thresholdData","cellWeights","gridSize","gridOrigin","cellSize","contourSegments","contourPolygons","width","height","segmentIndex","polygonIndex","data","contour","threshold","x","y","code","meanCode","opts","type","ISO_BANDS","Array","isArray","polygons","polygon","vertices","ISO_LINES","i","length","start","end","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["../../../src/contour-layer/contour-utils.ts"],"sourcesContent":["import {getCode, getVertices, CONTOUR_TYPE} from './marching-squares';\n\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({\n  thresholdData,\n  cellWeights,\n  gridSize,\n  gridOrigin,\n  cellSize\n}: {\n  thresholdData: any;\n  cellWeights: Float32Array;\n  gridSize: number[];\n  gridOrigin: number[];\n  cellSize: number[];\n}) {\n  const contourSegments: {start: number[]; end: number[]; contour: any}[] = [];\n  const contourPolygons: {vertices: number[][]; contour: any}[] = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {contour} = data;\n    const {threshold} = contour;\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        const {code, meanCode} = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          type: CONTOUR_TYPE.ISO_BANDS,\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts) as number[][][];\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          // Get the intersection vertices based on MarchingSquares code.\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts) as number[][];\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n  return {contourSegments, contourPolygons};\n}\n/* eslint-enable max-depth */\n"],"mappings":"uSAAA,SAAQA,OAAR,EAAiBC,WAAjB,EAA8BC,YAA9B,QAAiD,oBAAjD;AAIA,OAAO,SAASC,gBAATA,CAA0B;EAC/BC,aAD+B;EAE/BC,WAF+B;EAG/BC,QAH+B;EAI/BC,UAJ+B;EAK/BC;AAL+B,CAA1B,EAYJ;EACD,MAAMC,eAAiE,GAAG,EAA1E;EACA,MAAMC,eAAuD,GAAG,EAAhE;EACA,MAAMC,KAAK,GAAGL,QAAQ,CAAC,CAAD,CAAtB;EACA,MAAMM,MAAM,GAAGN,QAAQ,CAAC,CAAD,CAAvB;EACA,IAAIO,YAAY,GAAG,CAAnB;EACA,IAAIC,YAAY,GAAG,CAAnB;;EAEA,KAAK,MAAMC,IAAX,IAAmBX,aAAnB,EAAkC;IAChC,MAAM;MAACY;IAAD,IAAYD,IAAlB;IACA,MAAM;MAACE;IAAD,IAAcD,OAApB;;IACA,KAAK,IAAIE,CAAC,GAAG,CAAC,CAAd,EAAiBA,CAAC,GAAGP,KAArB,EAA4BO,CAAC,EAA7B,EAAiC;MAC/B,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAd,EAAiBA,CAAC,GAAGP,MAArB,EAA6BO,CAAC,EAA9B,EAAkC;QAEhC,MAAM;UAACC,IAAD;UAAOC;QAAP,IAAmBrB,OAAO,CAAC;UAC/BK,WAD+B;UAE/BY,SAF+B;UAG/BC,CAH+B;UAI/BC,CAJ+B;UAK/BR,KAL+B;UAM/BC;QAN+B,CAAD,CAAhC;QAQA,MAAMU,IAAI,GAAG;UACXC,IAAI,EAAErB,YAAY,CAACsB,SADR;UAEXjB,UAFW;UAGXC,QAHW;UAIXU,CAJW;UAKXC,CALW;UAMXR,KANW;UAOXC,MAPW;UAQXQ,IARW;UASXC,QATW;UAUXjB,aAAa,EAAEW;QAVJ,CAAb;;QAYA,IAAIU,KAAK,CAACC,OAAN,CAAcT,SAAd,CAAJ,EAA8B;UAC5BK,IAAI,CAACC,IAAL,GAAYrB,YAAY,CAACsB,SAAzB;UACA,MAAMG,QAAQ,GAAG1B,WAAW,CAACqB,IAAD,CAA5B;;UACA,KAAK,MAAMM,OAAX,IAAsBD,QAAtB,EAAgC;YAC9BjB,eAAe,CAACI,YAAY,EAAb,CAAf,GAAkC;cAChCe,QAAQ,EAAED,OADsB;cAEhCZ;YAFgC,CAAlC;UAID;QACF,CATD,MASO;UAELM,IAAI,CAACC,IAAL,GAAYrB,YAAY,CAAC4B,SAAzB;UACA,MAAMD,QAAQ,GAAG5B,WAAW,CAACqB,IAAD,CAA5B;;UACA,KAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACG,MAA7B,EAAqCD,CAAC,IAAI,CAA1C,EAA6C;YAC3CtB,eAAe,CAACI,YAAY,EAAb,CAAf,GAAkC;cAChCoB,KAAK,EAAEJ,QAAQ,CAACE,CAAD,CADiB;cAEhCG,GAAG,EAAEL,QAAQ,CAACE,CAAC,GAAG,CAAL,CAFmB;cAGhCf;YAHgC,CAAlC;UAKD;QACF;MACF;IACF;EACF;;EACD,OAAO;IAACP,eAAD;IAAkBC;EAAlB,CAAP;AACD,oBAAAyB,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAC,SAAA,MAAAH,cAAA,WAAAA,cAAA,CAAAI,QAAA,CAvEepC,gBAAT,4NAAAqC,WAAA,UAAAJ,oBAAA,mBAAAA,oBAAA,CAAAI,WAAA,GAAAF,SAAA,CAAAE,WAAA,IAAAA,WAAA,CAAAC,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}