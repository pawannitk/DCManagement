{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { WebMercatorViewport, OrthographicViewport } from '@deck.gl/core';\nexport function joinLayerBounds(layers, viewport) {\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n  for (const layer of layers) {\n    const layerBounds = layer.getBounds();\n\n    if (layerBounds) {\n      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {\n        viewport,\n        autoOffset: false\n      });\n      const topRightCommon = layer.projectPosition(layerBounds[1], {\n        viewport,\n        autoOffset: false\n      });\n      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);\n      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);\n      bounds[2] = Math.max(bounds[2], topRightCommon[0]);\n      bounds[3] = Math.max(bounds[3], topRightCommon[1]);\n    }\n  }\n\n  if (Number.isFinite(bounds[0])) {\n    return bounds;\n  }\n\n  return null;\n}\nconst MAX_VIEWPORT_SIZE = 2048;\nexport function makeViewport(opts) {\n  const {\n    bounds,\n    viewport,\n    border = 0\n  } = opts;\n  const {\n    isGeospatial\n  } = viewport;\n\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n\n  const centerWorld = viewport.unprojectPosition([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0]);\n  let {\n    width,\n    height,\n    zoom\n  } = opts;\n\n  if (zoom === undefined) {\n    width = width - border * 2;\n    height = height - border * 2;\n    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n    zoom = Math.min(Math.log2(scale), 20);\n  } else if (!width || !height) {\n    const scale = 2 ** zoom;\n    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);\n    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);\n    const maxSize = MAX_VIEWPORT_SIZE - border * 2;\n\n    if (width > maxSize || height > maxSize) {\n      const r = maxSize / Math.max(width, height);\n      width = Math.round(width * r);\n      height = Math.round(height * r);\n      zoom += Math.log2(r);\n    }\n  }\n\n  return isGeospatial ? new WebMercatorViewport({\n    id: viewport.id,\n    x: border,\n    y: border,\n    width,\n    height,\n    longitude: centerWorld[0],\n    latitude: centerWorld[1],\n    zoom,\n    orthographic: true\n  }) : new OrthographicViewport({\n    id: viewport.id,\n    x: border,\n    y: border,\n    width,\n    height,\n    target: centerWorld,\n    zoom,\n    flipY: false\n  });\n}\nexport function getViewportBounds(viewport, zRange) {\n  let viewportBoundsWorld;\n\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({\n      z: minZ\n    });\n    const bounds1 = viewport.getBounds({\n      z: maxZ\n    });\n    viewportBoundsWorld = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];\n  } else {\n    viewportBoundsWorld = viewport.getBounds();\n  }\n\n  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));\n  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));\n  return [viewportBottomLeftCommon[0], viewportBottomLeftCommon[1], viewportTopRightCommon[0], viewportTopRightCommon[1]];\n}\nexport function getRenderBounds(layerBounds, viewport, zRange) {\n  if (!layerBounds) {\n    return [0, 0, 1, 1];\n  }\n\n  const viewportBounds = getViewportBounds(viewport, zRange);\n  const paddedBounds = doubleBounds(viewportBounds);\n\n  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {\n    return layerBounds;\n  }\n\n  return [Math.max(layerBounds[0], paddedBounds[0]), Math.max(layerBounds[1], paddedBounds[1]), Math.min(layerBounds[2], paddedBounds[2]), Math.min(layerBounds[3], paddedBounds[3])];\n}\n\nfunction doubleBounds(bounds) {\n  const dx = bounds[2] - bounds[0];\n  const dy = bounds[3] - bounds[1];\n  const centerX = (bounds[0] + bounds[2]) / 2;\n  const centerY = (bounds[1] + bounds[3]) / 2;\n  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(joinLayerBounds, \"joinLayerBounds\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js\");reactHotLoader.register(MAX_VIEWPORT_SIZE, \"MAX_VIEWPORT_SIZE\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js\");reactHotLoader.register(makeViewport, \"makeViewport\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js\");reactHotLoader.register(getViewportBounds, \"getViewportBounds\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js\");reactHotLoader.register(getRenderBounds, \"getRenderBounds\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js\");reactHotLoader.register(doubleBounds, \"doubleBounds\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["WebMercatorViewport","OrthographicViewport","joinLayerBounds","layers","viewport","bounds","Infinity","layer","layerBounds","getBounds","bottomLeftCommon","projectPosition","autoOffset","topRightCommon","Math","min","max","Number","isFinite","MAX_VIEWPORT_SIZE","makeViewport","opts","border","isGeospatial","centerWorld","unprojectPosition","width","height","zoom","undefined","scale","log2","round","abs","maxSize","r","id","x","y","longitude","latitude","orthographic","target","flipY","getViewportBounds","zRange","viewportBoundsWorld","length","minZ","maxZ","bounds0","z","bounds1","viewportBottomLeftCommon","slice","viewportTopRightCommon","getRenderBounds","viewportBounds","paddedBounds","doubleBounds","dx","dy","centerX","centerY","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["../../../src/utils/projection-utils.ts"],"sourcesContent":["import {WebMercatorViewport, OrthographicViewport} from '@deck.gl/core';\nimport type {Layer, Viewport} from '@deck.gl/core';\n\n/** Bounds in CARTESIAN coordinates */\nexport type Bounds = [minX: number, minY: number, maxX: number, maxY: number];\n\n/*\n * Compute the union of bounds from multiple layers\n * Returns bounds in CARTESIAN coordinates\n */\nexport function joinLayerBounds(\n  /** The layers to combine */\n  layers: Layer[],\n  /** A Viewport instance that is used to determine the type of the view */\n  viewport: Viewport\n): Bounds | null {\n  // Join the bounds of layer data\n  const bounds: Bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (const layer of layers) {\n    const layerBounds = layer.getBounds();\n    if (layerBounds) {\n      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {viewport, autoOffset: false});\n      const topRightCommon = layer.projectPosition(layerBounds[1], {viewport, autoOffset: false});\n\n      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);\n      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);\n      bounds[2] = Math.max(bounds[2], topRightCommon[0]);\n      bounds[3] = Math.max(bounds[3], topRightCommon[1]);\n    }\n  }\n\n  if (Number.isFinite(bounds[0])) {\n    return bounds;\n  }\n  return null;\n}\n\nconst MAX_VIEWPORT_SIZE = 2048;\n\n/** Construct a viewport that just covers the target bounds. Used for rendering to common space indexed texture. */\nexport function makeViewport(opts: {\n  /** The cartesian bounds of layers that will render into this texture */\n  bounds: Bounds;\n  /** Target width. If not specified, will be deduced from zoom */\n  width?: number;\n  /** Target height. If not specified, will be deduced from zoom */\n  height?: number;\n  /** Target zoom. If not specified, will be deduced from width and height */\n  zoom?: number;\n  /** Border around the viewport in pixels */\n  border?: number;\n  /** A viewport used to determine the output type */\n  viewport: Viewport;\n}): Viewport | null {\n  const {bounds, viewport, border = 0} = opts;\n  const {isGeospatial} = viewport;\n\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n\n  const centerWorld = viewport.unprojectPosition([\n    (bounds[0] + bounds[2]) / 2,\n    (bounds[1] + bounds[3]) / 2,\n    0\n  ]);\n\n  let {width, height, zoom} = opts;\n  if (zoom === undefined) {\n    // Use width and height to determine zoom\n    width = width! - border * 2;\n    height = height! - border * 2;\n    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n    zoom = Math.min(Math.log2(scale), 20);\n  } else if (!width || !height) {\n    // Use zoom to determine width and height\n    const scale = 2 ** zoom;\n    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);\n    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);\n    const maxSize = MAX_VIEWPORT_SIZE - border * 2;\n    if (width > maxSize || height > maxSize) {\n      const r = maxSize / Math.max(width, height);\n      width = Math.round(width * r);\n      height = Math.round(height * r);\n      zoom += Math.log2(r);\n    }\n  }\n\n  // TODO - find a more generic way to construct this viewport\n  // Geospatial viewports may not be web-mercator\n  return isGeospatial\n    ? new WebMercatorViewport({\n        id: viewport.id,\n        x: border,\n        y: border,\n        width,\n        height,\n        longitude: centerWorld[0],\n        latitude: centerWorld[1],\n        zoom,\n        orthographic: true\n      })\n    : new OrthographicViewport({\n        id: viewport.id,\n        x: border,\n        y: border,\n        width,\n        height,\n        target: centerWorld,\n        zoom,\n        flipY: false\n      });\n}\n\n/** Returns viewport bounds in CARTESIAN coordinates */\nexport function getViewportBounds(viewport: Viewport, zRange?: [number, number]): Bounds {\n  // Viewport bounds in world coordinates\n  let viewportBoundsWorld: Bounds;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({z: minZ});\n    const bounds1 = viewport.getBounds({z: maxZ});\n    viewportBoundsWorld = [\n      Math.min(bounds0[0], bounds1[0]),\n      Math.min(bounds0[1], bounds1[1]),\n      Math.max(bounds0[2], bounds1[2]),\n      Math.max(bounds0[3], bounds1[3])\n    ];\n  } else {\n    viewportBoundsWorld = viewport.getBounds();\n  }\n\n  // Viewport bounds in cartesian coordinates\n  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));\n  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));\n  return [\n    viewportBottomLeftCommon[0],\n    viewportBottomLeftCommon[1],\n    viewportTopRightCommon[0],\n    viewportTopRightCommon[1]\n  ];\n}\n\n/*\n * Determine the common space bounds that best cover the given data for the given viewport\n * Returns bounds in CARTESIAN coordinates\n */\nexport function getRenderBounds(\n  layerBounds: Bounds,\n  viewport: Viewport,\n  zRange?: [number, number]\n): Bounds {\n  if (!layerBounds) {\n    return [0, 0, 1, 1];\n  }\n\n  const viewportBounds = getViewportBounds(viewport, zRange);\n  // Expand viewport bounds by 2X. Heurestically chosen to avoid masking\n  // errors when mask is partially out of view\n  const paddedBounds = doubleBounds(viewportBounds);\n\n  // When bounds of the layers are smaller than the viewport bounds simply use\n  // mask bounds, so as to maximize resolution & avoid rerenders\n  if (\n    layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] &&\n    layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]\n  ) {\n    return layerBounds;\n  }\n\n  // As viewport shrinks, to avoid pixelation along mask edges\n  // we need to reduce the bounds and only render the visible portion\n  // of the mask.\n  // We pad the viewport bounds to capture the section\n  // of the mask just outside the viewport to correctly maskByInstance.\n  // Intersect mask & padded viewport bounds\n  return [\n    Math.max(layerBounds[0], paddedBounds[0]),\n    Math.max(layerBounds[1], paddedBounds[1]),\n    Math.min(layerBounds[2], paddedBounds[2]),\n    Math.min(layerBounds[3], paddedBounds[3])\n  ];\n}\n\nfunction doubleBounds(bounds: Bounds): Bounds {\n  const dx = bounds[2] - bounds[0];\n  const dy = bounds[3] - bounds[1];\n  const centerX = (bounds[0] + bounds[2]) / 2;\n  const centerY = (bounds[1] + bounds[3]) / 2;\n  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}