{"ast":null,"code":"import _sumBy from \"lodash/sumBy\";import _orderBy from \"lodash/orderBy\";import _minBy from \"lodash/minBy\";import _meanBy from \"lodash/meanBy\";import _maxBy from \"lodash/maxBy\";import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { AxisType, DTTM_ALIAS, ensureIsArray, GenericDataType, normalizeTimestamp, NumberFormats, NumberFormatter } from '@superset-ui/core';\nimport { SortSeriesType } from '@superset-ui/chart-controls';\nimport { format } from 'echarts';\n\nimport { NULL_STRING, StackControlsValue, TIMESERIES_CONSTANTS } from '../constants';\nimport { EchartsTimeseriesSeriesType, LegendOrientation } from '../types';\nimport { defaultLegendPadding } from '../defaults';\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\nexport function extractDataTotalValues(data, opts) {\n  const totalStackedValues = [];\n  const thresholdValues = [];\n  const { stack, percentageThreshold, xAxisCol, legendState } = opts;\n  if (stack) {\n    data.forEach((datum) => {\n      const values = Object.keys(datum).reduce((prev, curr) => {\n        if (curr === xAxisCol) {\n          return prev;\n        }\n        if (legendState && !legendState[curr]) {\n          return prev;\n        }\n        const value = datum[curr] || 0;\n        return prev + value;\n      }, 0);\n      totalStackedValues.push(values);\n      thresholdValues.push((percentageThreshold || 0) / 100 * values);\n    });\n  }\n  return {\n    totalStackedValues,\n    thresholdValues\n  };\n}\nexport function extractShowValueIndexes(series, opts) {\n  const showValueIndexes = [];\n  const { legendState, stack, isHorizontal, onlyTotal } = opts;\n  if (stack) {\n    series.forEach((entry, seriesIndex) => {\n      const { data = [] } = entry;\n      data.forEach((datum, dataIndex) => {\n        if (entry.id && legendState && !legendState[entry.id]) {\n          return;\n        }\n        if (!onlyTotal && datum[isHorizontal ? 0 : 1] !== null) {\n          showValueIndexes[dataIndex] = seriesIndex;\n        }\n        if (onlyTotal) {\n          if (datum[isHorizontal ? 0 : 1] > 0) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n          if (!showValueIndexes[dataIndex] &&\n          datum[isHorizontal ? 0 : 1] !== null) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n        }\n      });\n    });\n  }\n  return showValueIndexes;\n}\nexport function sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending) {\n  const seriesNames = Object.keys(rows[0]).\n  filter((key) => key !== xAxis).\n  filter((key) => !extraMetricLabels.includes(key));\n  let aggregator;\n  switch (sortSeriesType) {\n    case SortSeriesType.Sum:\n      aggregator = (name) => ({ name, value: _sumBy(rows, name) });\n      break;\n    case SortSeriesType.Min:\n      aggregator = (name) => {var _minBy2;return { name, value: (_minBy2 = _minBy(rows, name)) == null ? void 0 : _minBy2[name] };};\n      break;\n    case SortSeriesType.Max:\n      aggregator = (name) => {var _maxBy2;return { name, value: (_maxBy2 = _maxBy(rows, name)) == null ? void 0 : _maxBy2[name] };};\n      break;\n    case SortSeriesType.Avg:\n      aggregator = (name) => ({ name, value: _meanBy(rows, name) });\n      break;\n    default:\n      aggregator = (name) => ({ name, value: name.toLowerCase() });\n      break;\n  }\n  const sortedValues = seriesNames.map(aggregator);\n  return _orderBy(sortedValues, ['value'], [sortSeriesAscending ? 'asc' : 'desc']).map(({ name }) => name);\n}\nexport function sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) {\n  const sortedRows = rows.map((row, idx) => {\n    let sortKey = '';\n    let aggregate;\n    let entries = 0;\n    Object.entries(row).forEach(([key, value]) => {\n      const isValueDefined = isDefined(value);\n      if (key === xAxis) {\n        sortKey = value;\n      }\n      if (xAxisSortSeries === SortSeriesType.Name ||\n      typeof value !== 'number') {\n        return;\n      }\n      if (!(xAxisSortSeries === SortSeriesType.Avg && !isValueDefined)) {\n        entries += 1;\n      }\n      switch (xAxisSortSeries) {\n        case SortSeriesType.Avg:\n        case SortSeriesType.Sum:\n          if (aggregate === undefined) {\n            aggregate = value;\n          } else\n          {\n            aggregate += value;\n          }\n          break;\n        case SortSeriesType.Min:\n          aggregate =\n          aggregate === undefined || isValueDefined && value < aggregate ?\n          value :\n          aggregate;\n          break;\n        case SortSeriesType.Max:\n          aggregate =\n          aggregate === undefined || isValueDefined && value > aggregate ?\n          value :\n          aggregate;\n          break;\n        default:\n          break;\n      }\n    });\n    if (xAxisSortSeries === SortSeriesType.Avg &&\n    entries > 0 &&\n    aggregate !== undefined) {\n      aggregate /= entries;\n    }\n    const value = xAxisSortSeries === SortSeriesType.Name ?\n    typeof sortKey === 'string' ?\n    sortKey.toLowerCase() :\n    sortKey :\n    aggregate;\n    return {\n      key: sortKey,\n      value,\n      row,\n      totalStackedValue: totalStackedValues[idx]\n    };\n  });\n  return _orderBy(sortedRows, ['value'], [xAxisSortSeriesAscending ? 'asc' : 'desc']).map(({ row, totalStackedValue }) => ({ row, totalStackedValue }));\n}\nexport function extractSeries(data, opts = {}) {\n  const { fillNeighborValue, xAxis = DTTM_ALIAS, extraMetricLabels = [], removeNulls = false, stack = false, totalStackedValues = [], isHorizontal = false, sortSeriesType, sortSeriesAscending, xAxisSortSeries, xAxisSortSeriesAscending } = opts;\n  if (data.length === 0)\n  return [[], [], undefined];\n  const rows = data.map((datum) => ({\n    ...datum,\n    [xAxis]: datum[xAxis]\n  }));\n  const sortedSeries = sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending);\n  const sortedRows = isDefined(xAxisSortSeries) && isDefined(xAxisSortSeriesAscending) ?\n  sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) :\n  rows.map((row, idx) => ({\n    row,\n    totalStackedValue: totalStackedValues[idx]\n  }));\n  let minPositiveValue;\n  const finalSeries = sortedSeries.map((name) => ({\n    id: name,\n    name,\n    data: sortedRows.\n    map(({ row, totalStackedValue }, idx) => {var _rows, _rows2;\n      const currentValue = row[name];\n      if (typeof currentValue === 'number' &&\n      currentValue > 0 && (\n      minPositiveValue === undefined || minPositiveValue > currentValue)) {\n        minPositiveValue = currentValue;\n      }\n      const isNextToDefinedValue = isDefined((_rows = rows[idx - 1]) == null ? void 0 : _rows[name]) || isDefined((_rows2 = rows[idx + 1]) == null ? void 0 : _rows2[name]);\n      const isFillNeighborValue = !isDefined(currentValue) &&\n      isNextToDefinedValue &&\n      fillNeighborValue !== undefined;\n      let value = currentValue;\n      if (isFillNeighborValue) {\n        value = fillNeighborValue;\n      } else\n      if (stack === StackControlsValue.Expand &&\n      totalStackedValue !== undefined) {\n        value = (value || 0) / totalStackedValue;\n      }\n      return [row[xAxis], value];\n    }).\n    filter((obs) => !removeNulls || obs[0] !== null && obs[1] !== null).\n    map((obs) => isHorizontal ? [obs[1], obs[0]] : obs)\n  }));\n  return [\n  finalSeries,\n  sortedRows.map(({ totalStackedValue }) => totalStackedValue),\n  minPositiveValue];\n\n}\nexport function formatSeriesName(name, { numberFormatter, timeFormatter, coltype } = {}) {\n  if (name === undefined || name === null) {\n    return NULL_STRING;\n  }\n  if (typeof name === 'boolean') {\n    return name.toString();\n  }\n  if (name instanceof Date || coltype === GenericDataType.Temporal) {\n    const normalizedName = typeof name === 'string' ? normalizeTimestamp(name) : name;\n    const d = normalizedName instanceof Date ?\n    normalizedName :\n    new Date(normalizedName);\n    return timeFormatter ? timeFormatter(d) : d.toISOString();\n  }\n  if (typeof name === 'number') {\n    return numberFormatter ? numberFormatter(name) : name.toString();\n  }\n  return name;\n}\nexport const getColtypesMapping = ({ coltypes = [], colnames = [] }) => colnames.reduce((accumulator, item, index) => ({ ...accumulator, [item]: coltypes[index] }), {});\nexport function extractGroupbyLabel({ datum = {}, groupby, numberFormatter, timeFormatter, coltypeMapping = {} }) {\n  return ensureIsArray(groupby).\n  map((val) => formatSeriesName(datum[val], {\n    numberFormatter,\n    timeFormatter,\n    ...(coltypeMapping[val] && { coltype: coltypeMapping[val] })\n  })).\n  join(', ');\n}\nexport function getLegendProps(type, orientation, show, theme, zoomable = false, legendState) {\n  const legend = {\n    orient: [LegendOrientation.Top, LegendOrientation.Bottom].includes(orientation) ?\n    'horizontal' :\n    'vertical',\n    show,\n    type,\n    selected: legendState,\n    selector: ['all', 'inverse'],\n    selectorLabel: {\n      fontFamily: theme.typography.families.sansSerif,\n      fontSize: theme.typography.sizes.s,\n      color: theme.colors.grayscale.base,\n      borderColor: theme.colors.grayscale.base\n    }\n  };\n  switch (orientation) {\n    case LegendOrientation.Left:\n      legend.left = 0;\n      break;\n    case LegendOrientation.Right:\n      legend.right = 0;\n      legend.top = zoomable ? TIMESERIES_CONSTANTS.legendRightTopOffset : 0;\n      break;\n    case LegendOrientation.Bottom:\n      legend.bottom = 0;\n      break;\n    case LegendOrientation.Top:\n    default:\n      legend.top = 0;\n      legend.right = zoomable ? TIMESERIES_CONSTANTS.legendTopRightOffset : 0;\n      break;\n  }\n  return legend;\n}\nexport function getChartPadding(show, orientation, margin, padding, isHorizontal) {\n  let legendMargin;\n  if (!show) {\n    legendMargin = 0;\n  } else\n  if (margin === null ||\n  margin === undefined ||\n  typeof margin === 'string') {\n    legendMargin = defaultLegendPadding[orientation];\n  } else\n  {\n    legendMargin = margin;\n  }\n  const { bottom = 0, left = 0, right = 0, top = 0 } = padding || {};\n  if (isHorizontal) {\n    return {\n      left: left + (orientation === LegendOrientation.Bottom ? legendMargin : 0),\n      right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n      top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n      bottom: bottom + (orientation === LegendOrientation.Left ? legendMargin : 0)\n    };\n  }\n  return {\n    left: left + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n    top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n    bottom: bottom + (orientation === LegendOrientation.Bottom ? legendMargin : 0)\n  };\n}\nexport function dedupSeries(series) {\n  const counter = new Map();\n  return series.map((row) => {\n    let { id } = row;\n    if (id === undefined)\n    return row;\n    id = String(id);\n    const count = counter.get(id) || 0;\n    const suffix = count > 0 ? ` (${count})` : '';\n    counter.set(id, count + 1);\n    return {\n      ...row,\n      id: `${id}${suffix}`\n    };\n  });\n}\nexport function sanitizeHtml(text) {\n  return format.encodeHTML(text);\n}\nexport function getAxisType(stack, forceCategorical, dataType) {\n  if (forceCategorical) {\n    return AxisType.Category;\n  }\n  if (dataType === GenericDataType.Temporal) {\n    return AxisType.Time;\n  }\n  if (dataType === GenericDataType.Numeric && !stack) {\n    return AxisType.Value;\n  }\n  return AxisType.Category;\n}\nexport function getOverMaxHiddenFormatter(config = {}) {\n  const { max, formatter } = config;\n  // Only apply this logic if there's a MAX set in the controls\n  const shouldHideIfOverMax = !!max || max === 0;\n  return new NumberFormatter({\n    formatFunc: (value) => `${shouldHideIfOverMax && value > max ?\n    '' :\n    (formatter == null ? void 0 : formatter.format(value)) || value}`,\n    id: NumberFormats.OVER_MAX_HIDDEN\n  });\n}\nexport function calculateLowerLogTick(minPositiveValue) {\n  const logBase10 = Math.floor(Math.log10(minPositiveValue));\n  return Math.pow(10, logBase10);\n}\nexport function getMinAndMaxFromBounds(axisType, truncateAxis, min, max, seriesType) {\n  if (axisType === AxisType.Value && truncateAxis) {\n    const ret = {};\n    if (seriesType === EchartsTimeseriesSeriesType.Bar) {\n      ret.scale = true;\n    }\n    if (min !== undefined) {\n      ret.min = min;\n    } else\n    if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.min = 'dataMin';\n    }\n    if (max !== undefined) {\n      ret.max = max;\n    } else\n    if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.max = 'dataMax';\n    }\n    return ret;\n  }\n  return {};\n}\n/**\n * Returns the stackId used in stacked series.\n * It will return the defaultId if the chart is not using time comparison.\n * If time comparison is used, it will return the time comparison value as the stackId\n * if the name includes the time comparison value.\n *\n * @param {string} defaultId The default stackId.\n * @param {string[]} timeCompare The time comparison values.\n * @param {string | number} name The name of the serie.\n *\n * @returns {string} The stackId.\n */\nexport function getTimeCompareStackId(defaultId, timeCompare, name) {\n  if (_isEmpty(timeCompare)) {\n    return defaultId;\n  }\n  // Each timeCompare is its own stack so it doesn't stack on top of original ones\n  return timeCompare.find((value) => {\n    if (typeof name === 'string') {\n      // offset is represented as <offset>, group by list\n      return name.includes(`${value},`) ||\n      // offset is represented as <metric>__<offset>\n      name.includes(`__${value}`);\n    }\n    return name == null ? void 0 : name.toString().includes(value);\n  }) || defaultId;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(isDefined, \"isDefined\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractDataTotalValues, \"extractDataTotalValues\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractShowValueIndexes, \"extractShowValueIndexes\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(sortAndFilterSeries, \"sortAndFilterSeries\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(sortRows, \"sortRows\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractSeries, \"extractSeries\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(formatSeriesName, \"formatSeriesName\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getColtypesMapping, \"getColtypesMapping\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractGroupbyLabel, \"extractGroupbyLabel\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getLegendProps, \"getLegendProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getChartPadding, \"getChartPadding\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(dedupSeries, \"dedupSeries\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(sanitizeHtml, \"sanitizeHtml\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getAxisType, \"getAxisType\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getOverMaxHiddenFormatter, \"getOverMaxHiddenFormatter\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(calculateLowerLogTick, \"calculateLowerLogTick\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getMinAndMaxFromBounds, \"getMinAndMaxFromBounds\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getTimeCompareStackId, \"getTimeCompareStackId\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["AxisType","DTTM_ALIAS","ensureIsArray","GenericDataType","normalizeTimestamp","NumberFormats","NumberFormatter","SortSeriesType","format","NULL_STRING","StackControlsValue","TIMESERIES_CONSTANTS","EchartsTimeseriesSeriesType","LegendOrientation","defaultLegendPadding","isDefined","value","undefined","extractDataTotalValues","data","opts","totalStackedValues","thresholdValues","stack","percentageThreshold","xAxisCol","legendState","forEach","datum","values","Object","keys","reduce","prev","curr","push","extractShowValueIndexes","series","showValueIndexes","isHorizontal","onlyTotal","entry","seriesIndex","dataIndex","id","sortAndFilterSeries","rows","xAxis","extraMetricLabels","sortSeriesType","sortSeriesAscending","seriesNames","filter","key","includes","aggregator","Sum","name","_sumBy","Min","_minBy2","_minBy","Max","_maxBy2","_maxBy","Avg","_meanBy","toLowerCase","sortedValues","map","_orderBy","sortRows","xAxisSortSeries","xAxisSortSeriesAscending","sortedRows","row","idx","sortKey","aggregate","entries","isValueDefined","Name","totalStackedValue","extractSeries","fillNeighborValue","removeNulls","length","sortedSeries","minPositiveValue","finalSeries","_rows","_rows2","currentValue","isNextToDefinedValue","isFillNeighborValue","Expand","obs","formatSeriesName","numberFormatter","timeFormatter","coltype","toString","Date","Temporal","normalizedName","d","toISOString","getColtypesMapping","coltypes","colnames","accumulator","item","index","extractGroupbyLabel","groupby","coltypeMapping","val","join","getLegendProps","type","orientation","show","theme","zoomable","legend","orient","Top","Bottom","selected","selector","selectorLabel","fontFamily","typography","families","sansSerif","fontSize","sizes","s","color","colors","grayscale","base","borderColor","Left","left","Right","right","top","legendRightTopOffset","bottom","legendTopRightOffset","getChartPadding","margin","padding","legendMargin","dedupSeries","counter","Map","String","count","get","suffix","set","sanitizeHtml","text","encodeHTML","getAxisType","forceCategorical","dataType","Category","Time","Numeric","Value","getOverMaxHiddenFormatter","config","max","formatter","shouldHideIfOverMax","formatFunc","OVER_MAX_HIDDEN","calculateLowerLogTick","logBase10","Math","floor","log10","pow","getMinAndMaxFromBounds","axisType","truncateAxis","min","seriesType","ret","Bar","scale","getTimeCompareStackId","defaultId","timeCompare","_isEmpty","find","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AxisType,\n  ChartDataResponseResult,\n  DataRecord,\n  DataRecordValue,\n  DTTM_ALIAS,\n  ensureIsArray,\n  GenericDataType,\n  LegendState,\n  normalizeTimestamp,\n  NumberFormats,\n  NumberFormatter,\n  SupersetTheme,\n  TimeFormatter,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport { SortSeriesType } from '@superset-ui/chart-controls';\nimport { format, LegendComponentOption, SeriesOption } from 'echarts';\nimport { isEmpty, maxBy, meanBy, minBy, orderBy, sumBy } from 'lodash';\nimport {\n  NULL_STRING,\n  StackControlsValue,\n  TIMESERIES_CONSTANTS,\n} from '../constants';\nimport {\n  EchartsTimeseriesSeriesType,\n  LegendOrientation,\n  LegendType,\n  StackType,\n} from '../types';\nimport { defaultLegendPadding } from '../defaults';\n\nfunction isDefined<T>(value: T | undefined | null): boolean {\n  return value !== undefined && value !== null;\n}\n\nexport function extractDataTotalValues(\n  data: DataRecord[],\n  opts: {\n    stack: StackType;\n    percentageThreshold: number;\n    xAxisCol: string;\n    legendState?: LegendState;\n  },\n): {\n  totalStackedValues: number[];\n  thresholdValues: number[];\n} {\n  const totalStackedValues: number[] = [];\n  const thresholdValues: number[] = [];\n  const { stack, percentageThreshold, xAxisCol, legendState } = opts;\n  if (stack) {\n    data.forEach(datum => {\n      const values = Object.keys(datum).reduce((prev, curr) => {\n        if (curr === xAxisCol) {\n          return prev;\n        }\n        if (legendState && !legendState[curr]) {\n          return prev;\n        }\n        const value = datum[curr] || 0;\n        return prev + (value as number);\n      }, 0);\n      totalStackedValues.push(values);\n      thresholdValues.push(((percentageThreshold || 0) / 100) * values);\n    });\n  }\n  return {\n    totalStackedValues,\n    thresholdValues,\n  };\n}\n\nexport function extractShowValueIndexes(\n  series: SeriesOption[],\n  opts: {\n    stack: StackType;\n    onlyTotal?: boolean;\n    isHorizontal?: boolean;\n    legendState?: LegendState;\n  },\n): number[] {\n  const showValueIndexes: number[] = [];\n  const { legendState, stack, isHorizontal, onlyTotal } = opts;\n  if (stack) {\n    series.forEach((entry, seriesIndex) => {\n      const { data = [] } = entry;\n      (data as [any, number][]).forEach((datum, dataIndex) => {\n        if (entry.id && legendState && !legendState[entry.id]) {\n          return;\n        }\n        if (!onlyTotal && datum[isHorizontal ? 0 : 1] !== null) {\n          showValueIndexes[dataIndex] = seriesIndex;\n        }\n        if (onlyTotal) {\n          if (datum[isHorizontal ? 0 : 1] > 0) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n          if (\n            !showValueIndexes[dataIndex] &&\n            datum[isHorizontal ? 0 : 1] !== null\n          ) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n        }\n      });\n    });\n  }\n  return showValueIndexes;\n}\n\nexport function sortAndFilterSeries(\n  rows: DataRecord[],\n  xAxis: string,\n  extraMetricLabels: any[],\n  sortSeriesType?: SortSeriesType,\n  sortSeriesAscending?: boolean,\n): string[] {\n  const seriesNames = Object.keys(rows[0])\n    .filter(key => key !== xAxis)\n    .filter(key => !extraMetricLabels.includes(key));\n\n  let aggregator: (name: string) => { name: string; value: any };\n\n  switch (sortSeriesType) {\n    case SortSeriesType.Sum:\n      aggregator = name => ({ name, value: sumBy(rows, name) });\n      break;\n    case SortSeriesType.Min:\n      aggregator = name => ({ name, value: minBy(rows, name)?.[name] });\n      break;\n    case SortSeriesType.Max:\n      aggregator = name => ({ name, value: maxBy(rows, name)?.[name] });\n      break;\n    case SortSeriesType.Avg:\n      aggregator = name => ({ name, value: meanBy(rows, name) });\n      break;\n    default:\n      aggregator = name => ({ name, value: name.toLowerCase() });\n      break;\n  }\n\n  const sortedValues = seriesNames.map(aggregator);\n\n  return orderBy(\n    sortedValues,\n    ['value'],\n    [sortSeriesAscending ? 'asc' : 'desc'],\n  ).map(({ name }) => name);\n}\n\nexport function sortRows(\n  rows: DataRecord[],\n  totalStackedValues: number[],\n  xAxis: string,\n  xAxisSortSeries: SortSeriesType,\n  xAxisSortSeriesAscending: boolean,\n) {\n  const sortedRows = rows.map((row, idx) => {\n    let sortKey: DataRecordValue = '';\n    let aggregate: number | undefined;\n    let entries = 0;\n    Object.entries(row).forEach(([key, value]) => {\n      const isValueDefined = isDefined(value);\n      if (key === xAxis) {\n        sortKey = value;\n      }\n      if (\n        xAxisSortSeries === SortSeriesType.Name ||\n        typeof value !== 'number'\n      ) {\n        return;\n      }\n\n      if (!(xAxisSortSeries === SortSeriesType.Avg && !isValueDefined)) {\n        entries += 1;\n      }\n\n      switch (xAxisSortSeries) {\n        case SortSeriesType.Avg:\n        case SortSeriesType.Sum:\n          if (aggregate === undefined) {\n            aggregate = value;\n          } else {\n            aggregate += value;\n          }\n          break;\n        case SortSeriesType.Min:\n          aggregate =\n            aggregate === undefined || (isValueDefined && value < aggregate)\n              ? value\n              : aggregate;\n          break;\n        case SortSeriesType.Max:\n          aggregate =\n            aggregate === undefined || (isValueDefined && value > aggregate)\n              ? value\n              : aggregate;\n          break;\n        default:\n          break;\n      }\n    });\n    if (\n      xAxisSortSeries === SortSeriesType.Avg &&\n      entries > 0 &&\n      aggregate !== undefined\n    ) {\n      aggregate /= entries;\n    }\n\n    const value =\n      xAxisSortSeries === SortSeriesType.Name\n        ? typeof sortKey === 'string'\n          ? sortKey.toLowerCase()\n          : sortKey\n        : aggregate;\n\n    return {\n      key: sortKey,\n      value,\n      row,\n      totalStackedValue: totalStackedValues[idx],\n    };\n  });\n\n  return orderBy(\n    sortedRows,\n    ['value'],\n    [xAxisSortSeriesAscending ? 'asc' : 'desc'],\n  ).map(({ row, totalStackedValue }) => ({ row, totalStackedValue }));\n}\n\nexport function extractSeries(\n  data: DataRecord[],\n  opts: {\n    fillNeighborValue?: number;\n    xAxis?: string;\n    extraMetricLabels?: string[];\n    removeNulls?: boolean;\n    stack?: StackType;\n    totalStackedValues?: number[];\n    isHorizontal?: boolean;\n    sortSeriesType?: SortSeriesType;\n    sortSeriesAscending?: boolean;\n    xAxisSortSeries?: SortSeriesType;\n    xAxisSortSeriesAscending?: boolean;\n  } = {},\n): [SeriesOption[], number[], number | undefined] {\n  const {\n    fillNeighborValue,\n    xAxis = DTTM_ALIAS,\n    extraMetricLabels = [],\n    removeNulls = false,\n    stack = false,\n    totalStackedValues = [],\n    isHorizontal = false,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries,\n    xAxisSortSeriesAscending,\n  } = opts;\n  if (data.length === 0) return [[], [], undefined];\n  const rows: DataRecord[] = data.map(datum => ({\n    ...datum,\n    [xAxis]: datum[xAxis],\n  }));\n  const sortedSeries = sortAndFilterSeries(\n    rows,\n    xAxis,\n    extraMetricLabels,\n    sortSeriesType,\n    sortSeriesAscending,\n  );\n  const sortedRows =\n    isDefined(xAxisSortSeries) && isDefined(xAxisSortSeriesAscending)\n      ? sortRows(\n          rows,\n          totalStackedValues,\n          xAxis,\n          xAxisSortSeries!,\n          xAxisSortSeriesAscending!,\n        )\n      : rows.map((row, idx) => ({\n          row,\n          totalStackedValue: totalStackedValues[idx],\n        }));\n\n  let minPositiveValue: number | undefined;\n  const finalSeries = sortedSeries.map(name => ({\n    id: name,\n    name,\n    data: sortedRows\n      .map(({ row, totalStackedValue }, idx) => {\n        const currentValue = row[name];\n        if (\n          typeof currentValue === 'number' &&\n          currentValue > 0 &&\n          (minPositiveValue === undefined || minPositiveValue > currentValue)\n        ) {\n          minPositiveValue = currentValue;\n        }\n        const isNextToDefinedValue =\n          isDefined(rows[idx - 1]?.[name]) || isDefined(rows[idx + 1]?.[name]);\n        const isFillNeighborValue =\n          !isDefined(currentValue) &&\n          isNextToDefinedValue &&\n          fillNeighborValue !== undefined;\n        let value: DataRecordValue | undefined = currentValue;\n        if (isFillNeighborValue) {\n          value = fillNeighborValue;\n        } else if (\n          stack === StackControlsValue.Expand &&\n          totalStackedValue !== undefined\n        ) {\n          value = ((value || 0) as number) / totalStackedValue;\n        }\n        return [row[xAxis], value];\n      })\n      .filter(obs => !removeNulls || (obs[0] !== null && obs[1] !== null))\n      .map(obs => (isHorizontal ? [obs[1], obs[0]] : obs)),\n  }));\n  return [\n    finalSeries,\n    sortedRows.map(({ totalStackedValue }) => totalStackedValue),\n    minPositiveValue,\n  ];\n}\n\nexport function formatSeriesName(\n  name: DataRecordValue | undefined,\n  {\n    numberFormatter,\n    timeFormatter,\n    coltype,\n  }: {\n    numberFormatter?: ValueFormatter;\n    timeFormatter?: TimeFormatter;\n    coltype?: GenericDataType;\n  } = {},\n): string {\n  if (name === undefined || name === null) {\n    return NULL_STRING;\n  }\n  if (typeof name === 'boolean') {\n    return name.toString();\n  }\n  if (name instanceof Date || coltype === GenericDataType.Temporal) {\n    const normalizedName =\n      typeof name === 'string' ? normalizeTimestamp(name) : name;\n    const d =\n      normalizedName instanceof Date\n        ? normalizedName\n        : new Date(normalizedName);\n\n    return timeFormatter ? timeFormatter(d) : d.toISOString();\n  }\n  if (typeof name === 'number') {\n    return numberFormatter ? numberFormatter(name) : name.toString();\n  }\n  return name;\n}\n\nexport const getColtypesMapping = ({\n  coltypes = [],\n  colnames = [],\n}: Pick<ChartDataResponseResult, 'coltypes' | 'colnames'>): Record<\n  string,\n  GenericDataType\n> =>\n  colnames.reduce(\n    (accumulator, item, index) => ({ ...accumulator, [item]: coltypes[index] }),\n    {},\n  );\n\nexport function extractGroupbyLabel({\n  datum = {},\n  groupby,\n  numberFormatter,\n  timeFormatter,\n  coltypeMapping = {},\n}: {\n  datum?: DataRecord;\n  groupby?: string[] | null;\n  numberFormatter?: NumberFormatter;\n  timeFormatter?: TimeFormatter;\n  coltypeMapping?: Record<string, GenericDataType>;\n}): string {\n  return ensureIsArray(groupby)\n    .map(val =>\n      formatSeriesName(datum[val], {\n        numberFormatter,\n        timeFormatter,\n        ...(coltypeMapping[val] && { coltype: coltypeMapping[val] }),\n      }),\n    )\n    .join(', ');\n}\n\nexport function getLegendProps(\n  type: LegendType,\n  orientation: LegendOrientation,\n  show: boolean,\n  theme: SupersetTheme,\n  zoomable = false,\n  legendState?: LegendState,\n): LegendComponentOption | LegendComponentOption[] {\n  const legend: LegendComponentOption | LegendComponentOption[] = {\n    orient: [LegendOrientation.Top, LegendOrientation.Bottom].includes(\n      orientation,\n    )\n      ? 'horizontal'\n      : 'vertical',\n    show,\n    type,\n    selected: legendState,\n    selector: ['all', 'inverse'],\n    selectorLabel: {\n      fontFamily: theme.typography.families.sansSerif,\n      fontSize: theme.typography.sizes.s,\n      color: theme.colors.grayscale.base,\n      borderColor: theme.colors.grayscale.base,\n    },\n  };\n  switch (orientation) {\n    case LegendOrientation.Left:\n      legend.left = 0;\n      break;\n    case LegendOrientation.Right:\n      legend.right = 0;\n      legend.top = zoomable ? TIMESERIES_CONSTANTS.legendRightTopOffset : 0;\n      break;\n    case LegendOrientation.Bottom:\n      legend.bottom = 0;\n      break;\n    case LegendOrientation.Top:\n    default:\n      legend.top = 0;\n      legend.right = zoomable ? TIMESERIES_CONSTANTS.legendTopRightOffset : 0;\n      break;\n  }\n  return legend;\n}\n\nexport function getChartPadding(\n  show: boolean,\n  orientation: LegendOrientation,\n  margin?: string | number | null,\n  padding?: { top?: number; bottom?: number; left?: number; right?: number },\n  isHorizontal?: boolean,\n): {\n  bottom: number;\n  left: number;\n  right: number;\n  top: number;\n} {\n  let legendMargin;\n  if (!show) {\n    legendMargin = 0;\n  } else if (\n    margin === null ||\n    margin === undefined ||\n    typeof margin === 'string'\n  ) {\n    legendMargin = defaultLegendPadding[orientation];\n  } else {\n    legendMargin = margin;\n  }\n\n  const { bottom = 0, left = 0, right = 0, top = 0 } = padding || {};\n\n  if (isHorizontal) {\n    return {\n      left:\n        left + (orientation === LegendOrientation.Bottom ? legendMargin : 0),\n      right:\n        right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n      top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n      bottom:\n        bottom + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    };\n  }\n\n  return {\n    left: left + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n    top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n    bottom:\n      bottom + (orientation === LegendOrientation.Bottom ? legendMargin : 0),\n  };\n}\n\nexport function dedupSeries(series: SeriesOption[]): SeriesOption[] {\n  const counter = new Map<string, number>();\n  return series.map(row => {\n    let { id } = row;\n    if (id === undefined) return row;\n    id = String(id);\n    const count = counter.get(id) || 0;\n    const suffix = count > 0 ? ` (${count})` : '';\n    counter.set(id, count + 1);\n    return {\n      ...row,\n      id: `${id}${suffix}`,\n    };\n  });\n}\n\nexport function sanitizeHtml(text: string): string {\n  return format.encodeHTML(text);\n}\n\nexport function getAxisType(\n  stack: StackType,\n  forceCategorical?: boolean,\n  dataType?: GenericDataType,\n): AxisType {\n  if (forceCategorical) {\n    return AxisType.Category;\n  }\n  if (dataType === GenericDataType.Temporal) {\n    return AxisType.Time;\n  }\n  if (dataType === GenericDataType.Numeric && !stack) {\n    return AxisType.Value;\n  }\n  return AxisType.Category;\n}\n\nexport function getOverMaxHiddenFormatter(\n  config: {\n    max?: number;\n    formatter?: ValueFormatter;\n  } = {},\n) {\n  const { max, formatter } = config;\n  // Only apply this logic if there's a MAX set in the controls\n  const shouldHideIfOverMax = !!max || max === 0;\n\n  return new NumberFormatter({\n    formatFunc: value =>\n      `${\n        shouldHideIfOverMax && value > max\n          ? ''\n          : formatter?.format(value) || value\n      }`,\n    id: NumberFormats.OVER_MAX_HIDDEN,\n  });\n}\n\nexport function calculateLowerLogTick(minPositiveValue: number) {\n  const logBase10 = Math.floor(Math.log10(minPositiveValue));\n  return Math.pow(10, logBase10);\n}\n\ntype BoundsType = {\n  min?: number | 'dataMin';\n  max?: number | 'dataMax';\n  scale?: true;\n};\n\nexport function getMinAndMaxFromBounds(\n  axisType: AxisType,\n  truncateAxis: boolean,\n  min?: number,\n  max?: number,\n  seriesType?: EchartsTimeseriesSeriesType,\n): BoundsType | {} {\n  if (axisType === AxisType.Value && truncateAxis) {\n    const ret: BoundsType = {};\n    if (seriesType === EchartsTimeseriesSeriesType.Bar) {\n      ret.scale = true;\n    }\n    if (min !== undefined) {\n      ret.min = min;\n    } else if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.min = 'dataMin';\n    }\n    if (max !== undefined) {\n      ret.max = max;\n    } else if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.max = 'dataMax';\n    }\n    return ret;\n  }\n  return {};\n}\n\n/**\n * Returns the stackId used in stacked series.\n * It will return the defaultId if the chart is not using time comparison.\n * If time comparison is used, it will return the time comparison value as the stackId\n * if the name includes the time comparison value.\n *\n * @param {string} defaultId The default stackId.\n * @param {string[]} timeCompare The time comparison values.\n * @param {string | number} name The name of the serie.\n *\n * @returns {string} The stackId.\n */\nexport function getTimeCompareStackId(\n  defaultId: string,\n  timeCompare: string[],\n  name?: string | number,\n): string {\n  if (isEmpty(timeCompare)) {\n    return defaultId;\n  }\n  // Each timeCompare is its own stack so it doesn't stack on top of original ones\n  return (\n    timeCompare.find(value => {\n      if (typeof name === 'string') {\n        // offset is represented as <offset>, group by list\n        return (\n          name.includes(`${value},`) ||\n          // offset is represented as <metric>__<offset>\n          name.includes(`__${value}`)\n        );\n      }\n      return name?.toString().includes(value);\n    }) || defaultId\n  );\n}\n"],"mappings":"8fAAA;AACA;;;;;;;;;;;;;;;;;;AAkBA,SACEA,QAAQ,EAIRC,UAAU,EACVC,aAAa,EACbC,eAAe,EAEfC,kBAAkB,EAClBC,aAAa,EACbC,eAAe,QAIV,mBAAmB;AAC1B,SAASC,cAAc,QAAQ,6BAA6B;AAC5D,SAASC,MAAM,QAA6C,SAAS;;AAErE,SACEC,WAAW,EACXC,kBAAkB,EAClBC,oBAAoB,QACf,cAAc;AACrB,SACEC,2BAA2B,EAC3BC,iBAAiB,QAGZ,UAAU;AACjB,SAASC,oBAAoB,QAAQ,aAAa;AAElD,SAASC,SAASA,CAAIC,KAA2B;EAC/C,OAAOA,KAAK,KAAKC,SAAS,IAAID,KAAK,KAAK,IAAI;AAC9C;AAEA,OAAM,SAAUE,sBAAsBA,CACpCC,IAAkB,EAClBC,IAKC;EAKD,MAAMC,kBAAkB,GAAa,EAAE;EACvC,MAAMC,eAAe,GAAa,EAAE;EACpC,MAAM,EAAEC,KAAK,EAAEC,mBAAmB,EAAEC,QAAQ,EAAEC,WAAW,EAAE,GAAGN,IAAI;EAClE,IAAIG,KAAK,EAAE;IACTJ,IAAI,CAACQ,OAAO,CAAC,CAAAC,KAAK,KAAG;MACnB,MAAMC,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACH,KAAK,CAAC,CAACI,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAI;QACtD,IAAIA,IAAI,KAAKT,QAAQ,EAAE;UACrB,OAAOQ,IAAI;;QAEb,IAAIP,WAAW,IAAI,CAACA,WAAW,CAACQ,IAAI,CAAC,EAAE;UACrC,OAAOD,IAAI;;QAEb,MAAMjB,KAAK,GAAGY,KAAK,CAACM,IAAI,CAAC,IAAI,CAAC;QAC9B,OAAOD,IAAI,GAAIjB,KAAgB;MACjC,CAAC,EAAE,CAAC,CAAC;MACLK,kBAAkB,CAACc,IAAI,CAACN,MAAM,CAAC;MAC/BP,eAAe,CAACa,IAAI,CAAE,CAACX,mBAAmB,IAAI,CAAC,IAAI,GAAG,GAAIK,MAAM,CAAC;IACnE,CAAC,CAAC;;EAEJ,OAAO;IACLR,kBAAkB;IAClBC;GACD;AACH;AAEA,OAAM,SAAUc,uBAAuBA,CACrCC,MAAsB,EACtBjB,IAKC;EAED,MAAMkB,gBAAgB,GAAa,EAAE;EACrC,MAAM,EAAEZ,WAAW,EAAEH,KAAK,EAAEgB,YAAY,EAAEC,SAAS,EAAE,GAAGpB,IAAI;EAC5D,IAAIG,KAAK,EAAE;IACTc,MAAM,CAACV,OAAO,CAAC,CAACc,KAAK,EAAEC,WAAW,KAAI;MACpC,MAAM,EAAEvB,IAAI,GAAG,EAAE,EAAE,GAAGsB,KAAK;MAC1BtB,IAAwB,CAACQ,OAAO,CAAC,CAACC,KAAK,EAAEe,SAAS,KAAI;QACrD,IAAIF,KAAK,CAACG,EAAE,IAAIlB,WAAW,IAAI,CAACA,WAAW,CAACe,KAAK,CAACG,EAAE,CAAC,EAAE;UACrD;;QAEF,IAAI,CAACJ,SAAS,IAAIZ,KAAK,CAACW,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;UACtDD,gBAAgB,CAACK,SAAS,CAAC,GAAGD,WAAW;;QAE3C,IAAIF,SAAS,EAAE;UACb,IAAIZ,KAAK,CAACW,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE;YACnCD,gBAAgB,CAACK,SAAS,CAAC,GAAGD,WAAW;;UAE3C,IACE,CAACJ,gBAAgB,CAACK,SAAS,CAAC;UAC5Bf,KAAK,CAACW,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EACpC;YACAD,gBAAgB,CAACK,SAAS,CAAC,GAAGD,WAAW;;;MAG/C,CAAC,CAAC;IACJ,CAAC,CAAC;;EAEJ,OAAOJ,gBAAgB;AACzB;AAEA,OAAM,SAAUO,mBAAmBA,CACjCC,IAAkB,EAClBC,KAAa,EACbC,iBAAwB,EACxBC,cAA+B,EAC/BC,mBAA6B;EAE7B,MAAMC,WAAW,GAAGrB,MAAM,CAACC,IAAI,CAACe,IAAI,CAAC,CAAC,CAAC,CAAC;EACrCM,MAAM,CAAC,CAAAC,GAAG,KAAIA,GAAG,KAAKN,KAAK,CAAC;EAC5BK,MAAM,CAAC,CAAAC,GAAG,KAAI,CAACL,iBAAiB,CAACM,QAAQ,CAACD,GAAG,CAAC,CAAC;EAElD,IAAIE,UAA0D;EAE9D,QAAQN,cAAc;IACpB,KAAK1C,cAAc,CAACiD,GAAG;MACrBD,UAAU,GAAGA,CAAAE,IAAI,MAAK,EAAEA,IAAI,EAAEzC,KAAK,EAAE0C,MAAA,CAAMZ,IAAI,EAAEW,IAAI,CAAC,EAAE,CAAC;MACzD;IACF,KAAKlD,cAAc,CAACoD,GAAG;MACrBJ,UAAU,GAAGA,CAAAE,IAAI,UAAAG,OAAA,QAAK,EAAEH,IAAI,EAAEzC,KAAK,GAAA4C,OAAA,GAAEC,MAAA,CAAMf,IAAI,EAAEW,IAAI,CAAC,qBAAjBG,OAAA,CAAoBH,IAAI,CAAC,EAAE,EAAC;MACjE;IACF,KAAKlD,cAAc,CAACuD,GAAG;MACrBP,UAAU,GAAGA,CAAAE,IAAI,UAAAM,OAAA,QAAK,EAAEN,IAAI,EAAEzC,KAAK,GAAA+C,OAAA,GAAEC,MAAA,CAAMlB,IAAI,EAAEW,IAAI,CAAC,qBAAjBM,OAAA,CAAoBN,IAAI,CAAC,EAAE,EAAC;MACjE;IACF,KAAKlD,cAAc,CAAC0D,GAAG;MACrBV,UAAU,GAAGA,CAAAE,IAAI,MAAK,EAAEA,IAAI,EAAEzC,KAAK,EAAEkD,OAAA,CAAOpB,IAAI,EAAEW,IAAI,CAAC,EAAE,CAAC;MAC1D;IACF;MACEF,UAAU,GAAGA,CAAAE,IAAI,MAAK,EAAEA,IAAI,EAAEzC,KAAK,EAAEyC,IAAI,CAACU,WAAW,EAAE,EAAE,CAAC;MAC1D;;EAGJ,MAAMC,YAAY,GAAGjB,WAAW,CAACkB,GAAG,CAACd,UAAU,CAAC;EAEhD,OAAOe,QAAA,CACLF,YAAY,EACZ,CAAC,OAAO,CAAC,EACT,CAAClB,mBAAmB,GAAG,KAAK,GAAG,MAAM,CAAC,CACvC,CAACmB,GAAG,CAAC,CAAC,EAAEZ,IAAI,EAAE,KAAKA,IAAI,CAAC;AAC3B;AAEA,OAAM,SAAUc,QAAQA,CACtBzB,IAAkB,EAClBzB,kBAA4B,EAC5B0B,KAAa,EACbyB,eAA+B,EAC/BC,wBAAiC;EAEjC,MAAMC,UAAU,GAAG5B,IAAI,CAACuB,GAAG,CAAC,CAACM,GAAG,EAAEC,GAAG,KAAI;IACvC,IAAIC,OAAO,GAAoB,EAAE;IACjC,IAAIC,SAA6B;IACjC,IAAIC,OAAO,GAAG,CAAC;IACfjD,MAAM,CAACiD,OAAO,CAACJ,GAAG,CAAC,CAAChD,OAAO,CAAC,CAAC,CAAC0B,GAAG,EAAErC,KAAK,CAAC,KAAI;MAC3C,MAAMgE,cAAc,GAAGjE,SAAS,CAACC,KAAK,CAAC;MACvC,IAAIqC,GAAG,KAAKN,KAAK,EAAE;QACjB8B,OAAO,GAAG7D,KAAK;;MAEjB,IACEwD,eAAe,KAAKjE,cAAc,CAAC0E,IAAI;MACvC,OAAOjE,KAAK,KAAK,QAAQ,EACzB;QACA;;MAGF,IAAI,EAAEwD,eAAe,KAAKjE,cAAc,CAAC0D,GAAG,IAAI,CAACe,cAAc,CAAC,EAAE;QAChED,OAAO,IAAI,CAAC;;MAGd,QAAQP,eAAe;QACrB,KAAKjE,cAAc,CAAC0D,GAAG;QACvB,KAAK1D,cAAc,CAACiD,GAAG;UACrB,IAAIsB,SAAS,KAAK7D,SAAS,EAAE;YAC3B6D,SAAS,GAAG9D,KAAK;WAClB;UAAM;YACL8D,SAAS,IAAI9D,KAAK;;UAEpB;QACF,KAAKT,cAAc,CAACoD,GAAG;UACrBmB,SAAS;UACPA,SAAS,KAAK7D,SAAS,IAAK+D,cAAc,IAAIhE,KAAK,GAAG8D,SAAU;UAC5D9D,KAAK;UACL8D,SAAS;UACf;QACF,KAAKvE,cAAc,CAACuD,GAAG;UACrBgB,SAAS;UACPA,SAAS,KAAK7D,SAAS,IAAK+D,cAAc,IAAIhE,KAAK,GAAG8D,SAAU;UAC5D9D,KAAK;UACL8D,SAAS;UACf;QACF;UACE;;IAEN,CAAC,CAAC;IACF,IACEN,eAAe,KAAKjE,cAAc,CAAC0D,GAAG;IACtCc,OAAO,GAAG,CAAC;IACXD,SAAS,KAAK7D,SAAS,EACvB;MACA6D,SAAS,IAAIC,OAAO;;IAGtB,MAAM/D,KAAK,GACTwD,eAAe,KAAKjE,cAAc,CAAC0E,IAAI;IACnC,OAAOJ,OAAO,KAAK,QAAQ;IACzBA,OAAO,CAACV,WAAW,EAAE;IACrBU,OAAO;IACTC,SAAS;IAEf,OAAO;MACLzB,GAAG,EAAEwB,OAAO;MACZ7D,KAAK;MACL2D,GAAG;MACHO,iBAAiB,EAAE7D,kBAAkB,CAACuD,GAAG;KAC1C;EACH,CAAC,CAAC;EAEF,OAAON,QAAA,CACLI,UAAU,EACV,CAAC,OAAO,CAAC,EACT,CAACD,wBAAwB,GAAG,KAAK,GAAG,MAAM,CAAC,CAC5C,CAACJ,GAAG,CAAC,CAAC,EAAEM,GAAG,EAAEO,iBAAiB,EAAE,MAAM,EAAEP,GAAG,EAAEO,iBAAiB,EAAE,CAAC,CAAC;AACrE;AAEA,OAAM,SAAUC,aAAaA,CAC3BhE,IAAkB,EAClBC,IAAA,GAYI,EAAE;EAEN,MAAM,EACJgE,iBAAiB,EACjBrC,KAAK,GAAG9C,UAAU,EAClB+C,iBAAiB,GAAG,EAAE,EACtBqC,WAAW,GAAG,KAAK,EACnB9D,KAAK,GAAG,KAAK,EACbF,kBAAkB,GAAG,EAAE,EACvBkB,YAAY,GAAG,KAAK,EACpBU,cAAc,EACdC,mBAAmB,EACnBsB,eAAe,EACfC,wBAAwB,EACzB,GAAGrD,IAAI;EACR,IAAID,IAAI,CAACmE,MAAM,KAAK,CAAC;EAAE,OAAO,CAAC,EAAE,EAAE,EAAE,EAAErE,SAAS,CAAC;EACjD,MAAM6B,IAAI,GAAiB3B,IAAI,CAACkD,GAAG,CAAC,CAAAzC,KAAK,MAAK;IAC5C,GAAGA,KAAK;IACR,CAACmB,KAAK,GAAGnB,KAAK,CAACmB,KAAK;GACrB,CAAC,CAAC;EACH,MAAMwC,YAAY,GAAG1C,mBAAmB,CACtCC,IAAI,EACJC,KAAK,EACLC,iBAAiB,EACjBC,cAAc,EACdC,mBAAmB,CACpB;EACD,MAAMwB,UAAU,GACd3D,SAAS,CAACyD,eAAe,CAAC,IAAIzD,SAAS,CAAC0D,wBAAwB,CAAC;EAC7DF,QAAQ,CACNzB,IAAI,EACJzB,kBAAkB,EAClB0B,KAAK,EACLyB,eAAgB,EAChBC,wBAAyB,CAC1B;EACD3B,IAAI,CAACuB,GAAG,CAAC,CAACM,GAAG,EAAEC,GAAG,MAAM;IACtBD,GAAG;IACHO,iBAAiB,EAAE7D,kBAAkB,CAACuD,GAAG;GAC1C,CAAC,CAAC;EAET,IAAIY,gBAAoC;EACxC,MAAMC,WAAW,GAAGF,YAAY,CAAClB,GAAG,CAAC,CAAAZ,IAAI,MAAK;IAC5Cb,EAAE,EAAEa,IAAI;IACRA,IAAI;IACJtC,IAAI,EAAEuD,UAAU;IACbL,GAAG,CAAC,CAAC,EAAEM,GAAG,EAAEO,iBAAiB,EAAE,EAAEN,GAAG,KAAI,KAAAc,KAAA,EAAAC,MAAA;MACvC,MAAMC,YAAY,GAAGjB,GAAG,CAAClB,IAAI,CAAC;MAC9B,IACE,OAAOmC,YAAY,KAAK,QAAQ;MAChCA,YAAY,GAAG,CAAC;MACfJ,gBAAgB,KAAKvE,SAAS,IAAIuE,gBAAgB,GAAGI,YAAY,CAAC,EACnE;QACAJ,gBAAgB,GAAGI,YAAY;;MAEjC,MAAMC,oBAAoB,GACxB9E,SAAS,EAAA2E,KAAA,GAAC5C,IAAI,CAAC8B,GAAG,GAAG,CAAC,CAAC,qBAAbc,KAAA,CAAgBjC,IAAI,CAAC,CAAC,IAAI1C,SAAS,EAAA4E,MAAA,GAAC7C,IAAI,CAAC8B,GAAG,GAAG,CAAC,CAAC,qBAAbe,MAAA,CAAgBlC,IAAI,CAAC,CAAC;MACtE,MAAMqC,mBAAmB,GACvB,CAAC/E,SAAS,CAAC6E,YAAY,CAAC;MACxBC,oBAAoB;MACpBT,iBAAiB,KAAKnE,SAAS;MACjC,IAAID,KAAK,GAAgC4E,YAAY;MACrD,IAAIE,mBAAmB,EAAE;QACvB9E,KAAK,GAAGoE,iBAAiB;OAC1B;MAAM,IACL7D,KAAK,KAAKb,kBAAkB,CAACqF,MAAM;MACnCb,iBAAiB,KAAKjE,SAAS,EAC/B;QACAD,KAAK,GAAI,CAACA,KAAK,IAAI,CAAC,IAAekE,iBAAiB;;MAEtD,OAAO,CAACP,GAAG,CAAC5B,KAAK,CAAC,EAAE/B,KAAK,CAAC;IAC5B,CAAC,CAAC;IACDoC,MAAM,CAAC,CAAA4C,GAAG,KAAI,CAACX,WAAW,IAAKW,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,IAAK,CAAC;IACnE3B,GAAG,CAAC,CAAA2B,GAAG,KAAKzD,YAAY,GAAG,CAACyD,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGA,GAAI;GACtD,CAAC,CAAC;EACH,OAAO;EACLP,WAAW;EACXf,UAAU,CAACL,GAAG,CAAC,CAAC,EAAEa,iBAAiB,EAAE,KAAKA,iBAAiB,CAAC;EAC5DM,gBAAgB,CACjB;;AACH;AAEA,OAAM,SAAUS,gBAAgBA,CAC9BxC,IAAiC,EACjC,EACEyC,eAAe,EACfC,aAAa,EACbC,OAAO,KAKL,EAAE;EAEN,IAAI3C,IAAI,KAAKxC,SAAS,IAAIwC,IAAI,KAAK,IAAI,EAAE;IACvC,OAAOhD,WAAW;;EAEpB,IAAI,OAAOgD,IAAI,KAAK,SAAS,EAAE;IAC7B,OAAOA,IAAI,CAAC4C,QAAQ,EAAE;;EAExB,IAAI5C,IAAI,YAAY6C,IAAI,IAAIF,OAAO,KAAKjG,eAAe,CAACoG,QAAQ,EAAE;IAChE,MAAMC,cAAc,GAClB,OAAO/C,IAAI,KAAK,QAAQ,GAAGrD,kBAAkB,CAACqD,IAAI,CAAC,GAAGA,IAAI;IAC5D,MAAMgD,CAAC,GACLD,cAAc,YAAYF,IAAI;IAC1BE,cAAc;IACd,IAAIF,IAAI,CAACE,cAAc,CAAC;IAE9B,OAAOL,aAAa,GAAGA,aAAa,CAACM,CAAC,CAAC,GAAGA,CAAC,CAACC,WAAW,EAAE;;EAE3D,IAAI,OAAOjD,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAOyC,eAAe,GAAGA,eAAe,CAACzC,IAAI,CAAC,GAAGA,IAAI,CAAC4C,QAAQ,EAAE;;EAElE,OAAO5C,IAAI;AACb;AAEA,OAAO,MAAMkD,kBAAkB,GAAGA,CAAC,EACjCC,QAAQ,GAAG,EAAE,EACbC,QAAQ,GAAG,EAAE,EAC0C,KAIvDA,QAAQ,CAAC7E,MAAM,CACb,CAAC8E,WAAW,EAAEC,IAAI,EAAEC,KAAK,MAAM,EAAE,GAAGF,WAAW,EAAE,CAACC,IAAI,GAAGH,QAAQ,CAACI,KAAK,CAAC,EAAE,CAAC,EAC3E,EAAE,CACH;AAEH,OAAM,SAAUC,mBAAmBA,CAAC,EAClCrF,KAAK,GAAG,EAAE,EACVsF,OAAO,EACPhB,eAAe,EACfC,aAAa,EACbgB,cAAc,GAAG,EAAE,EAOpB;EACC,OAAOjH,aAAa,CAACgH,OAAO,CAAC;EAC1B7C,GAAG,CAAC,CAAA+C,GAAG,KACNnB,gBAAgB,CAACrE,KAAK,CAACwF,GAAG,CAAC,EAAE;IAC3BlB,eAAe;IACfC,aAAa;IACb,IAAIgB,cAAc,CAACC,GAAG,CAAC,IAAI,EAAEhB,OAAO,EAAEe,cAAc,CAACC,GAAG,CAAC,EAAE;GAC5D,CAAC,CACH;EACAC,IAAI,CAAC,IAAI,CAAC;AACf;AAEA,OAAM,SAAUC,cAAcA,CAC5BC,IAAgB,EAChBC,WAA8B,EAC9BC,IAAa,EACbC,KAAoB,EACpBC,QAAQ,GAAG,KAAK,EAChBjG,WAAyB;EAEzB,MAAMkG,MAAM,GAAoD;IAC9DC,MAAM,EAAE,CAAChH,iBAAiB,CAACiH,GAAG,EAAEjH,iBAAiB,CAACkH,MAAM,CAAC,CAACzE,QAAQ,CAChEkE,WAAW,CACZ;IACG,YAAY;IACZ,UAAU;IACdC,IAAI;IACJF,IAAI;IACJS,QAAQ,EAAEtG,WAAW;IACrBuG,QAAQ,EAAE,CAAC,KAAK,EAAE,SAAS,CAAC;IAC5BC,aAAa,EAAE;MACbC,UAAU,EAAET,KAAK,CAACU,UAAU,CAACC,QAAQ,CAACC,SAAS;MAC/CC,QAAQ,EAAEb,KAAK,CAACU,UAAU,CAACI,KAAK,CAACC,CAAC;MAClCC,KAAK,EAAEhB,KAAK,CAACiB,MAAM,CAACC,SAAS,CAACC,IAAI;MAClCC,WAAW,EAAEpB,KAAK,CAACiB,MAAM,CAACC,SAAS,CAACC;;GAEvC;EACD,QAAQrB,WAAW;IACjB,KAAK3G,iBAAiB,CAACkI,IAAI;MACzBnB,MAAM,CAACoB,IAAI,GAAG,CAAC;MACf;IACF,KAAKnI,iBAAiB,CAACoI,KAAK;MAC1BrB,MAAM,CAACsB,KAAK,GAAG,CAAC;MAChBtB,MAAM,CAACuB,GAAG,GAAGxB,QAAQ,GAAGhH,oBAAoB,CAACyI,oBAAoB,GAAG,CAAC;MACrE;IACF,KAAKvI,iBAAiB,CAACkH,MAAM;MAC3BH,MAAM,CAACyB,MAAM,GAAG,CAAC;MACjB;IACF,KAAKxI,iBAAiB,CAACiH,GAAG;IAC1B;MACEF,MAAM,CAACuB,GAAG,GAAG,CAAC;MACdvB,MAAM,CAACsB,KAAK,GAAGvB,QAAQ,GAAGhH,oBAAoB,CAAC2I,oBAAoB,GAAG,CAAC;MACvE;;EAEJ,OAAO1B,MAAM;AACf;AAEA,OAAM,SAAU2B,eAAeA,CAC7B9B,IAAa,EACbD,WAA8B,EAC9BgC,MAA+B,EAC/BC,OAA0E,EAC1ElH,YAAsB;EAOtB,IAAImH,YAAY;EAChB,IAAI,CAACjC,IAAI,EAAE;IACTiC,YAAY,GAAG,CAAC;GACjB;EAAM,IACLF,MAAM,KAAK,IAAI;EACfA,MAAM,KAAKvI,SAAS;EACpB,OAAOuI,MAAM,KAAK,QAAQ,EAC1B;IACAE,YAAY,GAAG5I,oBAAoB,CAAC0G,WAAW,CAAC;GACjD;EAAM;IACLkC,YAAY,GAAGF,MAAM;;EAGvB,MAAM,EAAEH,MAAM,GAAG,CAAC,EAAEL,IAAI,GAAG,CAAC,EAAEE,KAAK,GAAG,CAAC,EAAEC,GAAG,GAAG,CAAC,EAAE,GAAGM,OAAO,IAAI,EAAE;EAElE,IAAIlH,YAAY,EAAE;IAChB,OAAO;MACLyG,IAAI,EACFA,IAAI,IAAIxB,WAAW,KAAK3G,iBAAiB,CAACkH,MAAM,GAAG2B,YAAY,GAAG,CAAC,CAAC;MACtER,KAAK,EACHA,KAAK,IAAI1B,WAAW,KAAK3G,iBAAiB,CAACoI,KAAK,GAAGS,YAAY,GAAG,CAAC,CAAC;MACtEP,GAAG,EAAEA,GAAG,IAAI3B,WAAW,KAAK3G,iBAAiB,CAACiH,GAAG,GAAG4B,YAAY,GAAG,CAAC,CAAC;MACrEL,MAAM,EACJA,MAAM,IAAI7B,WAAW,KAAK3G,iBAAiB,CAACkI,IAAI,GAAGW,YAAY,GAAG,CAAC;KACtE;;EAGH,OAAO;IACLV,IAAI,EAAEA,IAAI,IAAIxB,WAAW,KAAK3G,iBAAiB,CAACkI,IAAI,GAAGW,YAAY,GAAG,CAAC,CAAC;IACxER,KAAK,EAAEA,KAAK,IAAI1B,WAAW,KAAK3G,iBAAiB,CAACoI,KAAK,GAAGS,YAAY,GAAG,CAAC,CAAC;IAC3EP,GAAG,EAAEA,GAAG,IAAI3B,WAAW,KAAK3G,iBAAiB,CAACiH,GAAG,GAAG4B,YAAY,GAAG,CAAC,CAAC;IACrEL,MAAM,EACJA,MAAM,IAAI7B,WAAW,KAAK3G,iBAAiB,CAACkH,MAAM,GAAG2B,YAAY,GAAG,CAAC;GACxE;AACH;AAEA,OAAM,SAAUC,WAAWA,CAACtH,MAAsB;EAChD,MAAMuH,OAAO,GAAG,IAAIC,GAAG,EAAkB;EACzC,OAAOxH,MAAM,CAACgC,GAAG,CAAC,CAAAM,GAAG,KAAG;IACtB,IAAI,EAAE/B,EAAE,EAAE,GAAG+B,GAAG;IAChB,IAAI/B,EAAE,KAAK3B,SAAS;IAAE,OAAO0D,GAAG;IAChC/B,EAAE,GAAGkH,MAAM,CAAClH,EAAE,CAAC;IACf,MAAMmH,KAAK,GAAGH,OAAO,CAACI,GAAG,CAACpH,EAAE,CAAC,IAAI,CAAC;IAClC,MAAMqH,MAAM,GAAGF,KAAK,GAAG,CAAC,GAAG,KAAKA,KAAK,GAAG,GAAG,EAAE;IAC7CH,OAAO,CAACM,GAAG,CAACtH,EAAE,EAAEmH,KAAK,GAAG,CAAC,CAAC;IAC1B,OAAO;MACL,GAAGpF,GAAG;MACN/B,EAAE,EAAE,GAAGA,EAAE,GAAGqH,MAAM;KACnB;EACH,CAAC,CAAC;AACJ;AAEA,OAAM,SAAUE,YAAYA,CAACC,IAAY;EACvC,OAAO5J,MAAM,CAAC6J,UAAU,CAACD,IAAI,CAAC;AAChC;AAEA,OAAM,SAAUE,WAAWA,CACzB/I,KAAgB,EAChBgJ,gBAA0B,EAC1BC,QAA0B;EAE1B,IAAID,gBAAgB,EAAE;IACpB,OAAOvK,QAAQ,CAACyK,QAAQ;;EAE1B,IAAID,QAAQ,KAAKrK,eAAe,CAACoG,QAAQ,EAAE;IACzC,OAAOvG,QAAQ,CAAC0K,IAAI;;EAEtB,IAAIF,QAAQ,KAAKrK,eAAe,CAACwK,OAAO,IAAI,CAACpJ,KAAK,EAAE;IAClD,OAAOvB,QAAQ,CAAC4K,KAAK;;EAEvB,OAAO5K,QAAQ,CAACyK,QAAQ;AAC1B;AAEA,OAAM,SAAUI,yBAAyBA,CACvCC,MAAA,GAGI,EAAE;EAEN,MAAM,EAAEC,GAAG,EAAEC,SAAS,EAAE,GAAGF,MAAM;EACjC;EACA,MAAMG,mBAAmB,GAAG,CAAC,CAACF,GAAG,IAAIA,GAAG,KAAK,CAAC;EAE9C,OAAO,IAAIzK,eAAe,CAAC;IACzB4K,UAAU,EAAEA,CAAAlK,KAAK,KACf,GACEiK,mBAAmB,IAAIjK,KAAK,GAAG+J,GAAG;IAC9B,EAAE;IACF,CAAAC,SAAS,oBAATA,SAAS,CAAExK,MAAM,CAACQ,KAAK,CAAC,KAAIA,KAClC,EAAE;IACJ4B,EAAE,EAAEvC,aAAa,CAAC8K;GACnB,CAAC;AACJ;AAEA,OAAM,SAAUC,qBAAqBA,CAAC5F,gBAAwB;EAC5D,MAAM6F,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,KAAK,CAAChG,gBAAgB,CAAC,CAAC;EAC1D,OAAO8F,IAAI,CAACG,GAAG,CAAC,EAAE,EAAEJ,SAAS,CAAC;AAChC;AAQA,OAAM,SAAUK,sBAAsBA,CACpCC,QAAkB,EAClBC,YAAqB,EACrBC,GAAY,EACZd,GAAY,EACZe,UAAwC;EAExC,IAAIH,QAAQ,KAAK3L,QAAQ,CAAC4K,KAAK,IAAIgB,YAAY,EAAE;IAC/C,MAAMG,GAAG,GAAe,EAAE;IAC1B,IAAID,UAAU,KAAKlL,2BAA2B,CAACoL,GAAG,EAAE;MAClDD,GAAG,CAACE,KAAK,GAAG,IAAI;;IAElB,IAAIJ,GAAG,KAAK5K,SAAS,EAAE;MACrB8K,GAAG,CAACF,GAAG,GAAGA,GAAG;KACd;IAAM,IAAIC,UAAU,KAAKlL,2BAA2B,CAACoL,GAAG,EAAE;MACzDD,GAAG,CAACF,GAAG,GAAG,SAAS;;IAErB,IAAId,GAAG,KAAK9J,SAAS,EAAE;MACrB8K,GAAG,CAAChB,GAAG,GAAGA,GAAG;KACd;IAAM,IAAIe,UAAU,KAAKlL,2BAA2B,CAACoL,GAAG,EAAE;MACzDD,GAAG,CAAChB,GAAG,GAAG,SAAS;;IAErB,OAAOgB,GAAG;;EAEZ,OAAO,EAAE;AACX;AAEA;;;;;;;;;;;;AAYA,OAAM,SAAUG,qBAAqBA,CACnCC,SAAiB,EACjBC,WAAqB,EACrB3I,IAAsB;EAEtB,IAAI4I,QAAA,CAAQD,WAAW,CAAC,EAAE;IACxB,OAAOD,SAAS;;EAElB;EACA,OACEC,WAAW,CAACE,IAAI,CAAC,CAAAtL,KAAK,KAAG;IACvB,IAAI,OAAOyC,IAAI,KAAK,QAAQ,EAAE;MAC5B;MACA,OACEA,IAAI,CAACH,QAAQ,CAAC,GAAGtC,KAAK,GAAG,CAAC;MAC1B;MACAyC,IAAI,CAACH,QAAQ,CAAC,KAAKtC,KAAK,EAAE,CAAC;;IAG/B,OAAOyC,IAAI,oBAAJA,IAAI,CAAE4C,QAAQ,EAAE,CAAC/C,QAAQ,CAACtC,KAAK,CAAC;EACzC,CAAC,CAAC,IAAImL,SAAS;AAEnB,CAAC,mBAAAI,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAxL,SAAA,MAAAsL,cAAA,WAAAA,cAAA,CAAAG,QAAA,CA9kBQ3L,SAAS,0HAAAwL,cAAA,CAAAG,QAAA,CAIFxL,sBAAsB,uIAAAqL,cAAA,CAAAG,QAAA,CAqCtBtK,uBAAuB,wIAAAmK,cAAA,CAAAG,QAAA,CAsCvB7J,mBAAmB,oIAAA0J,cAAA,CAAAG,QAAA,CAwCnBnI,QAAQ,yHAAAgI,cAAA,CAAAG,QAAA,CAkFRvH,aAAa,8HAAAoH,cAAA,CAAAG,QAAA,CAgGbzG,gBAAgB,iIAAAsG,cAAA,CAAAG,QAAA,CAkCnB/F,kBAAkB,mIAAA4F,cAAA,CAAAG,QAAA,CAYfzF,mBAAmB,oIAAAsF,cAAA,CAAAG,QAAA,CAwBnBpF,cAAc,+HAAAiF,cAAA,CAAAG,QAAA,CA6CdnD,eAAe,gIAAAgD,cAAA,CAAAG,QAAA,CAgDf/C,WAAW,4HAAA4C,cAAA,CAAAG,QAAA,CAgBXvC,YAAY,6HAAAoC,cAAA,CAAAG,QAAA,CAIZpC,WAAW,4HAAAiC,cAAA,CAAAG,QAAA,CAiBX7B,yBAAyB,0IAAA0B,cAAA,CAAAG,QAAA,CAqBzBtB,qBAAqB,sIAAAmB,cAAA,CAAAG,QAAA,CAWrBhB,sBAAsB,uIAAAa,cAAA,CAAAG,QAAA,CAuCtBR,qBAAqB,8JAAAS,WAAA,UAAAH,oBAAA,mBAAAA,oBAAA,CAAAG,WAAA,GAAA1L,SAAA,CAAA0L,WAAA,IAAAA,WAAA,CAAAC,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}