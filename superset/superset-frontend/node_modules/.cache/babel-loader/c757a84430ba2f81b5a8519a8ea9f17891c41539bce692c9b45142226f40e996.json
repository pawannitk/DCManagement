{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useLayoutEffect, useRef, useState } from 'react';\n/**\n * This hook encapsulates logic to support truncation of child HTML\n * elements contained in a fixed-width parent HTML element.  Given\n * a ref to the parent element and optionally a ref to the \"+x\"\n * component that shows the number of truncated items, this hook\n * will return the number of elements that are not fully visible\n * (including those completely hidden) and whether any elements\n * are completely hidden.\n */\nconst useChildElementTruncation = () => {\n  const [elementsTruncated, setElementsTruncated] = useState(0);\n  const [hasHiddenElements, setHasHiddenElements] = useState(false);\n  const elementRef = useRef(null);\n  const plusRef = useRef(null);\n  useLayoutEffect(() => {var _elementRef$current;\n    const onResize = () => {\n      const currentElement = elementRef.current;\n      if (!currentElement) {\n        return;\n      }\n      const plusRefElement = plusRef.current;\n      const { scrollWidth, clientWidth, childNodes } = currentElement;\n      if (scrollWidth > clientWidth) {\n        // \"...\" is around 6px wide\n        const truncationWidth = 6;\n        const plusSize = (plusRefElement == null ? void 0 : plusRefElement.offsetWidth) || 0;\n        const maxWidth = clientWidth - truncationWidth;\n        const elementsCount = childNodes.length;\n        let width = 0;\n        let hiddenElements = 0;\n        for (let i = 0; i < elementsCount; i += 1) {\n          const itemWidth = childNodes[i].offsetWidth;\n          const remainingWidth = maxWidth - width - plusSize;\n          // assures it shows +{number} only when the item is not visible\n          if (remainingWidth <= 0) {\n            hiddenElements += 1;\n          }\n          width += itemWidth;\n        }\n        if (elementsCount > 1 && hiddenElements) {\n          setHasHiddenElements(true);\n          setElementsTruncated(hiddenElements);\n        } else\n        {\n          setHasHiddenElements(false);\n          setElementsTruncated(1);\n        }\n      } else\n      {\n        setHasHiddenElements(false);\n        setElementsTruncated(0);\n      }\n    };\n    const obs = new ResizeObserver(onResize);\n    const element = (_elementRef$current = elementRef.current) == null ? void 0 : _elementRef$current.parentElement;\n    if (element) {\n      obs.observe(element);\n    }\n    onResize();\n    return () => {\n      obs.disconnect();\n    };\n  }, [plusRef.current]); // plus is rendered dynamically - the component rerenders the hook when plus appears, this makes sure that useLayoutEffect is rerun\n  return [elementRef, plusRef, elementsTruncated, hasHiddenElements];\n};__signature__(useChildElementTruncation, \"useState{[elementsTruncated, setElementsTruncated](0)}\\nuseState{[hasHiddenElements, setHasHiddenElements](false)}\\nuseRef{elementRef}\\nuseRef{plusRef}\\nuseLayoutEffect{}\");const _default =\nuseChildElementTruncation;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(useChildElementTruncation, \"useChildElementTruncation\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/hooks/useTruncation/useChildElementTruncation.ts\");reactHotLoader.register(_default, \"default\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/hooks/useTruncation/useChildElementTruncation.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["useLayoutEffect","useRef","useState","useChildElementTruncation","elementsTruncated","setElementsTruncated","hasHiddenElements","setHasHiddenElements","elementRef","plusRef","_elementRef$current","onResize","currentElement","current","plusRefElement","scrollWidth","clientWidth","childNodes","truncationWidth","plusSize","offsetWidth","maxWidth","elementsCount","length","width","hiddenElements","i","itemWidth","remainingWidth","obs","ResizeObserver","element","parentElement","observe","disconnect","__signature__","_default","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/hooks/useTruncation/useChildElementTruncation.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useLayoutEffect, useRef, useState } from 'react';\n\n/**\n * This hook encapsulates logic to support truncation of child HTML\n * elements contained in a fixed-width parent HTML element.  Given\n * a ref to the parent element and optionally a ref to the \"+x\"\n * component that shows the number of truncated items, this hook\n * will return the number of elements that are not fully visible\n * (including those completely hidden) and whether any elements\n * are completely hidden.\n */\nconst useChildElementTruncation = () => {\n  const [elementsTruncated, setElementsTruncated] = useState(0);\n  const [hasHiddenElements, setHasHiddenElements] = useState(false);\n  const elementRef = useRef<HTMLDivElement>(null);\n  const plusRef = useRef<HTMLDivElement>(null);\n\n  useLayoutEffect(() => {\n    const onResize = () => {\n      const currentElement = elementRef.current;\n      if (!currentElement) {\n        return;\n      }\n      const plusRefElement = plusRef.current;\n      const { scrollWidth, clientWidth, childNodes } = currentElement;\n\n      if (scrollWidth > clientWidth) {\n        // \"...\" is around 6px wide\n        const truncationWidth = 6;\n        const plusSize = plusRefElement?.offsetWidth || 0;\n        const maxWidth = clientWidth - truncationWidth;\n        const elementsCount = childNodes.length;\n\n        let width = 0;\n        let hiddenElements = 0;\n        for (let i = 0; i < elementsCount; i += 1) {\n          const itemWidth = (childNodes[i] as HTMLElement).offsetWidth;\n          const remainingWidth = maxWidth - width - plusSize;\n\n          // assures it shows +{number} only when the item is not visible\n          if (remainingWidth <= 0) {\n            hiddenElements += 1;\n          }\n          width += itemWidth;\n        }\n\n        if (elementsCount > 1 && hiddenElements) {\n          setHasHiddenElements(true);\n          setElementsTruncated(hiddenElements);\n        } else {\n          setHasHiddenElements(false);\n          setElementsTruncated(1);\n        }\n      } else {\n        setHasHiddenElements(false);\n        setElementsTruncated(0);\n      }\n    };\n    const obs = new ResizeObserver(onResize);\n\n    const element = elementRef.current?.parentElement;\n    if (element) {\n      obs.observe(element);\n    }\n\n    onResize();\n\n    return () => {\n      obs.disconnect();\n    };\n  }, [plusRef.current]); // plus is rendered dynamically - the component rerenders the hook when plus appears, this makes sure that useLayoutEffect is rerun\n\n  return [elementRef, plusRef, elementsTruncated, hasHiddenElements] as const;\n};\n\nexport default useChildElementTruncation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}