{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport { SupersetClient } from '../../../connection';\nimport handleError from './handleError';\nconst validRequestTypes = new Set(['form', 'json', 'search', 'rison']);\nfunction isPayloadless(method) {\n  return !method || method === 'GET' || method === 'DELETE' || method === 'HEAD';\n}\n/**\n * Generate an API caller with predefined configs/typing and consistent\n * return values.\n */\nexport default function makeApi(options) {\n  const { endpoint, method, requestType: requestType_, responseType, processResponse, ...requestOptions } = options;\n  // use `search` payload (searchParams) when it's a GET request\n  const requestType = requestType_ || (isPayloadless(method) ? 'search' : 'json');\n  if (!validRequestTypes.has(requestType)) {\n    throw new Error(`Invalid request payload type, choose from: ${[...validRequestTypes].join(' | ')}`);\n  }\n  async function request(payload, { client = SupersetClient } = {\n    client: SupersetClient\n  }) {\n    try {\n      const requestConfig = {\n        ...requestOptions,\n        method,\n        endpoint,\n        searchParams: undefined,\n        postPayload: undefined,\n        jsonPayload: undefined\n      };\n      if (requestType === 'search') {\n        requestConfig.searchParams = payload;\n      } else\n      if (requestType === 'rison') {\n        requestConfig.endpoint = `${endpoint}?q=${rison.encode(payload)}`;\n      } else\n      if (requestType === 'form') {\n        requestConfig.postPayload = payload;\n      } else\n      {\n        requestConfig.jsonPayload = payload;\n      }\n      let result;\n      const response = await client.request({\n        ...requestConfig,\n        parseMethod: 'raw'\n      });\n      if (responseType === 'text') {\n        result = await response.text();\n      } else\n      if (responseType === 'raw' || responseType === null) {\n        result = response;\n      } else\n      {\n        result = await response.json();\n        // if response json has an \"error\" field\n        if (result && typeof result === 'object' && 'error' in result) {\n          return handleError(result);\n        }\n      }\n      const typedResult = result;\n      return processResponse ? processResponse(typedResult) : typedResult;\n    }\n    catch (error) {\n      return handleError(error);\n    }\n  }\n  request.method = method;\n  request.endpoint = endpoint;\n  request.requestType = requestType;\n  return request;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(validRequestTypes, \"validRequestTypes\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/query/api/v1/makeApi.ts\");reactHotLoader.register(isPayloadless, \"isPayloadless\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/query/api/v1/makeApi.ts\");reactHotLoader.register(makeApi, \"makeApi\", \"/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/query/api/v1/makeApi.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["rison","SupersetClient","handleError","validRequestTypes","Set","isPayloadless","method","makeApi","options","endpoint","requestType","requestType_","responseType","processResponse","requestOptions","has","Error","join","request","payload","client","requestConfig","searchParams","undefined","postPayload","jsonPayload","encode","result","response","parseMethod","text","json","typedResult","error","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/packages/superset-ui-core/src/query/api/v1/makeApi.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport {\n  SupersetClient,\n  Payload as SupersetPayload,\n  JsonObject,\n  JsonValue,\n  ParseMethod,\n  Endpoint,\n  Method,\n  RequestBase,\n} from '../../../connection';\nimport handleError, { ErrorInput } from './handleError';\nimport {\n  SupersetApiRequestOptions,\n  SupersetApiErrorPayload,\n  ParsedResponseType,\n} from './types';\n\nconst validRequestTypes = new Set(['form', 'json', 'search', 'rison']);\n\ninterface SupersetApiFactoryOptions extends Omit<RequestBase, 'url'> {\n  /**\n   * API endpoint, must be relative.\n   */\n  endpoint: Endpoint;\n  /**\n   * Request method: 'GET' | 'POST' | 'DELETE' | 'PUT' | ...\n   */\n  method: Method;\n  /**\n   * How to send the payload:\n   *  - form: set request.body as FormData\n   *  - json: as JSON string with request Content-Type header set to application/json\n   *  - search: add to search params\n   */\n  requestType?: 'form' | 'json' | 'search' | 'rison';\n}\n\nfunction isPayloadless(method?: Method) {\n  return (\n    !method || method === 'GET' || method === 'DELETE' || method === 'HEAD'\n  );\n}\n\n/**\n * Generate an API caller with predefined configs/typing and consistent\n * return values.\n */\nexport default function makeApi<\n  Payload = SupersetPayload,\n  Result = JsonObject,\n  T extends ParseMethod = ParseMethod,\n>(\n  options: SupersetApiFactoryOptions & {\n    /**\n     * How to parse response, choose from: 'json' | 'text' | 'raw'.\n     */\n    responseType?: T;\n    /**\n     * Further process parsed response\n     */\n    processResponse?(result: ParsedResponseType<T>): Result;\n  },\n) {\n  const {\n    endpoint,\n    method,\n    requestType: requestType_,\n    responseType,\n    processResponse,\n    ...requestOptions\n  } = options;\n  // use `search` payload (searchParams) when it's a GET request\n  const requestType =\n    requestType_ || (isPayloadless(method) ? 'search' : 'json');\n  if (!validRequestTypes.has(requestType)) {\n    throw new Error(\n      `Invalid request payload type, choose from: ${[...validRequestTypes].join(\n        ' | ',\n      )}`,\n    );\n  }\n\n  async function request(\n    payload: Payload,\n    { client = SupersetClient }: SupersetApiRequestOptions = {\n      client: SupersetClient,\n    },\n  ): Promise<Result> {\n    try {\n      const requestConfig = {\n        ...requestOptions,\n        method,\n        endpoint,\n        searchParams: undefined as URLSearchParams | undefined,\n        postPayload: undefined as FormData | undefined,\n        jsonPayload: undefined as JsonObject | undefined,\n      };\n      if (requestType === 'search') {\n        requestConfig.searchParams = payload as unknown as URLSearchParams;\n      } else if (requestType === 'rison') {\n        requestConfig.endpoint = `${endpoint}?q=${rison.encode(payload)}`;\n      } else if (requestType === 'form') {\n        requestConfig.postPayload = payload as unknown as FormData;\n      } else {\n        requestConfig.jsonPayload = payload as JsonObject;\n      }\n\n      let result: JsonValue | Response;\n      const response = await client.request({\n        ...requestConfig,\n        parseMethod: 'raw',\n      });\n\n      if (responseType === 'text') {\n        result = await response.text();\n      } else if (responseType === 'raw' || responseType === null) {\n        result = response;\n      } else {\n        result = await response.json();\n        // if response json has an \"error\" field\n        if (result && typeof result === 'object' && 'error' in result) {\n          return handleError(result as SupersetApiErrorPayload);\n        }\n      }\n      const typedResult = result as ParsedResponseType<T>;\n      return (\n        processResponse ? processResponse(typedResult) : typedResult\n      ) as Result;\n    } catch (error) {\n      return handleError(error as ErrorInput);\n    }\n  }\n\n  request.method = method;\n  request.endpoint = endpoint;\n  request.requestType = requestType;\n\n  return request;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}