{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels'\n};\n\nclass MapBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom\n      }\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n    viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = width * 0.5 / 100;\n    const offsetVertical = height * 0.5 / 100;\n    const bbox = [\n    bounds[0][0] - offsetHorizontal,\n    bounds[0][1] - offsetVertical,\n    bounds[1][0] + offsetHorizontal,\n    bounds[1][1] + offsetVertical];\n\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      ___EmotionJSX(MapGL, _extends({},\n      viewport, {\n        mapStyle: mapStyle,\n        width: width,\n        height: height,\n        mapboxApiAccessToken: mapboxApiKey,\n        onViewportChange: this.handleViewportChange,\n        preserveDrawingBuffer: true }),\n\n      ___EmotionJSX(ScatterPlotGlowOverlay, _extends({},\n      viewport, {\n        isDragging: isDragging,\n        locations: clusters,\n        dotRadius: pointRadius,\n        pointRadiusUnit: pointRadiusUnit,\n        rgb: rgb,\n        globalOpacity: globalOpacity,\n        compositeOperation: \"screen\",\n        renderWhileDragging: renderWhileDragging,\n        aggregation: hasCustomMetric ? aggregatorName : null,\n        lngLatAccessor: (location) => {\n          const { coordinates } = location.geometry;\n\n          return [coordinates[0], coordinates[1]];\n        } })\n      )\n      ));\n\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;const _default =\n\nMapBox;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(NOOP, \"NOOP\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(DEFAULT_MAX_ZOOM, \"DEFAULT_MAX_ZOOM\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(DEFAULT_POINT_RADIUS, \"DEFAULT_POINT_RADIUS\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(propTypes, \"propTypes\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(defaultProps, \"defaultProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(MapBox, \"MapBox\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(_default, \"default\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["React","PropTypes","MapGL","ViewportMercator","ScatterPlotGlowOverlay","jsx","___EmotionJSX","NOOP","DEFAULT_MAX_ZOOM","DEFAULT_POINT_RADIUS","propTypes","width","number","height","aggregatorName","string","clusterer","object","globalOpacity","hasCustomMetric","bool","mapStyle","mapboxApiKey","isRequired","onViewportChange","func","pointRadius","pointRadiusUnit","renderWhileDragging","rgb","array","bounds","defaultProps","MapBox","Component","constructor","props","mercator","fitBounds","latitude","longitude","zoom","state","viewport","handleViewportChange","bind","setState","render","isDragging","undefined","offsetHorizontal","offsetVertical","bbox","clusters","getClusters","Math","round","_extends","mapboxApiAccessToken","preserveDrawingBuffer","locations","dotRadius","compositeOperation","aggregation","lngLatAccessor","location","coordinates","geometry","__reactstandin__regenerateByEval","key","code","eval","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array,\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels',\n};\n\nclass MapBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height,\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom,\n      },\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds,\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n      viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = (width * 0.5) / 100;\n    const offsetVertical = (height * 0.5) / 100;\n    const bbox = [\n      bounds[0][0] - offsetHorizontal,\n      bounds[0][1] - offsetVertical,\n      bounds[1][0] + offsetHorizontal,\n      bounds[1][1] + offsetVertical,\n    ];\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      <MapGL\n        {...viewport}\n        mapStyle={mapStyle}\n        width={width}\n        height={height}\n        mapboxApiAccessToken={mapboxApiKey}\n        onViewportChange={this.handleViewportChange}\n        preserveDrawingBuffer\n      >\n        <ScatterPlotGlowOverlay\n          {...viewport}\n          isDragging={isDragging}\n          locations={clusters}\n          dotRadius={pointRadius}\n          pointRadiusUnit={pointRadiusUnit}\n          rgb={rgb}\n          globalOpacity={globalOpacity}\n          compositeOperation=\"screen\"\n          renderWhileDragging={renderWhileDragging}\n          aggregation={hasCustomMetric ? aggregatorName : null}\n          lngLatAccessor={location => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          }}\n        />\n      </MapGL>\n    );\n  }\n}\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;\n"],"mappings":"sWAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,SAAS,MAAM,YAAY;AAClC,OAAOC,KAAK,MAAM,cAAc;AAChC,OAAOC,gBAAgB,MAAM,2BAA2B;AACxD,OAAOC,sBAAsB,MAAM,0BAA0B;AAC7D,OAAO,cAAc,CAAC,SAAAC,GAAA,IAAAC,aAAA;;AAEtB,MAAMC,IAAI,GAAGA,CAAA,KAAM,CAAC,CAAC;AACrB,OAAO,MAAMC,gBAAgB,GAAG,EAAE;AAClC,OAAO,MAAMC,oBAAoB,GAAG,EAAE;;AAEtC,MAAMC,SAAS,GAAG;EAChBC,KAAK,EAAEV,SAAS,CAACW,MAAM;EACvBC,MAAM,EAAEZ,SAAS,CAACW,MAAM;EACxBE,cAAc,EAAEb,SAAS,CAACc,MAAM;EAChCC,SAAS,EAAEf,SAAS,CAACgB,MAAM;EAC3BC,aAAa,EAAEjB,SAAS,CAACW,MAAM;EAC/BO,eAAe,EAAElB,SAAS,CAACmB,IAAI;EAC/BC,QAAQ,EAAEpB,SAAS,CAACc,MAAM;EAC1BO,YAAY,EAAErB,SAAS,CAACc,MAAM,CAACQ,UAAU;EACzCC,gBAAgB,EAAEvB,SAAS,CAACwB,IAAI;EAChCC,WAAW,EAAEzB,SAAS,CAACW,MAAM;EAC7Be,eAAe,EAAE1B,SAAS,CAACc,MAAM;EACjCa,mBAAmB,EAAE3B,SAAS,CAACmB,IAAI;EACnCS,GAAG,EAAE5B,SAAS,CAAC6B,KAAK;EACpBC,MAAM,EAAE9B,SAAS,CAAC6B;AACpB,CAAC;;AAED,MAAME,YAAY,GAAG;EACnBrB,KAAK,EAAE,GAAG;EACVE,MAAM,EAAE,GAAG;EACXK,aAAa,EAAE,CAAC;EAChBM,gBAAgB,EAAEjB,IAAI;EACtBmB,WAAW,EAAEjB,oBAAoB;EACjCkB,eAAe,EAAE;AACnB,CAAC;;AAED,MAAMM,MAAM,SAASjC,KAAK,CAACkC,SAAS,CAAC;EACnCC,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;;IAEZ,MAAM,EAAEzB,KAAK,EAAEE,MAAM,EAAEkB,MAAM,CAAC,CAAC,GAAG,IAAI,CAACK,KAAK;IAC5C;IACA;IACA;IACA,MAAMC,QAAQ,GAAG,IAAIlC,gBAAgB,CAAC;MACpCQ,KAAK;MACLE;IACF,CAAC,CAAC,CAACyB,SAAS,CAACP,MAAM,CAAC;IACpB,MAAM,EAAEQ,QAAQ,EAAEC,SAAS,EAAEC,IAAI,CAAC,CAAC,GAAGJ,QAAQ;;IAE9C,IAAI,CAACK,KAAK,GAAG;MACXC,QAAQ,EAAE;QACRH,SAAS;QACTD,QAAQ;QACRE;MACF;IACF,CAAC;IACD,IAAI,CAACG,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACC,IAAI,CAAC,IAAI,CAAC;EAClE;;EAEAD,oBAAoBA,CAACD,QAAQ,EAAE;IAC7B,IAAI,CAACG,QAAQ,CAAC,EAAEH,QAAQ,CAAC,CAAC,CAAC;IAC3B,MAAM,EAAEnB,gBAAgB,CAAC,CAAC,GAAG,IAAI,CAACY,KAAK;IACvCZ,gBAAgB,CAACmB,QAAQ,CAAC;EAC5B;;EAEAI,MAAMA,CAAA,EAAG;IACP,MAAM;MACJpC,KAAK;MACLE,MAAM;MACNC,cAAc;MACdE,SAAS;MACTE,aAAa;MACbG,QAAQ;MACRC,YAAY;MACZI,WAAW;MACXC,eAAe;MACfC,mBAAmB;MACnBC,GAAG;MACHV,eAAe;MACfY;IACF,CAAC,GAAG,IAAI,CAACK,KAAK;IACd,MAAM,EAAEO,QAAQ,CAAC,CAAC,GAAG,IAAI,CAACD,KAAK;IAC/B,MAAMM,UAAU;IACdL,QAAQ,CAACK,UAAU,KAAKC,SAAS,GAAG,KAAK,GAAGN,QAAQ,CAACK,UAAU;;IAEjE;IACA;IACA;IACA;IACA,MAAME,gBAAgB,GAAIvC,KAAK,GAAG,GAAG,GAAI,GAAG;IAC5C,MAAMwC,cAAc,GAAItC,MAAM,GAAG,GAAG,GAAI,GAAG;IAC3C,MAAMuC,IAAI,GAAG;IACXrB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGmB,gBAAgB;IAC/BnB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGoB,cAAc;IAC7BpB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGmB,gBAAgB;IAC/BnB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGoB,cAAc,CAC9B;;IACD,MAAME,QAAQ,GAAGrC,SAAS,CAACsC,WAAW,CAACF,IAAI,EAAEG,IAAI,CAACC,KAAK,CAACb,QAAQ,CAACF,IAAI,CAAC,CAAC;;IAEvE;MACEnC,aAAA,CAACJ,KAAK,EAAAuD,QAAA;MACAd,QAAQ;QACZtB,QAAQ,EAAEA,QAAS;QACnBV,KAAK,EAAEA,KAAM;QACbE,MAAM,EAAEA,MAAO;QACf6C,oBAAoB,EAAEpC,YAAa;QACnCE,gBAAgB,EAAE,IAAI,CAACoB,oBAAqB;QAC5Ce,qBAAqB;;MAErBrD,aAAA,CAACF,sBAAsB,EAAAqD,QAAA;MACjBd,QAAQ;QACZK,UAAU,EAAEA,UAAW;QACvBY,SAAS,EAAEP,QAAS;QACpBQ,SAAS,EAAEnC,WAAY;QACvBC,eAAe,EAAEA,eAAgB;QACjCE,GAAG,EAAEA,GAAI;QACTX,aAAa,EAAEA,aAAc;QAC7B4C,kBAAkB,EAAC,QAAQ;QAC3BlC,mBAAmB,EAAEA,mBAAoB;QACzCmC,WAAW,EAAE5C,eAAe,GAAGL,cAAc,GAAG,IAAK;QACrDkD,cAAc,EAAEA,CAAAC,QAAQ,KAAI;UAC1B,MAAM,EAAEC,WAAW,CAAC,CAAC,GAAGD,QAAQ,CAACE,QAAQ;;UAEzC,OAAO,CAACD,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;QACzC,CAAE;MACH;MACI,CAAC;;EAEZ,CAAC;EAAAE,iCAAAC,GAAA,EAAAC,IAAA;IAAA,KAAAD,GAAA,IAAAE,IAAA,CAAAD,IAAA,GACH;AAEArC,MAAM,CAACvB,SAAS,GAAGA,SAAS;AAC5BuB,MAAM,CAACD,YAAY,GAAGA,YAAY,CAAC,MAAAwC,QAAA;;AAEpBvC,MAAM,CAArB,eAAAuC,QAAA,CAAsB,mBAAAC,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAA1B,SAAA,MAAAwB,cAAA,WAAAA,cAAA,CAAAG,QAAA,CAjIhBrE,IAAI,uHAAAkE,cAAA,CAAAG,QAAA,CACGpE,gBAAgB,mIAAAiE,cAAA,CAAAG,QAAA,CAChBnE,oBAAoB,uIAAAgE,cAAA,CAAAG,QAAA,CAE3BlE,SAAS,4HAAA+D,cAAA,CAAAG,QAAA,CAiBT5C,YAAY,+HAAAyC,cAAA,CAAAG,QAAA,CASZ3C,MAAM,yHAAAwC,cAAA,CAAAG,QAAA,CAAAJ,QAAA,kJAAAK,WAAA,UAAAH,oBAAA,mBAAAA,oBAAA,CAAAG,WAAA,GAAA5B,SAAA,CAAA4B,WAAA,IAAAA,WAAA,CAAAC,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}