{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  sqlaAutoGeneratedMetricRegex,\n  AGGREGATES } from\n'src/explore/constants';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL'\n};\n\nfunction inferSqlExpressionColumn(adhocMetric) {\n  if (\n  adhocMetric.sqlExpression &&\n  sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression))\n  {\n    const indexFirstCloseParen = adhocMetric.sqlExpression.indexOf(')');\n    const indexPairedOpenParen = adhocMetric.sqlExpression.\n    substring(0, indexFirstCloseParen).\n    lastIndexOf('(');\n    if (indexFirstCloseParen > 0 && indexPairedOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(\n        indexPairedOpenParen + 1,\n        indexFirstCloseParen\n      );\n    }\n  }\n  return null;\n}\n\nfunction inferSqlExpressionAggregate(adhocMetric) {\n  if (\n  adhocMetric.sqlExpression &&\n  sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression))\n  {\n    const indexFirstOpenParen = adhocMetric.sqlExpression.indexOf('(');\n    if (indexFirstOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(0, indexFirstOpenParen);\n    }\n  }\n  return null;\n}\n\nexport default class AdhocMetric {\n  constructor(adhocMetric) {\n    this.expressionType = adhocMetric.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      // try to be clever in the case of transitioning from Sql expression back to simple expression\n      const inferredColumn = inferSqlExpressionColumn(adhocMetric);\n      this.column =\n      adhocMetric.column ||\n      inferredColumn && { column_name: inferredColumn };\n      this.aggregate =\n      adhocMetric.aggregate || inferSqlExpressionAggregate(adhocMetric);\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression = adhocMetric.sqlExpression;\n      this.column = null;\n      this.aggregate = null;\n    }\n    this.datasourceWarning = !!adhocMetric.datasourceWarning;\n    this.hasCustomLabel = !!(adhocMetric.hasCustomLabel && adhocMetric.label);\n    this.label = this.hasCustomLabel ?\n    adhocMetric.label :\n    this.getDefaultLabel();\n\n    this.optionName =\n    adhocMetric.optionName ||\n    `metric_${Math.random().toString(36).substring(2, 15)}_${Math.random().\n    toString(36).\n    substring(2, 15)}`;\n  }\n\n  getDefaultLabel() {\n    return this.translateToSql({ useVerboseName: true });\n  }\n\n  translateToSql(\n  params = { useVerboseName: false, transformCountDistinct: false })\n  {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {var _this$column, _this$column2;\n      const aggregate = this.aggregate || '';\n      // eslint-disable-next-line camelcase\n      const column =\n      params.useVerboseName && (_this$column = this.column) != null && _this$column.verbose_name ?\n      `(${this.column.verbose_name})` :\n      (_this$column2 = this.column) != null && _this$column2.column_name ?\n      `(${this.column.column_name})` :\n      '';\n      // transform from `count_distinct(column)` to `count(distinct column)`\n      if (\n      params.transformCountDistinct &&\n      aggregate === AGGREGATES.COUNT_DISTINCT &&\n      /^\\(.*\\)$/.test(column))\n      {\n        return `COUNT(DISTINCT ${column.slice(1, -1)})`;\n      }\n      return aggregate + column;\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return this.sqlExpression;\n    }\n    return '';\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocMetric({\n      ...this,\n      ...nextFields\n    });\n  }\n\n  equals(adhocMetric) {\n    return (\n      adhocMetric.label === this.label &&\n      adhocMetric.expressionType === this.expressionType &&\n      adhocMetric.sqlExpression === this.sqlExpression &&\n      adhocMetric.aggregate === this.aggregate &&\n      (adhocMetric.column && adhocMetric.column.column_name) === (\n      this.column && this.column.column_name));\n\n  }\n\n  isValid() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      return !!(this.column && this.aggregate);\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!this.sqlExpression;\n    }\n    return false;\n  }\n\n  inferSqlExpressionAggregate() {\n    return inferSqlExpressionAggregate(this);\n  }\n\n  inferSqlExpressionColumn() {\n    return inferSqlExpressionColumn(this);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(EXPRESSION_TYPES, \"EXPRESSION_TYPES\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(inferSqlExpressionColumn, \"inferSqlExpressionColumn\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(inferSqlExpressionAggregate, \"inferSqlExpressionAggregate\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(AdhocMetric, \"AdhocMetric\", \"/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["sqlaAutoGeneratedMetricRegex","AGGREGATES","EXPRESSION_TYPES","SIMPLE","SQL","inferSqlExpressionColumn","adhocMetric","sqlExpression","test","indexFirstCloseParen","indexOf","indexPairedOpenParen","substring","lastIndexOf","inferSqlExpressionAggregate","indexFirstOpenParen","AdhocMetric","constructor","expressionType","inferredColumn","column","column_name","aggregate","datasourceWarning","hasCustomLabel","label","getDefaultLabel","optionName","Math","random","toString","translateToSql","useVerboseName","params","transformCountDistinct","_this$column","_this$column2","verbose_name","COUNT_DISTINCT","slice","duplicateWith","nextFields","equals","isValid","__reactstandin__regenerateByEval","key","code","eval","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  sqlaAutoGeneratedMetricRegex,\n  AGGREGATES,\n} from 'src/explore/constants';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL',\n};\n\nfunction inferSqlExpressionColumn(adhocMetric) {\n  if (\n    adhocMetric.sqlExpression &&\n    sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression)\n  ) {\n    const indexFirstCloseParen = adhocMetric.sqlExpression.indexOf(')');\n    const indexPairedOpenParen = adhocMetric.sqlExpression\n      .substring(0, indexFirstCloseParen)\n      .lastIndexOf('(');\n    if (indexFirstCloseParen > 0 && indexPairedOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(\n        indexPairedOpenParen + 1,\n        indexFirstCloseParen,\n      );\n    }\n  }\n  return null;\n}\n\nfunction inferSqlExpressionAggregate(adhocMetric) {\n  if (\n    adhocMetric.sqlExpression &&\n    sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression)\n  ) {\n    const indexFirstOpenParen = adhocMetric.sqlExpression.indexOf('(');\n    if (indexFirstOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(0, indexFirstOpenParen);\n    }\n  }\n  return null;\n}\n\nexport default class AdhocMetric {\n  constructor(adhocMetric) {\n    this.expressionType = adhocMetric.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      // try to be clever in the case of transitioning from Sql expression back to simple expression\n      const inferredColumn = inferSqlExpressionColumn(adhocMetric);\n      this.column =\n        adhocMetric.column ||\n        (inferredColumn && { column_name: inferredColumn });\n      this.aggregate =\n        adhocMetric.aggregate || inferSqlExpressionAggregate(adhocMetric);\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression = adhocMetric.sqlExpression;\n      this.column = null;\n      this.aggregate = null;\n    }\n    this.datasourceWarning = !!adhocMetric.datasourceWarning;\n    this.hasCustomLabel = !!(adhocMetric.hasCustomLabel && adhocMetric.label);\n    this.label = this.hasCustomLabel\n      ? adhocMetric.label\n      : this.getDefaultLabel();\n\n    this.optionName =\n      adhocMetric.optionName ||\n      `metric_${Math.random().toString(36).substring(2, 15)}_${Math.random()\n        .toString(36)\n        .substring(2, 15)}`;\n  }\n\n  getDefaultLabel() {\n    return this.translateToSql({ useVerboseName: true });\n  }\n\n  translateToSql(\n    params = { useVerboseName: false, transformCountDistinct: false },\n  ) {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      const aggregate = this.aggregate || '';\n      // eslint-disable-next-line camelcase\n      const column =\n        params.useVerboseName && this.column?.verbose_name\n          ? `(${this.column.verbose_name})`\n          : this.column?.column_name\n            ? `(${this.column.column_name})`\n            : '';\n      // transform from `count_distinct(column)` to `count(distinct column)`\n      if (\n        params.transformCountDistinct &&\n        aggregate === AGGREGATES.COUNT_DISTINCT &&\n        /^\\(.*\\)$/.test(column)\n      ) {\n        return `COUNT(DISTINCT ${column.slice(1, -1)})`;\n      }\n      return aggregate + column;\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return this.sqlExpression;\n    }\n    return '';\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocMetric({\n      ...this,\n      ...nextFields,\n    });\n  }\n\n  equals(adhocMetric) {\n    return (\n      adhocMetric.label === this.label &&\n      adhocMetric.expressionType === this.expressionType &&\n      adhocMetric.sqlExpression === this.sqlExpression &&\n      adhocMetric.aggregate === this.aggregate &&\n      (adhocMetric.column && adhocMetric.column.column_name) ===\n        (this.column && this.column.column_name)\n    );\n  }\n\n  isValid() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      return !!(this.column && this.aggregate);\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!this.sqlExpression;\n    }\n    return false;\n  }\n\n  inferSqlExpressionAggregate() {\n    return inferSqlExpressionAggregate(this);\n  }\n\n  inferSqlExpressionColumn() {\n    return inferSqlExpressionColumn(this);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}