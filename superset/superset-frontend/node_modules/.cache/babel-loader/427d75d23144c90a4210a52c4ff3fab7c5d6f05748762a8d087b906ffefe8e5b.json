{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Geometry } from '@luma.gl/core';\nimport { CompositeLayer, COORDINATE_SYSTEM, log } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer } from '@deck.gl/mesh-layers';\nimport { default as MeshLayer } from '../mesh-layer/mesh-layer';\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nconst SINGLE_DATA = [0];\nconst defaultProps = {\n  getPointColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  pointSize: 1.0,\n  data: '',\n  loader: Tiles3DLoader,\n  onTilesetLoad: {\n    type: 'function',\n    value: (tileset3d) => {}\n  },\n  onTileLoad: {\n    type: 'function',\n    value: (tileHeader) => {}\n  },\n  onTileUnload: {\n    type: 'function',\n    value: (tileHeader) => {}\n  },\n  onTileError: {\n    type: 'function',\n    value: (tile, message, url) => {}\n  },\n  _getMeshColor: {\n    type: 'function',\n    value: (tileHeader) => [255, 255, 255]\n  }\n};\nexport default class Tile3DLayer extends CompositeLayer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n\n  get isLoaded() {\n    const {\n      tileset3d\n    } = this.state;\n    return tileset3d !== null && tileset3d.isLoaded();\n  }\n\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    if (props.data && props.data !== oldProps.data) {\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {\n        activeViewports\n      } = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n\n    if (changeFlags.propsChanged) {\n      const {\n        layerMap\n      } = this.state;\n\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n\n  activateViewport(viewport) {\n    const {\n      activeViewports,\n      lastUpdatedViewports\n    } = this.state;\n    this.internalState.viewport = viewport;\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports === null || lastUpdatedViewports === void 0 ? void 0 : lastUpdatedViewports[viewport.id];\n\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({\n        viewportChanged: true\n      });\n      this.setNeedsUpdate();\n    }\n  }\n\n  getPickingInfo({\n    info,\n    sourceLayer\n  }) {\n    const sourceTile = sourceLayer && sourceLayer.props.tile;\n\n    if (info.picked) {\n      info.object = sourceTile;\n    }\n\n    info.sourceTile = sourceTile;\n    return info;\n  }\n\n  filterSubLayer({\n    layer,\n    viewport\n  }) {\n    const {\n      tile\n    } = layer.props;\n    const {\n      id: viewportId\n    } = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n\n  _updateAutoHighlight(info) {\n    const sourceTile = info.sourceTile;\n    const layerCache = this.state.layerMap[sourceTile === null || sourceTile === void 0 ? void 0 : sourceTile.id];\n\n    if (layerCache && layerCache.layer) {\n      layerCache.layer.updateAutoHighlight(info);\n    }\n  }\n\n  async _loadTileset(tilesetUrl) {\n    const {\n      loadOptions = {}\n    } = this.props;\n    let loader = this.props.loader || this.props.loaders;\n\n    if (Array.isArray(loader)) {\n      loader = loader[0];\n    }\n\n    const options = {\n      loadOptions: { ...loadOptions\n      }\n    };\n    let actualTilesetUrl = tilesetUrl;\n\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n\n      if (preloadOptions.url) {\n        actualTilesetUrl = preloadOptions.url;\n      }\n\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = { ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n\n      Object.assign(options, preloadOptions);\n    }\n\n    const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileError: this.props.onTileError,\n      ...options\n    });\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(this.state.activeViewports);\n\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  _onTileLoad(tileHeader) {\n    const {\n      lastUpdatedViewports\n    } = this.state;\n    this.props.onTileLoad(tileHeader);\n\n    this._updateTileset(lastUpdatedViewports);\n\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tileHeader) {\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  _updateTileset(viewports) {\n    if (!viewports) {\n      return;\n    }\n\n    const {\n      tileset3d\n    } = this.state;\n    const {\n      timeline\n    } = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n\n    tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {\n      const tilesetChanged = this.state.frameNumber !== frameNumber;\n\n      if (tilesetChanged) {\n        this.setState({\n          frameNumber\n        });\n      }\n    });\n  }\n\n  _getSubLayer(tileHeader, oldLayer) {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer);\n\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader);\n\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n\n      default:\n        throw new Error(\"Tile3DLayer: Failed to render layer of type \".concat(tileHeader.content.type));\n    }\n  }\n\n  _makePointCloudLayer(tileHeader, oldLayer) {\n    const {\n      attributes,\n      pointCount,\n      constantRGBA,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const {\n      positions,\n      normals,\n      colors\n    } = attributes;\n\n    if (!positions) {\n      return null;\n    }\n\n    const data = oldLayer && oldLayer.props.data || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n    const {\n      pointSize,\n      getPointColor\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass({\n      pointSize\n    }, this.getSubLayerProps({\n      id: 'pointcloud'\n    }), {\n      id: \"\".concat(this.id, \"-pointcloud-\").concat(tileHeader.id),\n      tile: tileHeader,\n      data,\n      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n      coordinateOrigin: cartographicOrigin,\n      modelMatrix,\n      getColor: constantRGBA || getPointColor,\n      _offset: 0\n    });\n  }\n\n  _make3DModelLayer(tileHeader) {\n    const {\n      gltf,\n      instances,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n    return new SubLayerClass({\n      _lighting: 'pbr'\n    }, this.getSubLayerProps({\n      id: 'scenegraph'\n    }), {\n      id: \"\".concat(this.id, \"-scenegraph-\").concat(tileHeader.id),\n      tile: tileHeader,\n      data: instances || SINGLE_DATA,\n      scenegraph: gltf,\n      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n      coordinateOrigin: cartographicOrigin,\n      modelMatrix,\n      getTransformMatrix: (instance) => instance.modelMatrix,\n      getPosition: [0, 0, 0],\n      _offset: 0\n    });\n  }\n\n  _makeSimpleMeshLayer(tileHeader, oldLayer) {\n    const content = tileHeader.content;\n    const {\n      attributes,\n      indices,\n      modelMatrix,\n      cartographicOrigin,\n      coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,\n      material,\n      featureIds\n    } = content;\n    const {\n      _getMeshColor\n    } = this.props;\n    const geometry = oldLayer && oldLayer.props.mesh || new Geometry({\n      drawMode: 4,\n      attributes: getMeshGeometry(attributes),\n      indices\n    });\n    const SubLayerClass = this.getSubLayerClass('mesh', MeshLayer);\n    return new SubLayerClass(this.getSubLayerProps({\n      id: 'mesh'\n    }), {\n      id: \"\".concat(this.id, \"-mesh-\").concat(tileHeader.id),\n      tile: tileHeader,\n      mesh: geometry,\n      data: SINGLE_DATA,\n      getColor: _getMeshColor(tileHeader),\n      pbrMaterial: material,\n      modelMatrix,\n      coordinateOrigin: cartographicOrigin,\n      coordinateSystem,\n      featureIds,\n      _offset: 0\n    });\n  }\n\n  renderLayers() {\n    const {\n      tileset3d,\n      layerMap\n    } = this.state;\n\n    if (!tileset3d) {\n      return null;\n    }\n\n    return tileset3d.tiles.map((tile) => {\n      const layerCache = layerMap[tile.id] = layerMap[tile.id] || {\n        tile\n      };\n      let {\n        layer\n      } = layerCache;\n\n      if (tile.selected) {\n        if (!layer) {\n          layer = this._getSubLayer(tile);\n        } else if (layerCache.needsUpdate) {\n          layer = this._getSubLayer(tile, layer);\n          layerCache.needsUpdate = false;\n        }\n      }\n\n      layerCache.layer = layer;\n      return layer;\n    }).filter(Boolean);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\n_defineProperty(Tile3DLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(Tile3DLayer, \"layerName\", 'Tile3DLayer');\n\nfunction getMeshGeometry(contentAttributes) {\n  const attributes = {};\n  attributes.positions = { ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n\n  return attributes;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(SINGLE_DATA, \"SINGLE_DATA\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/tile-3d-layer/tile-3d-layer.js\");reactHotLoader.register(defaultProps, \"defaultProps\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/tile-3d-layer/tile-3d-layer.js\");reactHotLoader.register(Tile3DLayer, \"Tile3DLayer\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/tile-3d-layer/tile-3d-layer.js\");reactHotLoader.register(getMeshGeometry, \"getMeshGeometry\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/node_modules/@deck.gl/geo-layers/dist/esm/tile-3d-layer/tile-3d-layer.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["Geometry","CompositeLayer","COORDINATE_SYSTEM","log","PointCloudLayer","ScenegraphLayer","default","MeshLayer","load","Tileset3D","TILE_TYPE","Tiles3DLoader","SINGLE_DATA","defaultProps","getPointColor","type","value","pointSize","data","loader","onTilesetLoad","tileset3d","onTileLoad","tileHeader","onTileUnload","onTileError","tile","message","url","_getMeshColor","Tile3DLayer","constructor","args","_defineProperty","initializeState","props","removed","state","layerMap","activeViewports","lastUpdatedViewports","isLoaded","shouldUpdateState","changeFlags","somethingChanged","updateState","oldProps","_loadTileset","viewportChanged","viewportsNumber","Object","keys","length","_updateTileset","propsChanged","key","needsUpdate","activateViewport","viewport","internalState","id","lastViewport","equals","setChangeFlags","setNeedsUpdate","getPickingInfo","info","sourceLayer","sourceTile","picked","object","filterSubLayer","layer","viewportId","selected","viewportIds","includes","_updateAutoHighlight","layerCache","updateAutoHighlight","tilesetUrl","loadOptions","loaders","Array","isArray","options","actualTilesetUrl","preload","preloadOptions","headers","fetch","assign","tilesetJson","_onTileLoad","bind","_onTileUnload","setState","viewports","timeline","context","selectTiles","values","then","frameNumber","tilesetChanged","_getSubLayer","oldLayer","content","POINTCLOUD","_makePointCloudLayer","SCENEGRAPH","_make3DModelLayer","MESH","_makeSimpleMeshLayer","Error","concat","attributes","pointCount","constantRGBA","cartographicOrigin","modelMatrix","positions","normals","colors","header","vertexCount","POSITION","NORMAL","COLOR_0","SubLayerClass","getSubLayerClass","getSubLayerProps","coordinateSystem","METER_OFFSETS","coordinateOrigin","getColor","_offset","gltf","instances","_lighting","scenegraph","getTransformMatrix","instance","getPosition","indices","material","featureIds","geometry","mesh","drawMode","getMeshGeometry","pbrMaterial","renderLayers","tiles","map","filter","Boolean","__reactstandin__regenerateByEval","code","eval","contentAttributes","Float32Array","texCoords","uvRegions","reactHotLoader","reactHotLoaderGlobal","undefined","register","leaveModule","module"],"sources":["../../../src/tile-3d-layer/tile-3d-layer.ts"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {Geometry} from '@luma.gl/core';\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  COORDINATE_SYSTEM,\n  FilterContext,\n  GetPickingInfoParams,\n  Layer,\n  LayersList,\n  log,\n  PickingInfo,\n  UpdateParameters,\n  Viewport,\n  DefaultProps\n} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\nimport {ScenegraphLayer} from '@deck.gl/mesh-layers';\nimport {default as MeshLayer} from '../mesh-layer/mesh-layer';\n\nimport {load} from '@loaders.gl/core';\nimport {MeshAttributes} from '@loaders.gl/schema';\nimport {Tileset3D, Tile3D, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Tiles3DLoader} from '@loaders.gl/3d-tiles';\n\nconst SINGLE_DATA = [0];\n\nconst defaultProps: DefaultProps<Tile3DLayerProps> = {\n  getPointColor: {type: 'accessor', value: [0, 0, 0, 255]},\n  pointSize: 1.0,\n\n  // Disable async data loading (handling it in _loadTileSet)\n  data: '',\n  loader: Tiles3DLoader,\n\n  onTilesetLoad: {type: 'function', value: tileset3d => {}},\n  onTileLoad: {type: 'function', value: tileHeader => {}},\n  onTileUnload: {type: 'function', value: tileHeader => {}},\n  onTileError: {type: 'function', value: (tile, message, url) => {}},\n  _getMeshColor: {type: 'function', value: tileHeader => [255, 255, 255]}\n};\n\n/** All properties supported by Tile3DLayer */\nexport type Tile3DLayerProps<DataT = any> = _Tile3DLayerProps<DataT> & CompositeLayerProps;\n\n/** Props added by the Tile3DLayer */\ntype _Tile3DLayerProps<DataT> = {\n  data: string;\n  /** Color Accessor for point clouds. **/\n  getPointColor?: Accessor<DataT, Color>;\n\n  /** Global radius of all points in pixels. **/\n  pointSize?: number;\n\n  /** A loader which is used to decode the fetched tiles.\n   * @deprecated Use `loaders` instead\n   */\n  loader?: typeof Tiles3DLoader;\n\n  /** Called when Tileset JSON file is loaded. **/\n  onTilesetLoad?: (tile: Tileset3D) => void;\n\n  /** Called when a tile in the tileset hierarchy is loaded. **/\n  onTileLoad?: (tile: Tile3D) => void;\n\n  /** Called when a tile is unloaded. **/\n  onTileUnload?: (tile: Tile3D) => void;\n\n  /** Called when a tile fails to load. **/\n  onTileError?: (tile: Tile3D, url: string, message: string) => void;\n\n  /** (Experimental) Accessor to change color of mesh based on properties. **/\n  _getMeshColor?: (tile: Tile3D) => Color;\n};\n\n/** Render 3d tiles data formatted according to the [3D Tiles Specification](https://www.opengeospatial.org/standards/3DTiles) and [`ESRI I3S`](https://github.com/Esri/i3s-spec) */\nexport default class Tile3DLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_Tile3DLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'Tile3DLayer';\n\n  state!: {\n    activeViewports: {};\n    frameNumber?: number;\n    lastUpdatedViewports: {[viewportId: string]: Viewport} | null;\n    layerMap: {[layerId: string]: any};\n    tileset3d: Tileset3D | null;\n  };\n\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n\n  get isLoaded(): boolean {\n    const {tileset3d} = this.state;\n    return tileset3d !== null && tileset3d.isLoaded();\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>): boolean {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}: UpdateParameters<this>): void {\n    if (props.data && props.data !== oldProps.data) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {activeViewports} = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n    if (changeFlags.propsChanged) {\n      const {layerMap} = this.state;\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n\n  activateViewport(viewport: Viewport): void {\n    const {activeViewports, lastUpdatedViewports} = this.state;\n    this.internalState!.viewport = viewport;\n\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports?.[viewport.id];\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({viewportChanged: true});\n      this.setNeedsUpdate();\n    }\n  }\n\n  getPickingInfo({info, sourceLayer}: GetPickingInfoParams) {\n    const sourceTile = sourceLayer && (sourceLayer.props as any).tile;\n    if (info.picked) {\n      info.object = sourceTile;\n    }\n    (info as any).sourceTile = sourceTile;\n\n    return info;\n  }\n\n  filterSubLayer({layer, viewport}: FilterContext): boolean {\n    // All sublayers will have a tile prop\n    const {tile} = layer.props as unknown as {tile: Tile3D};\n    const {id: viewportId} = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    const sourceTile = (info as any).sourceTile;\n    const layerCache = this.state.layerMap[sourceTile?.id];\n    if (layerCache && layerCache.layer) {\n      layerCache.layer.updateAutoHighlight(info);\n    }\n  }\n\n  private async _loadTileset(tilesetUrl) {\n    const {loadOptions = {}} = this.props;\n\n    // TODO: deprecate `loader` in v9.0\n    // @ts-ignore\n    let loader = this.props.loader || this.props.loaders;\n    if (Array.isArray(loader)) {\n      loader = loader[0];\n    }\n\n    const options = {loadOptions: {...loadOptions}};\n    let actualTilesetUrl = tilesetUrl;\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n      if (preloadOptions.url) {\n        actualTilesetUrl = preloadOptions.url;\n      }\n\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = {\n          ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);\n\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileError: this.props.onTileError,\n      ...options\n    });\n\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(this.state.activeViewports);\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  private _onTileLoad(tileHeader: Tile3D): void {\n    const {lastUpdatedViewports} = this.state;\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(lastUpdatedViewports);\n    this.setNeedsUpdate();\n  }\n\n  private _onTileUnload(tileHeader: Tile3D): void {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  private _updateTileset(viewports: {[viewportId: string]: Viewport} | null): void {\n    if (!viewports) {\n      return;\n    }\n    const {tileset3d} = this.state;\n    const {timeline} = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    tileset3d.selectTiles(Object.values(viewports)).then(frameNumber => {\n      const tilesetChanged = this.state.frameNumber !== frameNumber;\n      if (tilesetChanged) {\n        this.setState({frameNumber});\n      }\n    });\n  }\n\n  private _getSubLayer(\n    tileHeader: Tile3D,\n    oldLayer?: Layer\n  ): MeshLayer<DataT> | PointCloudLayer<DataT> | ScenegraphLayer<DataT> | null {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer as PointCloudLayer<DataT>);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader);\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer as MeshLayer<DataT>);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n\n  private _makePointCloudLayer(\n    tileHeader: Tile3D,\n    oldLayer?: PointCloudLayer<DataT>\n  ): PointCloudLayer<DataT> | null {\n    const {attributes, pointCount, constantRGBA, cartographicOrigin, modelMatrix} =\n      tileHeader.content;\n    const {positions, normals, colors} = attributes;\n\n    if (!positions) {\n      return null;\n    }\n    const data = (oldLayer && oldLayer.props.data) || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n\n    const {pointSize, getPointColor} = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass(\n      {\n        pointSize\n      },\n      this.getSubLayerProps({\n        id: 'pointcloud'\n      }),\n      {\n        id: `${this.id}-pointcloud-${tileHeader.id}`,\n        tile: tileHeader,\n        data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getColor: constantRGBA || getPointColor,\n        _offset: 0\n      }\n    );\n  }\n\n  private _make3DModelLayer(tileHeader: Tile3D): ScenegraphLayer<DataT> {\n    const {gltf, instances, cartographicOrigin, modelMatrix} = tileHeader.content;\n\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n\n    return new SubLayerClass(\n      {\n        _lighting: 'pbr'\n      },\n      this.getSubLayerProps({\n        id: 'scenegraph'\n      }),\n      {\n        id: `${this.id}-scenegraph-${tileHeader.id}`,\n        tile: tileHeader,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getTransformMatrix: instance => instance.modelMatrix,\n        getPosition: [0, 0, 0],\n        _offset: 0\n      }\n    );\n  }\n\n  private _makeSimpleMeshLayer(tileHeader: Tile3D, oldLayer?: MeshLayer<DataT>): MeshLayer<DataT> {\n    const content = tileHeader.content;\n    const {\n      attributes,\n      indices,\n      modelMatrix,\n      cartographicOrigin,\n      coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,\n      material,\n      featureIds\n    } = content;\n    const {_getMeshColor} = this.props;\n\n    const geometry =\n      (oldLayer && oldLayer.props.mesh) ||\n      new Geometry({\n        drawMode: GL.TRIANGLES,\n        attributes: getMeshGeometry(attributes),\n        indices\n      });\n\n    const SubLayerClass = this.getSubLayerClass('mesh', MeshLayer);\n\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        id: `${this.id}-mesh-${tileHeader.id}`,\n        tile: tileHeader,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getColor: _getMeshColor(tileHeader),\n        pbrMaterial: material,\n        modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem,\n        featureIds,\n        _offset: 0\n      }\n    );\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const {tileset3d, layerMap} = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n\n    // loaders.gl doesn't provide a type for tileset3d.tiles\n    return (tileset3d.tiles as Tile3D[])\n      .map(tile => {\n        const layerCache = (layerMap[tile.id] = layerMap[tile.id] || {tile});\n        let {layer} = layerCache;\n        if (tile.selected) {\n          // render selected tiles\n          if (!layer) {\n            // create layer\n            layer = this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            // props have changed, rerender layer\n            layer = this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          }\n        }\n        layerCache.layer = layer;\n        return layer;\n      })\n      .filter(Boolean);\n  }\n}\n\nfunction getMeshGeometry(contentAttributes: MeshAttributes): MeshAttributes {\n  const attributes: MeshAttributes = {};\n  attributes.positions = {\n    ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n  return attributes;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}