{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\nimport { AnnotationOpacity, AnnotationType, AxisType, evalExpression, isRecordAnnotationResult, isTableAnnotationLayer, isTimeseriesAnnotationResult } from '@superset-ui/core';\nexport function evalFormula(formula, data, xAxis, xAxisType) {\n  const { value: expression } = formula;\n  return data.map((row) => {\n    let value = row[xAxis];\n    if (xAxisType === AxisType.Time) {\n      value = new Date(value).getTime();\n    }\n    return [value, evalExpression(expression, value || 0)];\n  });\n}\nexport function parseAnnotationOpacity(opacity) {\n  switch (opacity) {\n    case AnnotationOpacity.Low:\n      return 0.2;\n    case AnnotationOpacity.Medium:\n      return 0.5;\n    case AnnotationOpacity.High:\n      return 0.8;\n    default:\n      return 1;\n  }\n}\nconst NATIVE_COLUMN_NAMES = {\n  descriptionColumns: ['long_descr'],\n  intervalEndColumn: 'end_dttm',\n  timeColumn: 'start_dttm',\n  titleColumn: 'short_descr'\n};\nexport function extractRecordAnnotations(annotationLayer, annotationData) {\n  const { name } = annotationLayer;\n  const result = annotationData[name];\n  if (isRecordAnnotationResult(result)) {\n    const { records } = result;\n    const { descriptionColumns = [], intervalEndColumn = '', timeColumn = '', titleColumn = '' } = isTableAnnotationLayer(annotationLayer) ?\n    annotationLayer :\n    NATIVE_COLUMN_NAMES;\n    return records.map((record) => ({\n      descriptions: descriptionColumns.map((column) => record[column] || ''),\n      intervalEnd: record[intervalEndColumn] || '',\n      time: record[timeColumn] || '',\n      title: record[titleColumn] || ''\n    }));\n  }\n  throw new Error('Please rerun the query.');\n}\nexport function formatAnnotationLabel(name, title, descriptions = []) {\n  const labels = [];\n  const titleLabels = [];\n  const filteredDescriptions = descriptions.filter((description) => !!description);\n  if (name)\n  titleLabels.push(name);\n  if (title)\n  titleLabels.push(title);\n  if (titleLabels.length > 0)\n  labels.push(titleLabels.join(' - '));\n  if (filteredDescriptions.length > 0)\n  labels.push(filteredDescriptions.join('\\n'));\n  return labels.join('\\n\\n');\n}\nexport function extractAnnotationLabels(layers, data) {\n  const formulaAnnotationLabels = layers.\n  filter((anno) => anno.annotationType === AnnotationType.Formula && anno.show).\n  map((anno) => anno.name);\n  const timeseriesAnnotationLabels = layers.\n  filter((anno) => anno.annotationType === AnnotationType.Timeseries && anno.show).\n  flatMap((anno) => {\n    const result = data[anno.name];\n    return isTimeseriesAnnotationResult(result) ?\n    result.map((annoSeries) => annoSeries.key) :\n    [];\n  });\n  return formulaAnnotationLabels.concat(timeseriesAnnotationLabels);\n}\nexport function getAnnotationData(chartProps) {var _chartProps$queriesDa;\n  const data = chartProps == null ? void 0 : (_chartProps$queriesDa = chartProps.queriesData[0]) == null ? void 0 : _chartProps$queriesDa.annotation_data;\n  if (!_isEmpty(data)) {\n    return data;\n  }\n  return {};\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(evalFormula, \"evalFormula\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(parseAnnotationOpacity, \"parseAnnotationOpacity\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(NATIVE_COLUMN_NAMES, \"NATIVE_COLUMN_NAMES\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(extractRecordAnnotations, \"extractRecordAnnotations\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(formatAnnotationLabel, \"formatAnnotationLabel\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(extractAnnotationLabels, \"extractAnnotationLabels\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(getAnnotationData, \"getAnnotationData\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","AnnotationOpacity","AnnotationType","AxisType","evalExpression","isRecordAnnotationResult","isTableAnnotationLayer","isTimeseriesAnnotationResult","evalFormula","formula","data","xAxis","xAxisType","value","expression","map","row","Time","Date","getTime","parseAnnotationOpacity","opacity","Low","Medium","High","NATIVE_COLUMN_NAMES","descriptionColumns","intervalEndColumn","timeColumn","titleColumn","extractRecordAnnotations","annotationLayer","annotationData","name","result","records","record","descriptions","column","intervalEnd","time","title","Error","formatAnnotationLabel","labels","titleLabels","filteredDescriptions","filter","description","push","length","join","extractAnnotationLabels","layers","formulaAnnotationLabels","anno","annotationType","Formula","show","timeseriesAnnotationLabels","Timeseries","flatMap","annoSeries","key","concat","getAnnotationData","chartProps","_chartProps$queriesDa","queriesData","annotation_data","_isEmpty","reactHotLoader","register","leaveModule"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isEmpty } from 'lodash';\n\nimport {\n  Annotation,\n  AnnotationData,\n  AnnotationLayer,\n  AnnotationOpacity,\n  AnnotationType,\n  AxisType,\n  DataRecord,\n  evalExpression,\n  FormulaAnnotationLayer,\n  isRecordAnnotationResult,\n  isTableAnnotationLayer,\n  isTimeseriesAnnotationResult,\n} from '@superset-ui/core';\nimport { EchartsTimeseriesChartProps } from '../types';\nimport { EchartsMixedTimeseriesProps } from '../MixedTimeseries/types';\n\nexport function evalFormula(\n  formula: FormulaAnnotationLayer,\n  data: DataRecord[],\n  xAxis: string,\n  xAxisType: AxisType,\n): [any, number][] {\n  const { value: expression } = formula;\n\n  return data.map(row => {\n    let value = row[xAxis];\n    if (xAxisType === AxisType.Time) {\n      value = new Date(value as string).getTime();\n    }\n    return [value, evalExpression(expression, (value || 0) as number)];\n  });\n}\n\nexport function parseAnnotationOpacity(opacity?: AnnotationOpacity): number {\n  switch (opacity) {\n    case AnnotationOpacity.Low:\n      return 0.2;\n    case AnnotationOpacity.Medium:\n      return 0.5;\n    case AnnotationOpacity.High:\n      return 0.8;\n    default:\n      return 1;\n  }\n}\n\nconst NATIVE_COLUMN_NAMES = {\n  descriptionColumns: ['long_descr'],\n  intervalEndColumn: 'end_dttm',\n  timeColumn: 'start_dttm',\n  titleColumn: 'short_descr',\n};\n\nexport function extractRecordAnnotations(\n  annotationLayer: AnnotationLayer,\n  annotationData: AnnotationData,\n): Annotation[] {\n  const { name } = annotationLayer;\n  const result = annotationData[name];\n  if (isRecordAnnotationResult(result)) {\n    const { records } = result;\n    const {\n      descriptionColumns = [],\n      intervalEndColumn = '',\n      timeColumn = '',\n      titleColumn = '',\n    } = isTableAnnotationLayer(annotationLayer)\n      ? annotationLayer\n      : NATIVE_COLUMN_NAMES;\n\n    return records.map(record => ({\n      descriptions: descriptionColumns.map(\n        column => (record[column] || '') as string,\n      ) as string[],\n      intervalEnd: (record[intervalEndColumn] || '') as string,\n      time: (record[timeColumn] || '') as string,\n      title: (record[titleColumn] || '') as string,\n    }));\n  }\n  throw new Error('Please rerun the query.');\n}\n\nexport function formatAnnotationLabel(\n  name?: string,\n  title?: string,\n  descriptions: string[] = [],\n): string {\n  const labels: string[] = [];\n  const titleLabels: string[] = [];\n  const filteredDescriptions = descriptions.filter(\n    description => !!description,\n  );\n  if (name) titleLabels.push(name);\n  if (title) titleLabels.push(title);\n  if (titleLabels.length > 0) labels.push(titleLabels.join(' - '));\n  if (filteredDescriptions.length > 0)\n    labels.push(filteredDescriptions.join('\\n'));\n  return labels.join('\\n\\n');\n}\n\nexport function extractAnnotationLabels(\n  layers: AnnotationLayer[],\n  data: AnnotationData,\n): string[] {\n  const formulaAnnotationLabels = layers\n    .filter(anno => anno.annotationType === AnnotationType.Formula && anno.show)\n    .map(anno => anno.name);\n  const timeseriesAnnotationLabels = layers\n    .filter(\n      anno => anno.annotationType === AnnotationType.Timeseries && anno.show,\n    )\n    .flatMap(anno => {\n      const result = data[anno.name];\n      return isTimeseriesAnnotationResult(result)\n        ? result.map(annoSeries => annoSeries.key)\n        : [];\n    });\n\n  return formulaAnnotationLabels.concat(timeseriesAnnotationLabels);\n}\n\nexport function getAnnotationData(\n  chartProps: EchartsTimeseriesChartProps | EchartsMixedTimeseriesProps,\n): AnnotationData {\n  const data = chartProps?.queriesData[0]?.annotation_data as AnnotationData;\n  if (!isEmpty(data)) {\n    return data;\n  }\n  return {};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}