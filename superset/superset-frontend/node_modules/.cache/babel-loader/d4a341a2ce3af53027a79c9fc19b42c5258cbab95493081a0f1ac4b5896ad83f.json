{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { buildQueryContext, ensureIsArray, getMetricLabel, isPhysicalColumn, QueryMode, removeDuplicates } from '@superset-ui/core';\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.Aggregate || mode === QueryMode.Raw) {\n    return mode;\n  }\n  const rawColumns = formData == null ? void 0 : formData.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.Raw : QueryMode.Aggregate;\n}\nconst buildQuery = (formData, options) => {\n  const { percent_metrics: percentMetrics, order_desc: orderDesc = false, extra_form_data } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  const time_grain_sqla = (extra_form_data == null ? void 0 : extra_form_data.time_grain_sqla) || formData.time_grain_sqla;\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.Raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false\n    };\n  }\n  return buildQueryContext(formDataCopy, (baseQueryObject) => {var _options$ownState, _options$extras, _options$extras$cache, _options$extras2, _options$extras2$cach, _options$hooks2, _metrics2, _formData$extra_form_;\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    let postProcessing = [];\n    if (queryMode === QueryMode.Aggregate) {var _metrics;\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else\n      if (((_metrics = metrics) == null ? void 0 : _metrics.length) > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricLabels = removeDuplicates(percentMetrics.map(getMetricLabel));\n        metrics = removeDuplicates(metrics.concat(percentMetrics), getMetricLabel);\n        postProcessing = [\n        {\n          operation: 'contribution',\n          options: {\n            columns: percentMetricLabels,\n            rename_columns: percentMetricLabels.map((x) => `%${x}`)\n          }\n        }];\n\n      }\n      columns = columns.map((col) => {var _formData$temporal_co;\n        if (isPhysicalColumn(col) &&\n        time_grain_sqla &&\n        formData != null && (_formData$temporal_co = formData.temporal_columns_lookup) != null && _formData$temporal_co[col]) {\n          return {\n            timeGrain: time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL'\n          };\n        }\n        return col;\n      });\n    }\n    const moreProps = {};\n    const ownState = (_options$ownState = options == null ? void 0 : options.ownState) != null ? _options$ownState : {};\n    if (formDataCopy.server_pagination) {var _ownState$pageSize, _ownState$currentPage, _ownState$pageSize2;\n      moreProps.row_limit = (_ownState$pageSize =\n      ownState.pageSize) != null ? _ownState$pageSize : formDataCopy.server_page_length;\n      moreProps.row_offset =\n      ((_ownState$currentPage = ownState.currentPage) != null ? _ownState$currentPage : 0) * ((_ownState$pageSize2 = ownState.pageSize) != null ? _ownState$pageSize2 : 0);\n    }\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      ...moreProps\n    };\n    if (formData.server_pagination &&\n    options != null && (_options$extras = options.extras) != null && (_options$extras$cache = _options$extras.cachedChanges) != null && _options$extras$cache[formData.slice_id] &&\n    JSON.stringify(options == null ? void 0 : (_options$extras2 = options.extras) == null ? void 0 : (_options$extras2$cach = _options$extras2.cachedChanges) == null ? void 0 : _options$extras2$cach[formData.slice_id]) !==\n    JSON.stringify(queryObject.filters)) {var _options$hooks, _queryObject$row_limi;\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(options == null ? void 0 : (_options$hooks = options.hooks) == null ? void 0 : _options$hooks.setDataMask, 0, (_queryObject$row_limi = queryObject.row_limit) != null ? _queryObject$row_limi : 0);\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options == null ? void 0 : (_options$hooks2 = options.hooks) == null ? void 0 : _options$hooks2.setCachedChanges({\n      [formData.slice_id]: queryObject.filters\n    });\n    const extraQueries = [];\n    if ((_metrics2 = metrics) != null && _metrics2.length &&\n    formData.show_totals &&\n    queryMode === QueryMode.Aggregate) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        order_desc: undefined,\n        orderby: undefined // because this query will be used for get total aggregation.\n      });\n    }\n    const interactiveGroupBy = (_formData$extra_form_ = formData.extra_form_data) == null ? void 0 : _formData$extra_form_.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n      ...new Set([...queryObject.columns, ...interactiveGroupBy])];\n\n    }\n    if (formData.server_pagination) {\n      return [\n      { ...queryObject },\n      {\n        ...queryObject,\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        is_rowcount: true\n      },\n      ...extraQueries];\n\n    }\n    return [queryObject, ...extraQueries];\n  });\n};\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = () => {\n  let cachedChanges = {};\n  const setCachedChanges = (newChanges) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n  return (formData, options) => {var _options$ownState2;return buildQuery({ ...formData }, {\n      extras: { cachedChanges },\n      ownState: (_options$ownState2 = options == null ? void 0 : options.ownState) != null ? _options$ownState2 : {},\n      hooks: {\n        ...(options == null ? void 0 : options.hooks),\n        setDataMask: () => {},\n        setCachedChanges\n      }\n    });};\n};const _default =\ncachedBuildQuery();export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getQueryMode, \"getQueryMode\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(buildQuery, \"buildQuery\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(cachedBuildQuery, \"cachedBuildQuery\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(_default, \"default\", \"/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["buildQueryContext","ensureIsArray","getMetricLabel","isPhysicalColumn","QueryMode","removeDuplicates","updateExternalFormData","getQueryMode","formData","query_mode","mode","Aggregate","Raw","rawColumns","all_columns","hasRawColumns","length","buildQuery","options","percent_metrics","percentMetrics","order_desc","orderDesc","extra_form_data","queryMode","sortByMetric","timeseries_limit_metric","time_grain_sqla","formDataCopy","include_time","baseQueryObject","_options$ownState","_options$extras","_options$extras$cache","_options$extras2","_options$extras2$cach","_options$hooks2","_metrics2","_formData$extra_form_","metrics","orderby","columns","postProcessing","_metrics","percentMetricLabels","map","concat","operation","rename_columns","x","col","_formData$temporal_co","temporal_columns_lookup","timeGrain","columnType","sqlExpression","label","expressionType","moreProps","ownState","server_pagination","_ownState$pageSize","_ownState$currentPage","_ownState$pageSize2","row_limit","pageSize","server_page_length","row_offset","currentPage","queryObject","post_processing","extras","cachedChanges","slice_id","JSON","stringify","filters","_options$hooks","_queryObject$row_limi","hooks","setDataMask","setCachedChanges","extraQueries","show_totals","push","undefined","interactiveGroupBy","interactive_groupby","Set","is_rowcount","cachedBuildQuery","newChanges","_options$ownState2","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/home/pawank/Documents/dcim/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AdhocColumn,\n  buildQueryContext,\n  ensureIsArray,\n  getMetricLabel,\n  isPhysicalColumn,\n  QueryMode,\n  QueryObject,\n  removeDuplicates,\n} from '@superset-ui/core';\nimport { PostProcessingRule } from '@superset-ui/core/src/query/types/PostProcessing';\nimport { BuildQuery } from '@superset-ui/core/src/chart/registries/ChartBuildQueryRegistrySingleton';\nimport { TableChartFormData } from './types';\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData: TableChartFormData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.Aggregate || mode === QueryMode.Raw) {\n    return mode;\n  }\n  const rawColumns = formData?.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.Raw : QueryMode.Aggregate;\n}\n\nconst buildQuery: BuildQuery<TableChartFormData> = (\n  formData: TableChartFormData,\n  options,\n) => {\n  const {\n    percent_metrics: percentMetrics,\n    order_desc: orderDesc = false,\n    extra_form_data,\n  } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  const time_grain_sqla =\n    extra_form_data?.time_grain_sqla || formData.time_grain_sqla;\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.Raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false,\n    };\n  }\n\n  return buildQueryContext(formDataCopy, baseQueryObject => {\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    let postProcessing: PostProcessingRule[] = [];\n\n    if (queryMode === QueryMode.Aggregate) {\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else if (metrics?.length > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricLabels = removeDuplicates(\n          percentMetrics.map(getMetricLabel),\n        );\n        metrics = removeDuplicates(\n          metrics.concat(percentMetrics),\n          getMetricLabel,\n        );\n        postProcessing = [\n          {\n            operation: 'contribution',\n            options: {\n              columns: percentMetricLabels,\n              rename_columns: percentMetricLabels.map(x => `%${x}`),\n            },\n          },\n        ];\n      }\n\n      columns = columns.map(col => {\n        if (\n          isPhysicalColumn(col) &&\n          time_grain_sqla &&\n          formData?.temporal_columns_lookup?.[col]\n        ) {\n          return {\n            timeGrain: time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL',\n          } as AdhocColumn;\n        }\n        return col;\n      });\n    }\n\n    const moreProps: Partial<QueryObject> = {};\n    const ownState = options?.ownState ?? {};\n    if (formDataCopy.server_pagination) {\n      moreProps.row_limit =\n        ownState.pageSize ?? formDataCopy.server_page_length;\n      moreProps.row_offset =\n        (ownState.currentPage ?? 0) * (ownState.pageSize ?? 0);\n    }\n\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      ...moreProps,\n    };\n\n    if (\n      formData.server_pagination &&\n      options?.extras?.cachedChanges?.[formData.slice_id] &&\n      JSON.stringify(options?.extras?.cachedChanges?.[formData.slice_id]) !==\n        JSON.stringify(queryObject.filters)\n    ) {\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(\n        options?.hooks?.setDataMask,\n        0,\n        queryObject.row_limit ?? 0,\n      );\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options?.hooks?.setCachedChanges({\n      [formData.slice_id]: queryObject.filters,\n    });\n\n    const extraQueries: QueryObject[] = [];\n    if (\n      metrics?.length &&\n      formData.show_totals &&\n      queryMode === QueryMode.Aggregate\n    ) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        order_desc: undefined, // we don't need orderby stuff here,\n        orderby: undefined, // because this query will be used for get total aggregation.\n      });\n    }\n\n    const interactiveGroupBy = formData.extra_form_data?.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n        ...new Set([...queryObject.columns, ...interactiveGroupBy]),\n      ];\n    }\n\n    if (formData.server_pagination) {\n      return [\n        { ...queryObject },\n        {\n          ...queryObject,\n          row_limit: 0,\n          row_offset: 0,\n          post_processing: [],\n          is_rowcount: true,\n        },\n        ...extraQueries,\n      ];\n    }\n\n    return [queryObject, ...extraQueries];\n  });\n};\n\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = (): BuildQuery<TableChartFormData> => {\n  let cachedChanges: any = {};\n  const setCachedChanges = (newChanges: any) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n\n  return (formData, options) =>\n    buildQuery(\n      { ...formData },\n      {\n        extras: { cachedChanges },\n        ownState: options?.ownState ?? {},\n        hooks: {\n          ...options?.hooks,\n          setDataMask: () => {},\n          setCachedChanges,\n        },\n      },\n    );\n};\n\nexport default cachedBuildQuery();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}